Info file: calc.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `calc.texinfo'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the author
instead of in the original English.




File: calc.info, Node: Rewrites Answer 3, Next: Rewrites Answer 4, Prev: Rewrites Answer 2, Up: Answers to Exercises

Rewrites Tutorial Exercise 3
----------------------------

He got an infinite loop.  First, Calc did as expected and rewrote
`2 + 3 x' to `f(2, 3, x)'.  Then it looked for ways to
apply the rule again, and found that `f(2, 3, x)' looks like
`a + b x' with `a = 0' and `b = 1', so it rewrote to
`f(0, 1, f(2, 3, x))'.  It then wrapped another `f(0, 1, ...)'
around that, and so on, ad infinitum.  Joe should have used `M-1 a r'
to make sure the rule applied only once.

(Actually, even the first step didn't work as he expected.  What Calc
really gives for `M-1 a r' in this situation is `f(3 x, 1, 2)',
treating 2 as the "variable," and `3 x' as a constant being added
to it.  While this may seem odd, it's just as valid a solution as the
"obvious" one.  One way to fix this would be to add the condition
`:: variable(x)' to the rule, to make sure the thing that matches
`x' is indeed a variable, or to change `x' to `quote(x)'
on the lefthand side, so that the rule matches the actual variable
`x' rather than letting `x' stand for something else.)



File: calc.info, Node: Rewrites Answer 4, Next: Rewrites Answer 5, Prev: Rewrites Answer 3, Up: Answers to Exercises

Rewrites Tutorial Exercise 4
----------------------------

Here is a suitable set of rules to solve the first part of the
problem:

     [ seq(n, c) := seq(n/2,  c+1) :: n%2 = 0,
       seq(n, c) := seq(3n+1, c+1) :: n%2 = 1 :: n > 1 ]

Given the initial formula `seq(6, 0)', application of these rules
produces the following sequence of formulas:

     seq( 3, 1)
     seq(10, 2)
     seq( 5, 3)
     seq(16, 4)
     seq( 8, 5)
     seq( 4, 6)
     seq( 2, 7)
     seq( 1, 8)

whereupon neither of the rules match, and rewriting stops.

We can pretty this up a bit with a couple more rules:

     [ seq(n) := seq(n, 0),
       seq(1, c) := c,
       ... ]

Now, given `seq(6)' as the starting configuration, we get 8 as the
result.

The change to return a vector is quite simple:

     [ seq(n) := seq(n, []) :: integer(n) :: n > 0,
       seq(1, v) := v | 1,
       seq(n, v) := seq(n/2,  v | n) :: n%2 = 0,
       seq(n, v) := seq(3n+1, v | n) :: n%2 = 1 ]

Given `seq(6)', the result is `[6, 3, 10, 5, 16, 8, 4, 2, 1]'.

Notice that the `n > 1' guard is no longer necessary on the last rule
since the `n = 1' case is now detected by another rule.  But a guard
has been added to the initial rule to make sure the initial value is
suitable before the computation begins.

While still a good idea, this guard is not as vitally important as it
was for the `fib' function, since calling, say, `seq(x, [])' will not
get into an infinite loop.  Calc will not be able to prove the symbol
`x' is either even or odd, so none of the rules will apply and the
rewrites will stop right away.



File: calc.info, Node: Rewrites Answer 5, Next: Rewrites Answer 6, Prev: Rewrites Answer 4, Up: Answers to Exercises

Rewrites Tutorial Exercise 5
----------------------------

If `x' is the sum `a + b', then `nterms(x)' must be `nterms(a)' plus
`nterms(b)'.  If `x' is not a sum, then `nterms(x)' = 1.

     [ nterms(a + b) := nterms(a) + nterms(b),
       nterms(x)     := 1 ]

Here we have taken advantage of the fact that earlier rules always
match before later rules; `nterms(x)' will only be tried if we already
know that `x' is not a sum.



File: calc.info, Node: Rewrites Answer 6, Next: Rewrites Answer 7, Prev: Rewrites Answer 5, Up: Answers to Exercises

Rewrites Tutorial Exercise 6
----------------------------

Just put the rule `0^0 := 1' into `EvalRules'.  For example, before
making this definition we have:

     2:  [-2, -1, 0, 1, 2]                1:  [1, 1, 0^0, 1, 1]
     1:  0                                    .
	 .

	 v x 5 RET  3 -  0                    V M ^

But then:

     2:  [-2, -1, 0, 1, 2]                1:  [1, 1, 1, 1, 1]
     1:  0                                    .
	 .

	 U  ' 0^0:=1 RET s t EvalRules RET    V M ^

Perhaps more surprisingly, this rule still works with infinite mode
turned on.  Calc tries `EvalRules' before any built-in rules for
a function.  This allows you to override the default behavior of any
Calc feature:  Even though Calc now wants to evaluate `0^0' to
`nan', your rule gets there first and evaluates it to 1 instead.

Just for kicks, try adding the rule `2+3 := 6' to `EvalRules'.  What
happens?  (Be sure to remove this rule afterward, or you might get a
nasty surprise when you use Calc to balance your checkbook!)



File: calc.info, Node: Rewrites Answer 7, Next: Programming Answer 1, Prev: Rewrites Answer 6, Up: Answers to Exercises

Rewrites Tutorial Exercise 7
----------------------------

Here is a rule set that will do the job:

     [ a*(b + c) := a*b + a*c,
       opt(a) O(x^n) + opt(b) O(x^m) := O(x^n) :: n <= m
	  :: constant(a) :: constant(b),
       opt(a) O(x^n) + opt(b) x^m := O(x^n) :: n <= m
	  :: constant(a) :: constant(b),
       a O(x^n) := O(x^n) :: constant(a),
       x^opt(m) O(x^n) := O(x^(n+m)),
       O(x^n) O(x^m) := O(x^(n+m)) ]

If we really want the `+' and `*' keys to operate naturally on power
series, we should put these rules in `EvalRules'.  For testing
purposes, it is better to put them in a different variable, say, `O',
first.

The first rule just expands products of sums so that the rest of the
rules can assume they have an expanded-out polynomial to work with.
Note that this rule does not mention `O' at all, so it will apply to
any product-of-sum it encounters--this rule may surprise you if you
put it into `EvalRules'!

In the second rule, the sum of two O's is changed to the smaller O.
The optional constant coefficients are there mostly so that `O(x^2) -
O(x^3)' and `O(x^3) - O(x^2)' are handled as well as `O(x^2) +
O(x^3)'.

The third rule absorbs higher powers of `x' into O's.

The fourth rule says that a constant times a negligible quantity is
still negligible.  (This rule will also match `O(x^3) / 4', with `a =
1/4'.)

The fifth rule rewrites, for example, `x^2 O(x^3)' to `O(x^5)'.
(It is easy to see that if one of these forms is negligible, the other
is, too.)  Notice the `x^opt(m)' to pick up terms like
`x O(x^3)'.  Optional powers will match `x' as `x^1'
but not 1 as `x^0'.  This turns out to be exactly what we want here.

The sixth rule is the corresponding rule for products of two O's.

Another way to solve this problem would be to create a new "data type"
that represents truncated power series.  We might represent these as
function calls `series(COEFS, X)' where COEFS is a vector of
coefficients for `x^0', `x^1', `x^2', and so on.  Rules would exist
for sums and products of such `series' objects, and as an optional
convenience could also know how to combine a `series' object with a
normal polynomial.  (With this, and with a rule that rewrites `O(x^n)'
to the equivalent `series' form, you could still enter power series in
exactly the same notation as before.)  Operations on such objects
would probably be more efficient, although the objects would be a bit
harder to read.

Some other symbolic math programs provide a power series data type
similar to this.  Mathematica, for example, has an object that looks
like `PowerSeries[X, X0, COEFS, NMIN, NMAX, DEN]', where X0 is the
point about which the power series is taken (we've been assuming this
was always zero), and NMIN, NMAX, and DEN allow pseudo-power-series
with fractional or negative powers.  Also, the `PowerSeries' objects
have a special display format that makes them look like `2 x^2 +
O(x^4)' when they are printed out.  (*Note Compositions::, for a way
to do this in Calc, although for something as involved as this it
would probably be better to write the formatting routine in Lisp.)



File: calc.info, Node: Programming Answer 1, Next: Programming Answer 2, Prev: Rewrites Answer 7, Up: Answers to Exercises

Programming Tutorial Exercise 1
-------------------------------

Just enter the formula `ninteg(sin(t)/t, t, 0, x)', type `Z F', and
answer the questions.  Since this formula contains two variables, the
default argument list will be `(t x)'.  We want to change this to
`(x)' since `t' is really a dummy variable to be used within `ninteg'.

The exact keystrokes are `Z F s Si RET RET C-b C-b DEL DEL RET y'.
(The `C-b C-b DEL DEL' are what fix the argument list.)



File: calc.info, Node: Programming Answer 2, Next: Programming Answer 3, Prev: Programming Answer 1, Up: Answers to Exercises

Programming Tutorial Exercise 2
-------------------------------

One way is to move the number to the top of the stack, operate on it,
then move it back: `C-x ( M-TAB n M-TAB M-TAB C-x )'.

Another way is to negate the top three stack entries, then negate
again the top two stack entries: `C-x ( M-3 n M-2 n C-x )'.

Finally, it turns out that a negative prefix argument causes a command
like `n' to operate on the specified stack entry only, which is just
what we want: `C-x ( M-- 3 n C-x )'.

Just for kicks, let's also do it algebraically:
`C-x ( ' -$$$, $$, $ RET C-x )'.



File: calc.info, Node: Programming Answer 3, Next: Programming Answer 4, Prev: Programming Answer 2, Up: Answers to Exercises

Programming Tutorial Exercise 3
-------------------------------

Each of these functions can be computed using the stack, or using
algebraic entry, whichever way you prefer:

Computing `sin(x) / x':

Using the stack: `C-x ( RET S TAB / C-x )'.

Using algebraic entry: `C-x ( ' sin($)/$ RET C-x )'.

Computing the logarithm:

Using the stack: `C-x ( TAB B C-x )'

Using algebraic entry: `C-x ( ' log($,$$) RET C-x )'.

Computing the vector of integers:

Using the stack: `C-x ( 1 RET 1 C-u v x C-x )'.  (Recall that `C-u v
x' takes the vector size, starting value, and increment from the
stack.)

Alternatively: `C-x ( ~ v x C-x )'.  (The `~' key pops a number from
the stack and uses it as the prefix argument for the next command.)

Using algebraic entry: `C-x ( ' index($) RET C-x )'.



File: calc.info, Node: Programming Answer 4, Next: Programming Answer 5, Prev: Programming Answer 3, Up: Answers to Exercises

Programming Tutorial Exercise 4
-------------------------------

Here's one way: `C-x ( RET V R + TAB v l / C-x )'.



File: calc.info, Node: Programming Answer 5, Next: Programming Answer 6, Prev: Programming Answer 4, Up: Answers to Exercises

Programming Tutorial Exercise 5
-------------------------------

     2:  1              1:  1.61803398502         2:  1.61803398502
     1:  20                 .                     1:  1.61803398875
	 .                                            .

        1RET 20         Z < & 1 + Z >                I H P

This answer is quite accurate.



File: calc.info, Node: Programming Answer 6, Next: Programming Answer 7, Prev: Programming Answer 5, Up: Answers to Exercises

Programming Tutorial Exercise 6
-------------------------------

Here is the matrix:

     [ [ 0, 1 ]   * [a, b] = [b, a + b]
       [ 1, 1 ] ]

Thus `[0, 1; 1, 1]^n * [1, 1]' computes Fibonacci numbers `n+1' and
`n+2'.  Here's one program that does the job:

     C-x ( ' [0, 1; 1, 1] ^ ($-1) * [1, 1] RET v u DEL C-x )

This program is quite efficient because Calc knows how to raise a
matrix (or other value) to the power `n' in only `log(n,2)' steps.
For example, this program can compute the 1000th Fibonacci number (a
209-digit integer!) in about 10 steps; even though the `Z < ... Z >'
solution had much simpler steps, it would have required so many steps
that it would not have been practical.



File: calc.info, Node: Programming Answer 7, Next: Programming Answer 8, Prev: Programming Answer 6, Up: Answers to Exercises

Programming Tutorial Exercise 7
-------------------------------

The trick here is to compute the harmonic numbers differently, so that
the loop counter itself accumulates the sum of reciprocals.  We use a
separate variable to hold the integer counter.

     1:  1          2:  1       1:  .
	 .          1:  4
                        .

	 1 t 1       1 RET 4      Z ( t 2 r 1 1 + s 1 & Z )

The body of the loop goes as follows: First save the harmonic sum so
far in variable 2.  Then delete it from the stack; the for loop itself
will take care of remembering it for us.  Next, recall the count from
variable 1, add one to it, and feed its reciprocal to the for loop to
use as the step value.  The for loop will increase the "loop counter"
by that amount and keep going until the loop counter exceeds 4.

     2:  31                  3:  31
     1:  3.99498713092       2:  3.99498713092
	 .                   1:  4.02724519544
				 .

	 r 1 r 2                 RET 31 & +

Thus we find that the 30th harmonic number is 3.99, and the 31st
harmonic number is 4.02.



File: calc.info, Node: Programming Answer 8, Next: Programming Answer 9, Prev: Programming Answer 7, Up: Answers to Exercises

Programming Tutorial Exercise 8
-------------------------------

The first step is to compute the derivative `f'(x)' and thus
the formula `x - f(x)/f'(x)'.

(Because this definition is long, it will be repeated in concise form
below.  You can use `M-# m' to load it from there.  While you are
entering a `Z ` Z '' body in a macro, Calc simply collects
keystrokes without executing them.  In the following diagrams we'll
pretend Calc actually executed the keystrokes as you typed them,
just for purposes of illustration.)

     2:  sin(cos(x)) - 0.5            3:  4.5
     1:  4.5                          2:  sin(cos(x)) - 0.5
	 .                            1:  -(sin(x) cos(cos(x)))
					  .

     ' sin(cos(x))-0.5 RET 4.5  m r  C-x ( Z `  TAB RET a d x RET

     2:  4.5
     1:  x + (sin(cos(x)) - 0.5) / sin(x) cos(cos(x))
	 .

	 /  ' x RET TAB -   t 1

Now, we enter the loop.  We'll use a repeat loop with a 20-repetition
limit just in case the method fails to converge for some reason.
(Normally, the `Z /' command will stop the loop before all 20
repetitions are done.)

     1:  4.5         3:  4.5                     2:  4.5
	 .           2:  x + (sin(cos(x)) ...    1:  5.24196456928
		     1:  4.5                         .
			 .

       20 Z <          RET r 1 TAB                 s l x RET

This is the new guess for `x'.  Now we compare it with the old one to
see if we've converged.

     3:  5.24196     2:  5.24196     1:  5.24196     1:  5.26345856348
     2:  5.24196     1:  0               .               .
     1:  4.5             .
	 .

       RET M-TAB         a =             Z /             Z > Z ' C-x )

The loop converges in just a few steps to this value.  To check the
result, we can simply substitute it back into the equation.

     2:  5.26345856348
     1:  0.499999999997
	 .

      RET ' sin(cos($)) RET

Let's test the new definition again:

     2:  x^2 - 9           1:  3.
     1:  1                     .
	 .

       ' x^2-9 RET 1           X

Once again, here's the full Newton's Method definition:

     C-x ( Z `  TAB RET a d x RET  /  ' x RET TAB -  t 1
                20 Z <  RET r 1 TAB  s l x RET
                        RET M-TAB  a =  Z /
		   Z >
	   Z '
     C-x )

It turns out that Calc has a built-in command for applying a formula
repeatedly until it converges to a number.  *Note Nesting and Fixed
Points::, to see how to use it.

Also, of course, `a R' is a built-in command that uses Newton's
method (among others) to look for numerical solutions to any equation.
*Note Root Finding::.



File: calc.info, Node: Programming Answer 9, Next: Programming Answer 10, Prev: Programming Answer 8, Up: Answers to Exercises

Programming Tutorial Exercise 9
-------------------------------

The first step is to adjust `z' to be greater than 5.  A simple
"for" loop will do the job here.  If `z' is less than 5, we
reduce the problem using `psi(z) = psi(z+1) - 1/z'.  We go
on to compute `psi(z+1)', and remember to add back a factor of
`-1/z' when we're done.  This step is repeated until `z > 5'.

(Because this definition is long, it will be repeated in concise form
below.  You can use `M-# m' to load it from there.  While you are
entering a `Z ` Z '' body in a macro, Calc simply collects
keystrokes without executing them.  In the following diagrams we'll
pretend Calc actually executed the keystrokes as you typed them,
just for purposes of illustration.)

     1:  1.             1:  1.
	 .                  .

      1.0 RET       C-x ( Z `  s 1  0 t 2

Here, variable 1 holds `z' and variable 2 holds the adjustment factor.
If `z < 5', we use a loop to increase it.

(By the way, we started with `1.0' instead of the integer 1 because
otherwise the calculation below will try to do exact fractional
arithmetic, and will never converge because fractions compare equal
only if they are exactly equal, not just equal to within the current
precision.)

     3:  1.      2:  1.       1:  6.
     2:  1.      1:  1            .
     1:  5           .
	 .

       RET 5        a <    Z [  5 Z (  & s + 2  1 s + 1  1 Z ) r 1  Z ]

Now we compute the initial part of the sum: `ln(z) - 1/2z' minus the
adjustment factor.

     2:  1.79175946923      2:  1.7084261359      1:  -0.57490719743
     1:  0.0833333333333    1:  2.28333333333         .
	 .                      .

	 L  r 1 2 * &           -  r 2                -

Now we evaluate the series.  We'll use another "for" loop counting
up the value of `2 n'.  (Calc does have a summation command,
`a +', but we'll use loops just to get more practice with them.)

     3:  -0.5749       3:  -0.5749        4:  -0.5749      2:  -0.5749
     2:  2             2:  1:6            3:  1:6          1:  2.3148e-3
     1:  40            1:  2              2:  2                .
	 .                 .              1:  36.
					      .

        2RET 40        Z ( RET k b TAB     RET r 1 TAB ^      * /

     3:  -0.5749       3:  -0.5772      2:  -0.5772     1:  -0.577215664892
     2:  -0.5749       2:  -0.5772      1:  0               .
     1:  2.3148e-3     1:  -0.5749          .
	 .                 .

       TAB RET M-TAB       - RET M-TAB      a =     Z /    2  Z )  Z ' C-x )

This is the value of `- gamma', with a slight bit of roundoff error.
To get a full 12 digits, let's use a higher precision:

     2:  -0.577215664892      2:  -0.577215664892
     1:  1.                   1:  -0.577215664901532

	 1. RET                   p 16 RET X

Here's the complete sequence of keystrokes:

     C-x ( Z `  s 1  0 t 2
                RET 5 a <  Z [  5 Z (  & s + 2  1 s + 1  1 Z ) r 1  Z ]
                Lr 1 2 * & - r 2 -
                2RET 40  Z (  RET k b TAB RET r 1 TAB ^ * /
			       TAB RET M-TAB - RET M-TAB a = Z /
		       2  Z )
	   Z '
     C-x )



File: calc.info, Node: Programming Answer 10, Next: Programming Answer 11, Prev: Programming Answer 9, Up: Answers to Exercises

Programming Tutorial Exercise 10
--------------------------------

Taking the derivative of a term of the form `x^n' will produce a term
like `n x^(n-1)'.  Taking the derivative of a constant produces zero.
From this it is easy to see that the `n'th derivative of a polynomial,
evaluated at `x = 0', will equal the coefficient on the `x^n' term
times `n!'.

(Because this definition is long, it will be repeated in concise form
below.  You can use `M-# m' to load it from there.  While you are
entering a `Z ` Z '' body in a macro, Calc simply collects
keystrokes without executing them.  In the following diagrams we'll
pretend Calc actually executed the keystrokes as you typed them,
just for purposes of illustration.)

     2:  5 x^4 + (x + 1)^2          3:  5 x^4 + (x + 1)^2
     1:  6                          2:  0
	 .                          1:  6
                                        .

       ' 5 x^4 + (x+1)^2 RET 6        C-x ( Z `  [ ] t 1  0 TAB

Variable 1 will accumulate the vector of coefficients.

     2:  0              3:  0                  2:  5 x^4 + ...
     1:  5 x^4 + ...    2:  5 x^4 + ...        1:  1
	 .              1:  1                      .
			    .

        Z( TAB         RET 0 s l x RET            M-TAB ! /  s | 1

Note that `s | 1' appends the top-of-stack value to the vector in a
variable; it is completely analogous to `s + 1'.  We could have
written instead, `r 1 TAB | t 1'.

     1:  20 x^3 + 2 x + 2      1:  0         1:  [1, 2, 1, 0, 5, 0, 0]
	 .                         .             .

	 a d x RET                 1 Z )         DEL r 1  Z ' C-x )

To convert back, a simple method is just to map the coefficients
against a table of powers of `x'.

     2:  [1, 2, 1, 0, 5, 0, 0]    2:  [1, 2, 1, 0, 5, 0, 0]
     1:  6                        1:  [0, 1, 2, 3, 4, 5, 6]
	 .                            .

	 6 RET                        1 + 0 RET 1 C-u v x

     2:  [1, 2, 1, 0, 5, 0, 0]    2:  1 + 2 x + x^2 + 5 x^4
     1:  [1, x, x^2, x^3, ... ]       .
	 .

	 ' x RET TAB V M ^            *

Once again, here are the whole polynomial to/from vector programs:

     C-x ( Z `  [ ] t 1  0 TAB
                Z(  TAB RET 0 s l x RET M-TAB ! /  s | 1
		     a d x RET
	      1 Z ) r 1
	   Z '
     C-x )

     C-x (  1 + 0 RET 1 C-u v x ' x RET TAB V M ^ *  C-x )



File: calc.info, Node: Programming Answer 11, Next: Programming Answer 12, Prev: Programming Answer 10, Up: Answers to Exercises

Programming Tutorial Exercise 11
--------------------------------

First we define a dummy program to go on the `z s' key.  The true
`z s' key is supposed to take two numbers from the stack and
return one number, so `DEL' as a dummy definition will make
sure the stack comes out right.

     2:  4          1:  4                         2:  4
     1:  2              .                         1:  2
	 .                                            .

       4 RET 2       C-x ( DEL C-x )  Z K s RET       2

The last step replaces the 2 that was eaten during the creation of the
dummy `z s' command.  Now we move on to the real definition.  The
recurrence needs to be rewritten slightly, to the form `s(n,m) =
s(n-1,m-1) - (n-1) s(n-1,m)'.

(Because this definition is long, it will be repeated in concise form
below.  You can use `M-# m' to load it from there.)

     2:  4        4:  4       3:  4       2:  4
     1:  2        3:  2       2:  2       1:  2
	 .        2:  4       1:  0           .
		  1:  2           .
		      .

       C-x (       M-2 RET        a =         Z [  DEL DEL 1  Z :

     4:  4       2:  4                     2:  3      4:  3    4:  3    3:  3
     3:  2       1:  2                     1:  2      3:  2    3:  2    2:  2
     2:  2           .                         .      2:  3    2:  3    1:  3
     1:  0                                            1:  2    1:  1        .
	 .                                                .        .

       RET 0   a = Z [  DEL DEL 0  Z :  TAB 1 - TAB   M-2 RET     1 -      z s

(Note that the value 3 that our dummy `z s' produces is not correct;
it is merely a placeholder that will do just as well for now.)

     3:  3               4:  3           3:  3       2:  3      1:  -6
     2:  3               3:  3           2:  3       1:  9          .
     1:  2               2:  3           1:  3           .
	 .               1:  2               .
			     .

      M-TAB M-TAB     TAB RET M-TAB         z s          *          -

     1:  -6                          2:  4          1:  11      2:  11
	 .                           1:  2              .       1:  11
					 .                          .

       Z ] Z ] C-x )   Z K s RET      DEL 4 RET 2       z s      M-RET k s

Even though the result that we got during the definition was highly
bogus, once the definition is complete the `z s' command gets the
right answers.

Here's the full program once again:

     C-x (  M-2 RET a =
	    Z [  DEL DEL 1
	    Z :  RET 0 a =
		 Z [  DEL DEL 0
		 Z :  TAB 1 - TAB M-2 RET 1 - z s
		      M-TAB M-TAB TAB RET M-TAB z s * -
		 Z ]
	    Z ]
     C-x )

You can read this definition using `M-# m' (`read-kbd-macro') followed
by `Z K s', without having to make a dummy definition first, because
`read-kbd-macro' doesn't need to execute the definition as it reads it
in.  For this reason, `M-# m' is often the easiest way to create
recursive programs in Calc.



File: calc.info, Node: Programming Answer 12, Prev: Programming Answer 11, Up: Answers to Exercises

Programming Tutorial Exercise 12
--------------------------------

This turns out to be a much easier way to solve the problem.  Let's
denote Stirling numbers as calls of the function `s'.

First, we store the rewrite rules corresponding to the definition of
Stirling numbers in a convenient variable:

     s e StirlingRules RET
     [ s(n,n) := 1  :: n >= 0,
       s(n,0) := 0  :: n > 0,
       s(n,m) := s(n-1,m-1) - (n-1) s(n-1,m) :: n >= m :: m >= 1 ]
     C-c C-c

Now, it's just a matter of applying the rules:

     2:  4          1:  s(4, 2)              1:  11
     1:  2              .                        .
	 .

       4 RET 2       C-x (  ' s($$,$) RET     a r StirlingRules RET  C-x )

As in the case of the `fib' rules, it would be useful to put these
rules in `EvalRules' and to add a `:: remember' condition to the last
rule.





File: calc.info, Node: Introduction, Next: Data Types, Prev: Tutorial, Up: Top

Introduction
************

This chapter is the beginning of the Calc reference manual.  It covers
basic concepts such as the stack, algebraic and numeric entry, undo,
numeric prefix arguments, etc.


* Menu:

* Basic Commands::
* Help Commands::
* Stack Basics::
* Numeric Entry::
* Algebraic Entry::
* Quick Calculator::
* Keypad Mode::
* Prefix Arguments::
* Undo::
* Error Messages::
* Multiple Calculators::
* Troubleshooting Commands::



File: calc.info, Node: Basic Commands, Next: Help Commands, Prev: Introduction, Up: Introduction

Basic Commands
==============

To start the Calculator in its standard interface, type `M-x calc'.
By default this creates a pair of small windows, `*Calculator*' and
`*Calc Trail*'.  The former displays the contents of the Calculator
stack and is manipulated exclusively through Calc commands.  It is
possible (though not usually necessary) to create several Calc Mode
buffers each of which has an independent stack, undo list, and mode
settings.  There is exactly one Calc Trail buffer; it records a list
of the results of all calculations that have been done.  The Calc
Trail buffer uses a variant of Calc Mode, so Calculator commands still
work when the trail buffer's window is selected.  It is possible to
turn the trail window off, but the `*Calc Trail*' buffer itself still
exists and is updated silently.  *Note Trail Commands::.

In most installations, the `M-# c' key sequence is a more convenient
way to start the Calculator.  Also, `M-# M-#' and `M-# #' are synonyms
for `M-# c' unless you last used Calc in its "keypad" mode.

Most Calc commands use one or two keystrokes.  Lower- and upper-case
letters are distinct.  Commands may also be entered in full `M-x'
form; for some commands this is the only form.  As a convenience, the
`x' key (`calc-execute-extended-command') is like `M-x' except that it
enters the initial string `calc-' for you.  For example, the following
key sequences are equivalent: `S', `M-x calc-sin RET', `x sin RET'.

The Calculator exists in many parts.  When you type `M-# c', the Emacs
auto-load" mechanism will bring in only the first part, which contains
the basic arithmetic functions.  The other parts will be auto-loaded
the first time you use the more advanced commands like trig functions
or matrix operations.  This is done to improve the response time of
the Calculator in the common case when all you need to do is a little
arithmetic.  If for some reason the Calculator fails to load an
extension module automatically, you can force it to load all the
extensions by using the `M-# L' (`calc-load-everything') command.
*Note Mode Settings::.

If you type `M-x calc' or `M-# c' with any numeric prefix argument,
the Calculator is loaded if necessary, but it is not actually started.
If the argument is positive, the `calc-ext' extensions are also loaded
if necessary.  User-written Lisp code that wishes to make use of
Calc's arithmetic routines can use `(calc 0)' or `(calc 1)' to
auto-load the Calculator.

If you type `M-# b', then next time you use `M-# c' you will get a
Calculator that uses the full height of the Emacs screen.  When
full-screen mode is on, `M-# c' runs the `full-calc' command instead
of `calc'.  From the Unix shell you can type `emacs -f full-calc' to
start a new Emacs specifically for use as a calculator.  When Calc is
started from the Emacs command line like this, Calc's normal "quit"
commands actually quit Emacs itself.

The `M-# o' command is like `M-# c' except that the Calc
window is not actually selected.  If you are already in the Calc
window, `M-# o' switches you out of it.  (The regular Emacs
`C-x o' command would also work for this, but it has a
tendency to drop you into the Calc Trail window instead, which
`M-# o' takes care not to do.)

For one quick calculation, you can type `M-# q' (`quick-calc') which
prompts you for a formula (like `2+3/4').  The result is displayed at
the bottom of the Emacs screen without ever creating any special
Calculator windows.  *Note Quick Calculator::.

Finally, if you are using the X window system you may want to try `M-#
k' (`calc-keypad') which runs Calc with a "calculator keypad" picture
as well as a stack display.  Click on the keys with the mouse to
operate the calculator.  *Note Keypad Mode::.

The `q' key (`calc-quit') exits Calc Mode and closes the Calculator's
window(s).  It does not delete the Calculator buffers.  If you type
`M-x calc' again, the Calculator will reappear with the contents of
the stack intact.  Typing `M-# c' or `M-# M-#' again from inside the
Calculator buffer is equivalent to executing `calc-quit'; you can
think of `M-# M-#' as toggling the Calculator on and off.

The `M-# x' command also turns the Calculator off, no matter which
user interface (standard, Keypad, or Embedded) is currently active.
It also cancels `calc-edit' mode if used from there.

The `d SPC' key sequence (`calc-refresh') redraws the contents of the
Calculator buffer from memory.  Use this if the contents of the buffer
have been damaged somehow.

The `o' key (`calc-realign') moves the cursor back to its "home"
position at the bottom of the Calculator buffer.

The `<' and `>' keys are bound to `calc-scroll-left' and
`calc-scroll-right'.  These are just like the normal horizontal
scrolling commands except that they scroll one half-screen at a time
by default.  (Calc formats its output to fit within the bounds of the
window whenever it can.)

The `{' and `}' keys are bound to `calc-scroll-down' and
`calc-scroll-up'.  They scroll up or down by one-half the height of
the Calc window.

The `M-# 0' command (`calc-reset'; that's `M-#' followed by a zero)
resets the Calculator to its default state.  This clears the stack,
resets all the modes, clears the caches (*Note Caches::), and so on.
(It does *not* erase the values of any variables.)  With a numeric
prefix argument, `M-# 0' preserves the contents of the stack but
resets everything else.

The `M-x calc-version' command displays the current version number of
Calc and the name of the person who installed it on your system.
(This information is also present in the `*Calc Trail*' buffer, and in
the output of the `h h' command.)



File: calc.info, Node: Help Commands, Next: Stack Basics, Prev: Basic Commands, Up: Introduction

Help Commands
=============

The `?' key (`calc-help') displays a series of brief help messages.
Some keys (such as `b' and `d') are prefix keys, like Emacs' ESC and
`C-x' prefixes.  You can type `?' after a prefix to see a list of
commands beginning with that prefix.  (If the message includes
`[MORE]', press `?' again to see additional commands for that prefix.)

The `h h' (`calc-full-help') command displays all the `?'  responses
at once.  When printed, this makes a nice, compact (three pages)
summary of Calc keystrokes.

In general, the `h' key prefix introduces various commands that
provide help within Calc.  Many of the `h' key functions are
Calc-specific analogues to the `C-h' functions for Emacs help.

The `h i' (`calc-info') command runs the Emacs Info system to read
this manual on-line.  This is basically the same as typing `C-h i'
(the regular way to run the Info system), then, if Info is not already
in the Calc manual, selecting the beginning of the manual.  The `M-#
i' command is another way to read the Calc manual; it is different
from `h i' in that it works any time, not just inside Calc.  The plain
`i' key is also equivalent to `h i', though this key is obsolete and
may be replaced with a different command in a future version of Calc.

The `h t' (`calc-tutorial') command runs the Info system on the
Tutorial section of the Calc manual.  It is like `h i', except that it
selects the starting node of the tutorial rather than the beginning of
the whole manual.  (It actually selects the node "Interactive
Tutorial" which tells a few things about using the Info system before
going on to the actual tutorial.)  The `M-# t' key is equivalent to `h
t' (but it works at all times).

The `h s' (`calc-info-summary') command runs the Info system on the
Summary node of the Calc manual.  *Note Summary::.  The `M-# s' key is
equivalent to `h s'.

The `h k' (`calc-describe-key') command looks up a key sequence in the
Calc manual.  For example, `h k H a S' looks up the documentation on
the `H a S' (`calc-solve-for') command.  This works by looking up the
textual description of the key(s) in the Key Index of the manual, then
jumping to the node indicated by the index.

Most Calc commands do not have traditional Emacs documentation
strings, since the `h k' command is both more convenient and more
instructive.  This means the regular Emacs `C-h k' (`describe-key')
command will not be useful for Calc keystrokes.

The `h c' (`calc-describe-key-briefly') command reads a key sequence
and displays a brief one-line description of it at the bottom of the
screen.  It looks for the key sequence in the Summary node of the Calc
manual; if it doesn't find the sequence there, it acts just like its
regular Emacs counterpart `C-h c' (`describe-key-briefly').  For
example, `h c H a S' gives the description:

     H a S runs calc-solve-for:  a `H a S' v  => fsolve(a,v)  (?=notes)

which means the command `H a S' or `H M-x calc-solve-for' takes a
value `a' from the stack, prompts for a value `v', then applies the
algebraic function `fsolve' to these values.  The `?=notes' message
means you can now type `?' to see additional notes from the summary
that apply to this command.

The `h f' (`calc-describe-function') command looks up an algebraic
function or a command name in the Calc manual.  The prompt initially
contains `calcFunc-'; follow this with an algebraic function name to
look up that function in the Function Index.  Or, backspace and enter
a command name beginning with `calc-' to look it up in the Command
Index.  This command will also look up operator symbols that can
appear in algebraic formulas, like `%' and `=>'.

The `h v' (`calc-describe-variable') command looks up a
variable in the Calc manual.  The prompt initially contains the
`var-' prefix; just add a variable name like `pi' or
`PlotRejects'.

The `h b' (`calc-describe-bindings') command is just like `C-h b',
except that only local (Calc-related) key bindings are listed.

The `h n' or `h C-n' (`calc-view-news') command displays the "news" or
change history of Calc.  This is kept in the file `README', which Calc
looks for in the same directory as the Calc source files.

The `h C-c', `h C-d', and `h C-w' keys display copying, distribution,
and warranty information about Calc.  These work by pulling up the
appropriate parts of the "Copying" or "Reporting Bugs" sections of the
manual.



File: calc.info, Node: Stack Basics, Next: Numeric Entry, Prev: Help Commands, Up: Introduction

Stack Basics
============

Calc uses RPN notation.  If you are not familar with RPN, *Note RPN
Tutorial::.

To add the numbers 1 and 2 in Calc you would type the keys: `1 RET 2
+'.  (RET corresponds to the ENTER key on most calculators.)  The
first three keystrokes "push" the numbers 1 and 2 onto the stack.  The
`+' key always "pops" the top two numbers from the stack, adds them,
and pushes the result (3) back onto the stack.  This number is ready
for further calculations: `5 -' pushes 5 onto the stack, then pops the
3 and 5, subtracts them, and pushes the result (-2).

Note that the "top" of the stack actually appears at the *bottom*
of the buffer.  A line containing a single `.' character signifies
the end of the buffer; Calculator commands operate on the number(s)
directly above this line.  The `d t' (`calc-truncate-stack')
command allows you to move the `.' marker up and down in the stack;
*Note Truncating the Stack::.

Stack elements are numbered consecutively, with number 1 being the top
of the stack.  These line numbers are ordinarily displayed on the
lefthand side of the window.  The `d l' (`calc-line-numbering')
command controls whether these numbers appear.  (Line numbers may be
turned off since they slow the Calculator down a bit and also clutter
the display.)

The unshifted letter `o' (`calc-realign') command repositions the
cursor to its top-of-stack "home" position.  It also undoes any
horizontal scrolling in the window.  If you give it a numeric prefix
argument, it instead moves the cursor to the specified stack element.

The RET (or equivalent SPC) key is only required to separate two
consecutive numbers.  (After all, if you typed `1 2' by themselves the
Calculator would enter the number 12.)  If you press `RET' or `SPC'
*not* right after typing a number, the key duplicates the number on
the top of the stack.  `RET *' is thus a handy way to square a number.

The DEL key pops and throws away the top number on the stack.  The TAB
key swaps the top two objects on the stack.  *Note Stack and Trail::,
for descriptions of these and other stack-related commands.



File: calc.info, Node: Numeric Entry, Next: Algebraic Entry, Prev: Stack Basics, Up: Introduction

Numeric Entry
=============

Pressing a digit or other numeric key begins numeric entry using the
minibuffer.  The number is pushed on the stack when you press the RET
or SPC keys.  If you press any other non-numeric key, the number is
pushed onto the stack and the appropriate operation is performed.  If
you press a numeric key which is not valid, the key is ignored.

There are three different concepts corresponding to the word "minus,"
typified by `a-b' (subtraction), `-x' (change-sign), and `-5'
(negative number).  Calc uses three different keys for these
operations, respectively: `-', `n', and `_' (the underscore).  The `-'
key subtracts the two numbers on the top of the stack.  The `n' key
changes the sign of the number on the top of the stack or the number
currently being entered.  The `_' key begins entry of a negative
number or changes the sign of the number currently being entered.  The
following sequences all enter the number -5 onto the stack: `0 RET
5 -', `5 n RET', `5 RET n', `_ 5 RET', `5 _ RET'.

Some other keys are active during numeric entry, such as `#' for
non-decimal numbers, `:' for fractions, and `@' for HMS forms.  These
notations are described later in this manual with the corresponding
data types.  *Note Data Types::.

During numeric entry, the only editing key available is `DEL'.



File: calc.info, Node: Algebraic Entry, Next: Quick Calculator, Prev: Numeric Entry, Up: Introduction

Algebraic Entry
===============

Calculations can also be entered in algebraic form.  This is
accomplished by typing the apostrophe key, `'', followed by the
expression in standard format: `' 2+3*4 RET' computes `2+(3*4) = 14'
and pushes that on the stack.  If you wish you can ignore the RPN
aspect of Calc altogether and simply enter algebraic expressions in
this way.  You may want to use DEL every so often to clear previous
results off the stack.

You can press the apostrophe key during normal numeric entry to switch
the half-entered number into algebraic entry mode.  One reason to do
this would be to use the full Emacs cursor motion and editing keys,
which are available during algebraic entry but not during numeric
entry.

In the same vein, during either numeric or algebraic entry you can
press ``' (backquote) to switch to `calc-edit' mode, where
you complete your half-finished entry in a separate buffer.
*Note Editing Stack Entries::.

If you prefer algebraic entry, you can use the command `m a'
(`calc-algebraic-mode') to set Algebraic mode.  In this mode, digits
and other keys that would normally start numeric entry instead start
full algebraic entry; as long as your formula begins with a digit you
can omit the apostrophe.  Open parentheses and square brackets also
begin algebraic entry.  You can still do RPN calculations in this
mode, but you will have to press RET to terminate every number: `2 RET
3 RET * 4 RET +' would accomplish the same thing as `2*3+4 RET'.

If you give a numeric prefix argument like `C-u' to the `m a' command,
it enables Incomplete Algebraic mode; this is like regular Algebraic
mode except that it applies to the `(' and `[' keys only.  Numeric
keys still begin a numeric entry in this mode.

The `m t' (`calc-total-algebraic-mode') gives you an even
stronger algebraic-entry mode, in which *all* regular letter and
punctuation keys begin algebraic entry.  Use this if you prefer typing
`sqrt( )' instead of `Q', `factor( )' instead of
`a f', and so on.  To type regular Calc commands when you are in
"total" algebraic mode, hold down the META key.  Thus `M-q'
is the command to quit Calc, `M-p' sets the precision, and
`M-m t' (or `M-m M-t', if you prefer) turns total algebraic
mode back off again.  Meta keys also terminate algebraic entry, so
that `2+3 M-S' is equivalent to `2+3 RET M-S'.  The symbol
`Alg*' will appear in the mode line whenever you are in this mode.

Pressing `'' (the apostrophe) a second time re-enters the previous
algebraic formula.  You can then use the normal Emacs editing keys to
modify this formula to your liking before pressing RET.

Within a formula entered from the keyboard, the symbol `$' represents
the number on the top of the stack.  If an entered formula contains
any `$' characters, the Calculator replaces the top of stack with that
formula rather than simply pushing the formula onto the stack.  Thus,
`' 1+2 RET' pushes 3 on the stack, and `$*2 RET' replaces it with 6.
Note that the `$' key always initiates algebraic entry; the `'' is
unnecessary if `$' is the first character in the new formula.

Higher stack elements can be accessed from an entered formula with the
symbols `$$', `$$$', and so on.  The number of stack elements removed
(to be replaced by the entered values) equals the number of dollar
signs in the longest such symbol in the formula.  For example,
`$$+$$$' adds the second and third stack elements, replacing the top
three elements with the answer.  (All information about the top stack
element is thus lost since no single `$' appears in this formula.)

A slightly different way to refer to stack elements is with a dollar
sign followed by a number: `$1', `$2', and so on are much like `$',
`$$', etc., except that stack entries referred to numerically are not
replaced by the algebraic entry.  That is, while `$+1' replaces 5 on
the stack with 6, `$1+1' leaves the 5 on the stack and pushes an
additional 6.

If a sequence of formulas are entered separated by commas, each formula
is pushed onto the stack in turn.  For example, `1,2,3' pushes
those three numbers onto the stack (leaving the 3 at the top), and
`$+1,$-1' replaces a 5 on the stack with 4 followed by 6.  Also,
`$,$$' exchanges the top two elements of the stack, just like the
TAB key.

You can finish an algebraic entry with `M-=' or `M-RET' instead of
RET.  This uses `=' to evaluate the variables in each formula that
goes onto the stack.  (Thus `' pi RET' pushes the variable `pi', but
`' pi M-RET' pushes 3.1415.)

If you finish your algebraic entry by pressing `LFD' (or `C-j')
instead of RET, Calc disables the default simplifications (as if by `m
O'; *Note Simplification Modes::) while the entry is being pushed on
the stack.  Thus `' 1+2 RET' pushes 3 on the stack, but `' 1+2 LFD'
pushes the formula `1+2'; you might then press `=' when it is time to
evaluate this formula.



File: calc.info, Node: Quick Calculator, Next: Prefix Arguments, Prev: Algebraic Entry, Up: Introduction

"Quick Calculator" Mode
=======================

There is another way to invoke the Calculator if all you need to do is
make one or two quick calculations.  Type `M-# q' (or `M-x
quick-calc'), then type any formula as an algebraic entry.  The
Calculator will compute the result and display it in the echo area,
without ever actually putting up a Calc window.

You can use the `$' character in a Quick Calculator formula to
refer to the previous Quick Calculator result.  Older results are
not retained; the Quick Calculator has no effect on the full
Calculator's stack or trail.  If you compute a result and then
forget what it was, just run `M-# q' again and enter
`$' as the formula.

If this is the first time you have used the Calculator in this Emacs
session, the `M-# q' command will create the `*Calculator*' buffer and
perform all the usual initializations; it simply will refrain from
putting that buffer up in a new window.  The Quick Calculator refers
to the `*Calculator*' buffer for all mode settings.  Thus, for
example, to set the precision that the Quick Calculator uses, simply
run the full Calculator momentarily and use the regular `p' command.

If you use `M-# q' from inside the Calculator buffer, the effect is
the same as pressing the apostrophe key (algebraic entry).

The result of a Quick calculation is placed in the Emacs "kill ring"
as well as being displayed.  A subsequent `C-y' command will yank the
result into the editing buffer.  You can also use this to yank the
result into the next `M-# q' input line as a more explicit alternative
to `$' notation, or to yank the result into the Calculator stack after
typing `M-# c'.

If you finish your formula by typing LFD (or `C-j') instead of RET,
the result is inserted immediately into the current buffer rather than
going into the kill ring.

Quick Calculator results are actually evaluated as if by the `='
key (which replaces variable names by their stored values, if any).
If the formula you enter is an assignment to a variable using the
`:=' operator, say, `foo := 2 + 3' or `foo := foo + 1',
then the result of the evaluation is stored in that Calc variable.
*Note Store and Recall::.

If the result is an integer and the current display radix is decimal,
the number will also be displayed in hex and octal formats.  If the
integer is in the range from 1 to 126, it will also be displayed as an
ASCII character.

For example, the quoted character `"x"' produces the vector result
`[120]' (because 120 is the ASCII code of the lower-case `x'; *Note
Strings::).  Since this is a vector, not an integer, it is displayed
only according to the current mode settings.  But running Quick Calc
again and entering `120' will produce the result `120 (16#78, 8#170,
x)' which shows the number in its decimal, hexadecimal, octal, and
ASCII forms.

Please note that the Quick Calculator is not any faster at loading or
computing the answer than the full Calculator; the name "quick" merely
refers to the fact that it's much less hassle to use for small
calculations.



File: calc.info, Node: Prefix Arguments, Next: Undo, Prev: Quick Calculator, Up: Introduction

Numeric Prefix Arguments
========================

Many Calculator commands use numeric prefix arguments.  Some, such as
`d s' (`calc-sci-notation'), set a parameter to the value of the
prefix argument or use a default if you don't use a prefix.  Others
(like `d f' (`calc-fix-notation')) require an argument and prompt for
a number if you don't give one as a prefix.

As a rule, stack-manipulation commands accept a numeric prefix
argument which is interpreted as an index into the stack.  A positive
argument operates on the top N stack entries; a negative argument
operates on the Nth stack entry in isolation; and a zero argument
operates on the entire stack.

Most commands that perform computations (such as the arithmetic and
scientific functions) accept a numeric prefix argument that allows the
operation to be applied across many stack elements.  For unary
operations (that is, functions of one argument like absolute value or
complex conjugate), a positive prefix argument applies that function
to the top N stack entries simultaneously, and a negative argument
applies it to the Nth stack entry only.  For binary operations
(functions of two arguments like addition, GCD, and vector
concatenation), a positive prefix argument "reduces" the function
across the top N stack elements (for example, `C-u 5 +' sums the top 5
stack entries; *Note Reducing and Mapping::), and a negative argument
maps the next-to-top N stack elements with the top stack element as a
second argument (for example, `7 c-u -5 +' adds 7 to the top 5 stack
elements).  This feature is not available for operations which use the
numeric prefix argument for some other purpose.

Numeric prefixes are specified the same way as always in Emacs: Press
a sequence of META-digits, or press ESC followed by digits, or press
`C-u' followed by digits.  Some commands treat plain `C-u' (without
any actual digits) specially.

You can type `~' (`calc-num-prefix') to pop an integer from the top of
the stack and enter it as the numeric prefix for the next command.
For example, `C-u 16 p' sets the precision to 16 digits; an alternate
(silly) way to do this would be `2 RET 4 ^ ~ p', i.e., compute 2 to
the fourth power and set the precision to that value.

Conversely, if you have typed a numeric prefix argument the `~' key
pushes it onto the stack in the form of an integer.



