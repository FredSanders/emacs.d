Info file: calc.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `calc.texinfo'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the author
instead of in the original English.




File: calc.info, Node: Composing Patterns in Rewrite Rules, Next: Nested Formulas with Rewrite Rules, Prev: Other Features of Rewrite Rules, Up: Rewrite Rules

Composing Patterns in Rewrite Rules
-----------------------------------

There are three operators, `&&&', `|||', and `!!!', that combine
rewrite patterns to make larger patterns.  The combinations are "and,"
or," and "not," respectively, and these operators are the pattern
equivalents of `&&', `||' and `!' (which operate on zero-or-nonzero
logical values).

Note that `&&&', `|||', and `!!!' are left in symbolic form by all
regular Calc features; they have special meaning only in the context
of rewrite rule patterns.

The pattern `P1 &&& P2' matches anything that matches both P1 and P2.
One especially useful case is when one of P1 or P2 is a meta-variable.
For example, here is a rule that operates on error forms:

     f(x &&& a +/- b, x)  :=  g(x)

This does the same thing, but is arguably simpler than, the rule

     f(a +/- b, a +/- b)  :=  g(a +/- b)

Here's another interesting example:

     ends(cons(a, x) &&& rcons(y, b))  :=  [a, b]

which effectively clips out the middle of a vector leaving just the
first and last elements.  This rule will change a one-element vector
`[a]' to `[a, a]'.  The similar rule

     ends(cons(a, rcons(y, b)))  :=  [a, b]

would do the same thing except that it would fail to match a
one-element vector.


The pattern `P1 ||| P2' matches anything that matches either P1 or P2.
Calc first tries matching against P1; if that fails, it goes on to try
P2.

A simple example of `|||' is

     curve(inf ||| -inf)  :=  0

which converts both `curve(inf)' and `curve(-inf)' to zero.

Here is a larger example:

     log(a, b) ||| (ln(a) :: let(b := e))  :=  mylog(a, b)

This matches both generalized and natural logarithms in a single rule.
Note that the `::' term must be enclosed in parentheses because that
operator has lower precedence than `|||' or `:='.

(In practice this rule would probably include a third alternative,
omitted here for brevity, to take care of `log10'.)

While Calc generally treats interior conditions exactly the same as
conditions on the outside of a rule, it does guarantee that if all the
variables in the condition are special names like `e', or already
bound in the pattern to which the condition is attached (say, if
`a' had appeared in this condition), then Calc will process this
condition right after matching the pattern to the left of the `::'.
Thus, we know that `b' will be bound to `e' only if the
`ln' branch of the `|||' was taken.

Note that this rule was careful to bind the same set of meta-variables
on both sides of the `|||'.  Calc does not check this, but if you bind
a certain meta-variable only in one branch and then use that
meta-variable elsewhere in the rule, results are unpredictable:

     f(a,b) ||| g(b)  :=  h(a,b)

Here if the pattern matches `g(17)', Calc makes no promises about the
value that will be substituted for `a' on the righthand side.


The pattern `!!! PAT' matches anything that does not
match PAT.  Any meta-variables that are bound while matching
PAT remain unbound outside of PAT.

For example,

     f(x &&& !!! a +/- b, !!![])  :=  g(x)

converts `f' whose first argument is anything *except* an error form,
and whose second argument is not the empty vector, into a similar call
to `g' (but without the second argument).

If we know that the second argument will be a vector (empty or not),
then an equivalent rule would be:

     f(x, y)  :=  g(x)  :: typeof(x) != 7 :: vlen(y) > 0

where of course 7 is the `typeof' code for error forms.  Another final
condition, that works for any kind of `y', would be `!istrue(y ==
[])'.  (The `istrue' function returns an explicit 0 if its argument
was left in symbolic form; plain `!(y == [])' or `y != []' would not
work to replace `!!![]' since these would be left unsimplified, and
thus cause the rule to fail, if `y' was something like a variable
name.)

It is possible for a `!!!' to refer to meta-variables bound elsewhere
in the pattern.  For example,

     f(a, !!!a)  :=  g(a)

matches any call to `f' with different arguments, changing this to `g'
with only the first argument.

If a function call is to be matched and one of the argument patterns
contains a `!!!' somewhere inside it, that argument will be matched
last.  Thus

     f(!!!a, a)  :=  g(a)

will be careful to bind `a' to the second argument of `f' before
testing the first argument.  If Calc had tried to match the first
argument of `f' first, the results would have been disasterous: Since
`a' was unbound so far, the pattern `a' would have matched anything at
all, and the pattern `!!!a' therefore would *not* have matched
anything at all!



File: calc.info, Node: Nested Formulas with Rewrite Rules, Next: Multi-Phase Rewrite Rules, Prev: Composing Patterns in Rewrite Rules, Up: Rewrite Rules

Nested Formulas with Rewrite Rules
----------------------------------

When `a r' (`calc-rewrite') is used, it takes an expression from the
top of the stack and attempts to match any of the specified rules to
any part of the expression, starting with the whole expression and
then, if that fails, trying deeper and deeper sub-expressions.  For
each part of the expression, the rules are tried in the order they
appear in the rules vector.  The first rule to match the first
sub-expression wins; it replaces the matched sub-expression according
to the NEW part of the rule.

Often, the rule set will match and change the formula several times.
The top-level formula is first matched and substituted repeatedly
until it no longer matches the pattern; then, sub-formulas are tried,
and so on.  Once every part of the formula has gotten its chance, the
rewrite mechanism starts over again with the top-level formula (in
case a substitution of one of its arguments has caused it again to
match).  This continues until no further matches can be made anywhere
in the formula.

It is possible for a rule set to get into an infinite loop.  The most
obvious case, replacing a formula with itself, is not a problem
because a rule is not considered to "succeed" unless the righthand
side actually comes out to something different than the original
formula or sub-formula that was matched.  But if you accidentally had
both `ln(a b) := ln(a) + ln(b)' and the reverse `ln(a) + ln(b) := ln(a
b)' in your rule set, Calc would run forever switching a formula back
and forth between the two forms.

To avoid disaster, Calc normally stops after 100 changes have been
made to the formula.  This will be enough for most multiple rewrites,
but it will keep an endless loop of rewrites from locking up the
computer forever.  (On most systems, you can also type `C-g' to halt
any Emacs command prematurely.)

To change this limit, give a positive numeric prefix argument.  In
particular, `M-1 a r' applies only one rewrite at a time, useful when
you are first testing your rule (or just if repeated rewriting is not
what is called for by your application).

You can also put a "function call" `iterations(N)' in place of a rule
anywhere in your rules vector (but usually at the top).  Then, N will
be used instead of 100 as the default number of iterations for this
rule set.  You can use `iterations(inf)' if you want no iteration
limit by default.  A prefix argument will override the `iterations'
limit in the rule set.

     [ iterations(1),
       f(x) := f(x+1) ]

More precisely, the limit controls the number of "iterations," where
each iteration is a successful matching of a rule pattern whose
righthand side, after substituting meta-variables and applying the
default simplifications, is different from the original sub-formula
that was matched.

A prefix argument of zero sets the limit to infinity.  Use with
caution!

Given a negative numeric prefix argument, `a r' will match and
substitute the top-level expression up to that many times, but will
not attempt to match the rules to any sub-expressions.

In a formula, `rewrite(EXPR, RULES, N)' does a rewriting operation.
Here EXPR is the expression being rewritten, RULES is the rule, vector
of rules, or variable containing the rules, and N is the optional
iteration limit, which may be a positive integer, a negative integer,
or `inf' or `-inf'.  If N is omitted the `iterations' value from the
rule set is used; if both are omitted, 100 is used.



File: calc.info, Node: Multi-Phase Rewrite Rules, Next: Selections with Rewrite Rules, Prev: Nested Formulas with Rewrite Rules, Up: Rewrite Rules

Multi-Phase Rewrite Rules
-------------------------

It is possible to separate a rewrite rule set into several "phases".
During each phase, certain rules will be enabled while certain others
will be disabled.  A "phase schedule" controls the order in which
phases occur during the rewriting process.

If a call to the marker function `phase' appears in the rules vector
in place of a rule, all rules following that point will be members of
the phase(s) identified in the arguments to `phase'.  Phases are given
integer numbers.  The markers `phase()' and `phase(all)' both mean the
following rules belong to all phases; this is the default at the start
of the rule set.

If you do not explicitly schedule the phases, Calc sorts all phase
numbers that appear in the rule set and executes the phases in
ascending order.  For example, the rule set

     [ f0(x) := g0(x),
       phase(1),
       f1(x) := g1(x),
       phase(2),
       f2(x) := g2(x),
       phase(3),
       f3(x) := g3(x),
       phase(1,2),
       f4(x) := g4(x) ]

has three phases, 1 through 3.  Phase 1 consists of the `f0', `f1',
and `f4' rules (in that order).  Phase 2 consists of `f0', `f2', and
`f4'.  Phase 3 consists of `f0' and `f3'.

When Calc rewrites a formula using this rule set, it first rewrites
the formula using only the phase 1 rules until no further changes are
possible.  Then it switches to the phase 2 rule set and continues
until no further changes occur, then finally rewrites with phase 3.
When no more phase 3 rules apply, rewriting finishes.  (This is
assuming `a r' with a large enough prefix argument to allow the
rewriting to run to completion; the sequence just described stops
early if the number of iterations specified in the prefix argument,
100 by default, is reached.)

During each phase, Calc descends through the nested levels of the
formula as described previously.  (*Note Nested Formulas with Rewrite
Rules::.)  Rewriting starts at the top of the formula, then works its
way down to the parts, then goes back to the top and works down again.
The phase 2 rules do not begin until no phase 1 rules apply anywhere
in the formula.

A `schedule' marker appearing in the rule set (anywhere, but
conventionally at the top) changes the default schedule of phases.  In
the simplest case, `schedule' has a sequence of phase numbers for
arguments; each phase number is invoked in turn until the arguments to
`schedule' are exhausted.  Thus adding `schedule(3,2,1)' at the top of
the above rule set would reverse the order of the phases;
`schedule(1,2,3)' would have no effect since this is the default
schedule; and `schedule(1,2,1,3)' would give phase 1 a second chance
after phase 2 has completed, before moving on to phase 3.

Any argument to `schedule' can instead be a vector of phase numbers
(or even of sub-vectors).  Then the sub-sequence of phases described
by the vector are tried repeatedly until no change occurs in any phase
in the sequence.  For example, `schedule([1, 2], 3)' tries phase 1,
then phase 2, then, if either phase made any changes to the formula,
repeats these two phases until they can make no further progress.
Finally, it goes on to phase 3 for finishing touches.

Also, items in `schedule' can be variable names as well as numbers.  A
variable name is interpreted as the name of a function to call on the
whole formula.  For example, `schedule(1, simplify)' says to apply the
phase-1 rules (presumably, all of them), then to call `simplify' which
is the function name equivalent of `a s'.  Likewise, `schedule([1,
simplify])' says to alternate between phase 1 and `a s' until no
further changes occur.

Phases can be used purely to improve efficiency; if it is known that a
certain group of rules will apply only at the beginning of rewriting,
and a certain other group will apply only at the end, then rewriting
will be faster if these groups are identified as separate phases.
Once the phase 1 rules are done, Calc can put them aside and no longer
spend any time on them while it works on phase 2.

There are also some problems that can only be solved with several
rewrite phases.  For a real-world example of a multi-phase rule set,
examine the set `FitRules', which is used by the curve-fitting command
to convert a model expression to linear form.  *Note Curve Fitting
Details::.  This set is divided into four phases.  The first phase
rewrites certain kinds of expressions to be more easily linearizable,
but less computationally efficient.  After the linear components have
been picked out, the final phase includes the opposite rewrites to put
each component back into an efficient form.  If both sets of rules
were included in one big phase, Calc could get into an infinite loop
going back and forth between the two forms.

Elsewhere in `FitRules', the components are first isolated, then
recombined where possible to reduce the complexity of the linear fit,
then finally packaged one component at a time into vectors.  If the
packaging rules were allowed to begin before the recombining rules
were finished, some components might be put away into vectors before
they had a chance to recombine.  By putting these rules in two
separate phases, this problem is neatly avoided.



File: calc.info, Node: Selections with Rewrite Rules, Next: Matching Commands, Prev: Multi-Phase Rewrite Rules, Up: Rewrite Rules

Selections with Rewrite Rules
-----------------------------

If a sub-formula of the current formula is selected (as by `j s';
*Note Selecting Subformulas::), the `a r' (`calc-rewrite') command
applies only to that sub-formula.  Together with a negative prefix
argument, you can use this fact to apply a rewrite to one specific
part of a formula without affecting any other parts.

The `j r' (`calc-rewrite-selection') command allows more sophisticated
operations on selections.  This command prompts for the rules in the
same way as `a r', but it then applies those rules to the whole
formula in question even though a sub-formula of it has been selected.
However, the selected sub-formula will first have been surrounded by a
`select( )' function call.  (Calc's evaluator does not understand the
function name `select'; this is only a tag used by the `j r' command.)

For example, suppose the formula on the stack is `2 (a + b)^2' and the
sub-formula `a + b' is selected.  This formula will be rewritten to `2
select(a + b)^2' and then the rewrite rules will be applied in the
usual way.  The rewrite rules can include references to `select' to
tell where in the pattern the selected sub-formula should appear.

If there is still exactly one `select( )' function call in the formula
after rewriting is done, it indicates which part of the formula should
be selected afterwards.  Otherwise, the formula will be unselected.

You can make `j r' act much like `a r' by enclosing both parts of the
rewrite rule with `select()'.  However, `j r' allows you to use the
current selection in more flexible ways.  Suppose you wished to make a
rule which removed the exponent from the selected term; the rule
`select(a)^x := select(a)' would work.  In the above example, it would
rewrite `2 select(a + b)^2' to `2 select(a + b)'.  This would then be
returned to the stack as `2 (a + b)' with the `a + b' selected.

The `j r' command uses one iteration by default, unlike
`a r' which defaults to 100 iterations.  A numeric prefix
argument affects `j r' in the same way as `a r'.
*Note Nested Formulas with Rewrite Rules::.

As with other selection commands, `j r' operates on the stack entry
that contains the cursor.  (If the cursor is on the top-of-stack `.'
marker, it works as if the cursor were on the formula at stack level
1.)

If you don't specify a set of rules, the rules are taken from the top
of the stack, just as with `a r'.  In this case, the cursor must
indicate stack entry 2 or above as the formula to be rewritten
(otherwise the same formula would be used as both the target and the
rewrite rules).

If the indicated formula has no selection, the cursor position within
the formula temporarily selects a sub-formula for the purposes of this
command.  If the cursor is not on any sub-formula (e.g., it is in the
line-number area to the left of the formula), the `select( )' markers
are ignored by the rewrite mechanism and the rules are allowed to
apply anywhere in the formula.

As a special feature, the normal `a r' command also ignores `select(
)' calls in rewrite rules.  For example, if you used the above rule
`select(a)^x := select(a)' with `a r', it would apply the rule as if
it were `a^x := a'.  Thus, you can write general purpose rules with
`select( )' hints inside them so that they will "do the right thing"
in both `a r' and `j r', both with and without selections.



File: calc.info, Node: Matching Commands, Next: Automatic Rewrites, Prev: Selections with Rewrite Rules, Up: Rewrite Rules

Matching Commands
-----------------

The `a m' (`calc-match') [`match'] function takes a vector of formulas
and a rewrite-rule-style pattern, and produces a vector of all
formulas which match the pattern.  The command prompts you to enter
the pattern; as for `a r', you can enter a single pattern (i.e., a
formula with meta-variables), or a vector of patterns, or a variable
which contains patterns, or you can give a blank response in which
case the patterns are taken from the top of the stack.  The pattern
set will be compiled once and saved if it is stored in a variable.  If
there are several patterns in the set, vector elements are kept if
they match any of the patterns.

For example, `match(a+b, [x, x+y, x-y, 7, x+y+z])' will return `[x+y,
x-y, x+y+z]'.

The `import' mechanism is not available for pattern sets.

The `a m' command can also be used to extract all vector elements
which satisfy any condition: The pattern `x :: x>0' will select all
the positive vector elements.

With the Inverse flag [`matchnot'], this command extracts all vector
elements which do *not* match the given pattern.

There is also a function `matches(X, P)' which evaluates to 1 if
expression X matches pattern P, or to 0 otherwise.  This is sometimes
useful for including into the conditional clauses of other rewrite
rules.

The function `vmatches' is just like `matches', except that if the
match succeeds it returns a vector of assignments to the
meta-variables instead of the number 1.  For example,
`vmatches(f(1,2), f(a,b))' returns `[a := 1, b := 2]'.  If the match
fails, the function returns the number 0.



File: calc.info, Node: Automatic Rewrites, Next: Debugging Rewrites, Prev: Matching Commands, Up: Rewrite Rules

Automatic Rewrites
------------------

It is possible to get Calc to apply a set of rewrite rules on all
results, effectively adding to the built-in set of default
simplifications.  To do this, simply store your rule set in the
variable `EvalRules'.  There is a convenient `s E' command for editing
`EvalRules'; *Note Operations on Variables::.

For example, suppose you want `sin(a + b)' to be expanded out to
`sin(b) cos(a) + cos(b) sin(a)' wherever it appears, and similarly for
`cos(a + b)'.  The corresponding rewrite rule set would be,

     [ sin(a + b)  :=  cos(a) sin(b) + sin(a) cos(b),
       cos(a + b)  :=  cos(a) cos(b) - sin(a) sin(b) ]

To apply these manually, you could put them in a variable called
`trigexp' and then use `a r trigexp' every time you wanted
to expand trig functions.  But if instead you store them in the
variable `EvalRules', they will automatically be applied to all
sines and cosines of sums.  Then, with `2 x' and `45' on
the stack, typing `+ S' will (assuming degrees mode) result in
`0.7071 sin(2 x) + 0.7071 cos(2 x)' automatically.

As each level of a formula is evaluated, the rules from `EvalRules'
are applied before the default simplifications.  Rewriting continues
until no further `EvalRules' apply.  Note that this is different from
the usual order of application of rewrite rules: `EvalRules' works
from the bottom up, simplifying the arguments to a function before the
function itself, while `a r' applies rules from the top down.

Because the `EvalRules' are tried first, you can use them to override
the normal behavior of any built-in Calc function.

It is important not to write a rule that will get into an infinite
loop.  For example, the rule set `[f(0) := 1, f(n) := n f(n-1)]'
appears to be a good definition of a factorial function, but it is
unsafe.  Imagine what happens if `f(2.5)' is simplified.  Calc will
continue to subtract 1 from this argument forever without reaching
zero.  A safer second rule would be `f(n) := n f(n-1) :: n>0'.
Another dangerous rule is `g(x, y) := g(y, x)'.  Rewriting `g(2, 4)',
this would bounce back and forth between that and `g(4, 2)' forever.
If an infinite loop in `EvalRules' occurs, Emacs will eventually stop
with a "Computation got stuck or ran too long" message.

Another subtle difference between `EvalRules' and regular rewrites
concerns rules that rewrite a formula into an identical formula.  For
example, `f(n) := f(floor(n))' "fails to match" when `n' is already an
integer.  But in `EvalRules' this case is detected only if the
righthand side literally becomes the original formula before any
further simplification.  This means that `f(n) := f(floor(n))' will
get into an infinite loop if it occurs in `EvalRules'.  Calc will
replace `f(6)' with `f(floor(6))', which is different from `f(6)', so
it will consider the rule to have matched and will continue
simplifying that formula; first the argument is simplified to get
`f(6)', then the rule matches again to get `f(floor(6))' again, ad
infinitum.  A much safer rule would check its argument first, say,
with `f(n) := f(floor(n)) :: !dint(n)'.

(What really happens is that the rewrite mechanism substitutes the
meta-variables in the righthand side of a rule, compares to see if the
result is the same as the original formula and fails if so, then uses
the default simplifications to simplify the result and compares again
(and again fails if the formula has simplified back to its original
form).  The only special wrinkle for the `EvalRules' is that the same
rules will come back into play when the default simplifications are
used.  What Calc wants to do is build `f(floor(6))', see that this is
different from the original formula, simplify to `f(6)', see that this
is the same as the original formula, and thus halt the rewriting.  But
while simplifying, `f(6)' will again trigger the same `EvalRules' rule
and Calc will get into a loop inside the rewrite mechanism itself.)

The `phase', `schedule', and `iterations' markers do not work in
`EvalRules'.  If the rule set is divided into phases, only the phase 1
rules are applied, and the schedule is ignored.  The rules are always
repeated as many times as possible.

The `EvalRules' are applied to all function calls in a formula, but
not to numbers (and other number-like objects like error forms), nor
to vectors or individual variable names.  (Though they will apply to
*components* of vectors and error forms when appropriate.)  You might
try to make a variable `phihat' which automatically expands to its
definition without the need to press `=' by writing the rule
`quote(phihat) := (1-sqrt(5))/2', but unfortunately this rule will not
work as part of `EvalRules'.

Finally, another limitation is that Calc sometimes calls its built-in
functions directly rather than going through the default
simplifications.  When it does this, `EvalRules' will not be able to
override those functions.  For example, when you take the absolute
value of the complex number `(2, 3)', Calc computes `sqrt(2*2 + 3*3)'
by calling the multiplication, addition, and square root functions
directly rather than applying the default simplifications to this
formula.  So an `EvalRules' rule that (perversely) rewrites `sqrt(13)
:= 6' would not apply.  (However, if you put Calc into symbolic mode
so that `sqrt(13)' will be left in symbolic form by the built-in
square root function, your rule will be able to apply.  But if the
complex number were `(3,4)', so that `sqrt(25)' must be calculated,
then symbolic mode will not help because `sqrt(25)' can be evaluated
exactly to 5.)

One subtle restriction that normally only manifests itself with
`EvalRules' is that while a given rewrite rule is in the process of
being checked, that same rule cannot be recursively applied.  Calc
effectively removes the rule from its rule set while checking the
rule, then puts it back once the match succeeds or fails.  (The
technical reason for this is that compiled pattern programs are not
reentrant.)  For example, consider the rule `foo(x) := x :: foo(x/2) >
0' attempting to match `foo(8)'.  This rule will be inactive while the
condition `foo(4) > 0' is checked, even though it might be an integral
part of evaluating that condition.  Note that this is not a problem
for the more usual recursive type of rule, such as `foo(x) :=
foo(x/2)', because there the rule has succeeded and been reactivated
by the time the righthand side is evaluated.

If `EvalRules' has no stored value (its default state), or if anything
but a vector is stored in it, then it is ignored.

Even though Calc's rewrite mechanism is designed to compare rewrite
rules to formulas as quickly as possible, storing rules in `EvalRules'
may make Calc run substantially slower.  This is particularly true of
rules where the top-level call is a commonly used function, or is not
fixed.  The rule `f(n) := n f(n-1) :: n>0' will only activate the
rewrite mechanism for calls to the function `f', but `lg(n) + lg(m) :=
lg(n m)' will check every `+' operator.  And `apply(f, [a*b]) :=
apply(f, [a]) + apply(f, [b]) :: in(f, [ln, log10])' may seem more
efficient" than two separate rules for `ln' and `log10', but actually
it is vastly less efficient because rules with `apply' as the
top-level pattern must be tested against *every* function call that is
simplified.

Suppose you want `sin(a + b)' to be expanded out not all the time, but
only when `a s' is used to simplify the formula.  The variable
`AlgSimpRules' holds rules for this purpose.  The `a s' command will
apply `EvalRules' and `AlgSimpRules' to the formula, as well as all of
its built-in simplifications.

Most of the special limitations for `EvalRules' don't apply to
`AlgSimpRules'.  Calc simply does an `a r AlgSimpRules' command with
an infinite repeat count as the first step of `a s'.  It then applies
its own built-in simplifications throughout the formula, and then
repeats these two steps (along with applying the default
simplifications) until no further changes are possible.

There are also `ExtSimpRules' and `UnitSimpRules' variables that are
used by `a e' and `u s', respectively; these commands also apply
`EvalRules' and `AlgSimpRules'.  The variable `IntegSimpRules'
contains simplification rules that are used only during integration by
`a i'.



File: calc.info, Node: Debugging Rewrites, Next: Examples of Rewrite Rules, Prev: Automatic Rewrites, Up: Rewrite Rules

Debugging Rewrites
------------------

If a buffer named `*Trace*' exists, the rewrite mechanism will record
some useful information there as it operates.  The original formula is
written there, as is the result of each successful rewrite, and the
final result of the rewriting.  All phase changes are also noted.

Calc always appends to `*Trace*'.  You must empty this buffer yourself
periodically if it is in danger of growing unwieldy.

Note that the rewriting mechanism is substantially slower when the
`*Trace*' buffer exists, even if the buffer is not visible on the
screen.  Once you are done, you will probably want to kill this buffer
(with `C-x k *Trace* RET').  If you leave it in existence and forget
about it, all your future rewrite commands will be needlessly slow.



File: calc.info, Node: Examples of Rewrite Rules, Prev: Debugging Rewrites, Up: Rewrite Rules

Examples of Rewrite Rules
-------------------------

Returning to the example of substituting the pattern `sin(x)^2 +
cos(x)^2' with 1, we saw that the rule `opt(a) sin(x)^2 + opt(a)
cos(x)^2 := a' does a good job of finding suitable cases.  Another
solution would be to use the rule `cos(x)^2 := 1 - sin(x)^2', followed
by algebraic simplification if necessary.  This rule will be the most
effective way to do the job, but at the expense of making some changes
that you might not desire.

Another algebraic rewrite rule is `exp(x+y) := exp(x) exp(y)'.  To
make this work with the `j r' command so that it can be easily
targeted to a particular exponential in a large formula, you might
wish to write the rule as `select(exp(x+y)) := select(exp(x) exp(y))'.
The `select' markers will be ignored by the regular `a r' command
(*Note Selections with Rewrite Rules::).

A surprisingly useful rewrite rule is `a/(b-c) := a*(b+c)/(b^2-c^2)'.
This will simplify the formula whenever `b' and/or `c' can
be made simpler by squaring.  For example, applying this rule to
`2 / (sqrt(2) + 3)' yields `6:7 - 2:7 sqrt(2)' (assuming
Symbolic Mode has been enabled to keep the square root from being
evaulated to a floating-point approximation).  This rule is also
useful when working with symbolic complex numbers, e.g.,
`(a + b i) / (c + d i)'.

As another example, we could define our own "triangular numbers" function
with the rules `[tri(0) := 0, tri(n) := n + tri(n-1) :: n>0]'.  Enter
this vector and store it in a variable:  `s t trirules'.  Now, given
a suitable formula like `tri(5)' on the stack, type `a r trirules'
to apply these rules repeatedly.  After six applications, `a r' will
stop with 15 on the stack.  Once these rules are debugged, it would probably
be most useful to add them to `EvalRules' so that Calc will evaluate
the new `tri' function automatically.  We could then use `Z K' on
the keyboard macro `' tri($) RET' to make a command that applies
`tri' to the value on the top of the stack.  *Note Programming::.

The following rule set, contributed by Francois Pinard, implements
quaternions", a generalization of the concept of complex numbers.
Quaternions have four components, and are here represented by function
calls `quat(W, [X, Y, Z])' with "real part" W and the three
imaginary" parts collected into a vector.  Various arithmetical
operations on quaternions are supported.  To use these rules, either
add them to `EvalRules', or create a command based on `a r' for
simplifying quaternion formulas.  A convenient way to enter
quaternions would be a command defined by a keyboard macro containing:
`' quat($$$$, [$$$, $$, $]) RET'.

     [ quat(w, x, y, z) := quat(w, [x, y, z]),
       quat(w, [0, 0, 0]) := w,
       abs(quat(w, v)) := hypot(w, v),
       -quat(w, v) := quat(-w, -v),
       r + quat(w, v) := quat(r + w, v) :: real(r),
       r - quat(w, v) := quat(r - w, -v) :: real(r),
       quat(w1, v1) + quat(w2, v2) := quat(w1 + w2, v1 + v2),
       r * quat(w, v) := quat(r * w, r * v) :: real(r),
       plain(quat(w1, v1) * quat(w2, v2))
	  := quat(w1 * w2 - v1 * v2, w1 * v2 + w2 * v1 + cross(v1, v2)),
       quat(w1, v1) / r := quat(w1 / r, v1 / r) :: real(r),
       z / quat(w, v) := z * quatinv(quat(w, v)),
       quatinv(quat(w, v)) := quat(w, -v) / (w^2 + v^2),
       quatsqr(quat(w, v)) := quat(w^2 - v^2, 2 * w * v),
       quat(w, v)^k := quatsqr(quat(w, v)^(k / 2))
		    :: integer(k) :: k > 0 :: k % 2 = 0,
       quat(w, v)^k := quatsqr(quat(w, v)^((k - 1) / 2)) * quat(w, v)
		    :: integer(k) :: k > 2,
       quat(w, v)^-k := quatinv(quat(w, v)^k) :: integer(k) :: k > 0 ]

Quaternions, like matrices, have non-commutative multiplication.  In
other words, `q1 * q2 = q2 * q1' is not necessarily true if `q1' and
`q2' are `quat' forms.  The `quat*quat' rule above uses `plain' to
prevent Calc from rearranging the product.  It may also be wise to add
the line `[quat(), matrix]' to the `Decls' matrix, to ensure that
Calc's other algebraic operations will not rearrange a quaternion
product.  *Note Declarations::.

These rules also accept a four-argument `quat' form, converting it to
the preferred form in the first rule.  If you would rather see results
in the four-argument form, just append the two items `phase(2),
quat(w, [x, y, z]) := quat(w, x, y, z)' to the end of the rule set.
(But remember that multi-phase rule sets don't work in `EvalRules'.)



File: calc.info, Node: Units, Next: Store and Recall, Prev: Algebra, Up: Top

Operating on Units
******************

One special interpretation of algebraic formulas is as numbers with
units.  For example, the formula `5 m / s^2' can be read "five meters
per second squared."  The commands in this chapter help you manipulate
units expressions in this form.  Units-related commands begin with the
`u' prefix key.

* Menu:

* Basic Operations on Units::
* The Units Table::
* Predefined Units::
* User-Defined Units::



File: calc.info, Node: Basic Operations on Units, Next: The Units Table, Prev: Units, Up: Units

Basic Operations on Units
=========================

A "units expression" is a formula which is basically a number
multiplied and/or divided by one or more "unit names", which may
optionally be raised to integer powers.  Actually, the value part need
not be a number; any product or quotient involving unit names is a
units expression.  Many of the units commands will also accept any
formula, where the command applies to all units expressions which
appear in the formula.

A unit name is a variable whose name appears in the "unit table", or a
variable whose name is a prefix character like `k' (for "kilo") or `u'
(for "micro") followed by a name in the unit table.  A substantial
table of built-in units is provided with Calc; *Note Predefined
Units::.  You can also define your own unit names; *Note User-Defined
Units::.

Note that if the value part of a units expression is exactly `1', it
will be removed by the Calculator's automatic algebra routines: The
formula `1 mm' is "simplified" to `mm'.  This is only a display
anomaly, however; `mm' will work just fine as a representation of one
millimeter.

You may find that Algebraic Mode (*Note Algebraic Entry::) makes
working with units expressions easier.  Otherwise, you will have to
remember to hit the apostrophe key every time you wish to enter units.

The `u s' (`calc-simplify-units') [`usimplify'] command simplifies a
units expression.  It uses `a s' (`calc-simplify') to simplify the
expression first as a regular algebraic formula; it then looks for
features that can be further simplified by converting one object's
units to be compatible with another's.  For example, `5 m + 23 mm'
will simplify to `5.023 m'.  When different but compatible units are
added, the righthand term's units are converted to match those of the
lefthand term.  *Note Simplification Modes::, for a way to have this
done automatically at all times.

Units simplification also handles quotients of two units with the same
dimensionality, as in `2 in s/L cm' to `5.08 s/L'; fractional powers
of unit expressions, as in `sqrt(9 mm^2)' to `3 mm' and `sqrt(9 acre)'
to a quantity in meters; and `floor', `ceil', `round', `rounde',
`roundu', `trunc', `float', `frac', `abs', and `clean' applied to
units expressions, in which case the operation in question is applied
only to the numeric part of the expression.  Finally, trigonometric
functions of quantities with units of angle are evaluated, regardless
of the current angular mode.

The `u c' (`calc-convert-units') command converts a units
expression to new, compatible units.  For example, given the units
expression `55 mph', typing `u c m/s RET' produces
`24.5872 m/s'.  If the units you request are inconsistent with
the original units, the number will be converted into your units
times whatever "remainder" units are left over.  For example,
converting `55 mph' into acres produces `6.08e-3 acre / m s'.
(Recall that multiplication binds more strongly than division in Calc
formulas, so the units here are acres per meter-second.)  Remainder
units are expressed in terms of "fundamental" units like `m' and
`s', regardless of the input units.

One special exception is that if you specify a single unit name, and a
compatible unit appears somewhere in the units expression, then that
compatible unit will be converted to the new unit and the remaining
units in the expression will be left alone.  For example, given the
input `980 cm/s^2', the command `u c ms' will change the `s' to `ms'
to get `9.8e-4 cm/ms^2'.  The "remainder unit" `cm' is left alone
rather than being changed to the base unit `m'.

You can use explicit unit conversion instead of the `u s' command to
gain more control over the units of the result of an expression.  For
example, given `5 m + 23 mm', you can type `u c m' or `u c mm' to
express the result in either meters or millimeters.  (For that matter,
you could type `u c fath' to express the result in fathoms, if you
preferred!)

In place of a specific set of units, you can also enter one of the
units system names `si', `mks' (equivalent), or `cgs'.  For example,
`u c si RET' converts the expression into International System of
Units (SI) base units.  Also, `u c base' converts to Calc's base
units, which are the same as `si' units except that `base' uses `g' as
the fundamental unit of mass whereas `si' uses `kg'.

The `u c' command also accepts "composite units", which
are expressed as the sum of several compatible unit names.  For
example, converting `30.5 in' to units `mi+ft+in' (miles,
feet, and inches) produces `2 ft + 6.5 in'.  Calc first
sorts the unit names into order of decreasing relative size.
It then accounts for as much of the input quantity as it can
using an integer number times the largest unit, then moves on
to the next smaller unit, and so on.  Only the smallest unit
may have a non-integer amount attached in the result.  A few
standard unit names exist for common combinations, such as
`mfi' for `mi+ft+in', and `tpo' for `ton+lb+oz'.
Composite units are expanded as if by `a x', so that
`(ft+in)/hr' is first converted to `ft/hr+in/hr'.

If the value on the stack does not contain any units, `u c' will
prompt first for the old units which this value should be considered
to have, then for the new units.  Assuming the old and new units you
give are consistent with each other, the result also will not contain
any units.  For example, `u c cm RET in RET' converts the number
2 on the stack to 5.08.

The `u b' (`calc-base-units') command is shorthand for `u c base'; it
converts the units expression on the top of the stack into `base'
units.  If `u s' does not simplify a units expression as far as you
would like, try `u b'.

The `u c' and `u b' commands treat temperature units (like `degC' and
`K') as relative temperatures.  For example, `u c' converts `10 degC'
to `18 degF': A change of 10 degrees Celsius corresponds to a change
of 18 degrees Fahrenheit.

The `u t' (`calc-convert-temperature') command converts absolute
temperatures.  The value on the stack must be a simple units
expression with units of temperature only.  This command would convert
`10 degC' to `50 degF', the equivalent temperature on the Fahrenheit
scale.

The `u r' (`calc-remove-units') command removes units from the formula
at the top of the stack.  The `u x' (`calc-extract-units') command
extracts only the units portion of a formula.  These commands
essentially replace every term of the formula that does or doesn't
(respectively) look like a unit name by the constant 1, then
resimplify the formula.

The `u a' (`calc-autorange-units') command turns on and off a mode in
which unit prefixes like `k' ("kilo") are automatically applied to
keep the numeric part of a units expression in a reasonable range.
This mode affects `u s' and all units conversion commands except `u
b'.  For example, with autoranging on, `12345 Hz' will be simplified
to `12.345 kHz'.  Autoranging is useful for some kinds of units (like
`Hz' and `m'), but is probably undesirable for non-metric units like
`ft' and `tbsp'.  (Composite units are more appropriate for those; see
above.)

Autoranging always applies the prefix to the leftmost unit name.  Calc
chooses the largest prefix that causes the number to be greater than
or equal to 1.0.  Thus an increasing sequence of adjusted times would
be `1 ms, 10 ms, 100 ms, 1 s, 10 s, 100 s, 1 ks'.  Generally the rule
of thumb is that the number will be adjusted to be in the interval
`[1 .. 1000)', although there are several exceptions to this rule.
First, if the unit has a power then this is not possible; `0.1 s^2'
simplifies to `100000 ms^2'.  Second, the "centi-" prefix is allowed
to form `cm' (centimeters), but will not apply to other units.  The
deci-," "deka-," and "hecto-" prefixes are never used.  Thus the
allowable interval is `[1 .. 10)' for millimeters and `[1 .. 100)' for
centimeters.  Finally, a prefix will not be added to a unit if the
resulting name is also the actual name of another unit; `1e-15 t'
would normally be considered a "femto-ton," but it is written as `1000
at' (1000 atto-tons) instead because `ft' would be confused with feet.



File: calc.info, Node: The Units Table, Next: Predefined Units, Prev: Basic Operations on Units, Up: Units

The Units Table
===============

The `u v' (`calc-enter-units-table') command displays the units table
in another buffer called `*Units Table*'.  Each entry in this table
gives the unit name as it would appear in an expression, the
definition of the unit in terms of simpler units, and a full name or
description of the unit.  Fundamental units are defined as themselves;
these are the units produced by the `u b' command.  The fundamental
units are meters, seconds, grams, kelvins, amperes, candelas, moles,
radians, and steradians.

The Units Table buffer also displays the Unit Prefix Table.  Note that
two prefixes, "kilo" and "hecto," accept either upper- or lower-case
prefix letters.  `Meg' is also accepted as a synonym for the `M'
prefix.  Whenever a unit name can be interpreted as either a built-in
name or a prefix followed by another built-in name, the former
interpretation wins.  For example, `2 pt' means two pints, not two
pico-tons.

The Units Table buffer, once created, is not rebuilt unless you define
new units.  To force the buffer to be rebuilt, give any numeric prefix
argument to `u v'.

The `u V' (`calc-view-units-table') command is like `u v' except
that the cursor is not moved into the Units Table buffer.  You can
type `u V' again to remove the Units Table from the display.  To
return from the Units Table buffer after a `u v', type `M-# c'
again or use the regular Emacs `C-x o' (`other-window')
command.  You can also kill the buffer with `C-x k' if you wish;
the actual units table is safely stored inside the Calculator.

The `u g' (`calc-get-unit-definition') command retrieves a unit's
defining expression and pushes it onto the Calculator stack.  For
example, `u g in' will produce the expression `2.54 cm'.  This is the
same definition for the unit that would appear in the Units Table
buffer.  Note that this command works only for actual unit names; `u g
km' will report that no such unit exists, for example, because `km' is
really the unit `m' with a `k' ("kilo") prefix.  To see a definition
of a unit in terms of base units, it is easier to push the unit name
on the stack and then reduce it to base units with `u b'.

The `u e' (`calc-explain-units') command displays an English
description of the units of the expression on the stack.  For example,
for the expression `62 km^2 g / s^2 mol K', the description is
Square-Kilometer Gram per (Second-squared Mole Degree-Kelvin)."  This
command uses the English descriptions that appear in the righthand
column of the Units Table.



File: calc.info, Node: Predefined Units, Next: User-Defined Units, Prev: The Units Table, Up: Units

Predefined Units
================

Since the exact definitions of many kinds of units have evolved over
the years, and since certain countries sometimes have local
differences in their definitions, it is a good idea to examine Calc's
definition of a unit before depending on its exact value.  For
example, there are three different units for gallons, corresponding to
the US (`gal'), Canadian (`galC'), and British (`galUK') definitions.
Also, note that `oz' is a standard ounce of mass, `ozt' is a Troy
ounce, and `ozfl' is a fluid ounce.

The temperature units corresponding to degrees Kelvin and Centigrade
(Celsius) are the same in this table, since most units commands treat
temperatures as being relative.  The `calc-convert-temperature'
command has special rules for handling the different absolute
magnitudes of the various temperature scales.

The unit of volume "liters" can be referred to by either the lower-case
`l' or the upper-case `L'.

The unit `A' stands for Amperes; the name `Ang' is used for Angstroms.

The unit `pt' stands for pints; the name `point' stands for
a typographical point, defined by `72 point = 1 in'.  There is
also `tpt', which stands for a printer's point as defined by the
TeX typesetting system:  `72.27 tpt = 1 in'.

The unit `e' stands for the elementary (electron) unit of charge;
because algebra command could mistake this for the special constant
`e', Calc provides the alternate unit name `ech' which is preferable
to `e'.

The name `g' stands for one gram of mass; there is also `gf', one gram
of force.  (Likewise for `lb', pounds, and `lbf'.)  Meanwhile, one
`g'" of acceleration is denoted `ga'.

The unit `ton' is a U.S. ton of `2000 lb', and `t' is a metric ton of
`1000 kg'.

The names `s' (or `sec') and `min' refer to units of time; `arcsec'
and `arcmin' are units of angle.

Some "units" are really physical constants; for example, `c'
represents the speed of light, and `h' represents Planck's constant.
You can use these just like other units: converting `.5 c' to `m/s'
expresses one-half the speed of light in meters per second.  You can
also use this merely as a handy reference; the `u g' command gets the
definition of one of these constants in its normal terms, and `u b'
expresses the definition in base units.

Two units, `pi' and `fsc' (the fine structure constant, approximately
1/137) are dimensionless.  The units simplification commands simply
treat these names as equivalent to their corresponding values.
However you can, for example, use `u c' to convert a pure number into
multiples of the fine structure constant, or `u b' to convert this
back into a pure number.  (When `u c' prompts for the "old units,"
just enter a blank line to signify that the value really is unitless.)




File: calc.info, Node: User-Defined Units, Prev: Predefined Units, Up: Units

User-Defined Units
==================

Calc provides ways to get quick access to your selected "favorite"
units, as well as ways to define your own new units.

To select your favorite units, store a vector of unit names or
expressions in the Calc variable `Units'.  The `u 1' through `u 9'
commands (`calc-quick-units') provide access to these units.  If the
value on the top of the stack is a plain number (with no units
attached), then `u 1' gives it the specified units.  (Basically, it
multiplies the number by the first item in the `Units' vector.)  If
the number on the stack *does* have units, then `u 1' converts that
number to the new units.  For example, suppose the vector `[in, ft]'
is stored in `Units'.  Then `30 u 1' will create the expression `30
in', and `u 2' will convert that expression to `2.5 ft'.

The `u 0' command accesses the tenth element of `Units'.  Only ten
quick units may be defined at a time.  If the `Units' variable has no
stored value (the default), or if its value is not a vector, then the
quick-units commands will not function.  The `s U' command is a
convenient way to edit the `Units' variable; *Note Operations on
Variables::.

The `u d' (`calc-define-unit') command records the units expression on
the top of the stack as the definition for a new, user-defined unit.
For example, putting `16.5 ft' on the stack and typing `u d rod'
defines the new unit `rod' to be equivalent to 16.5 feet.  The unit
conversion and simplification commands will now treat `rod' just like
any other unit of length.  You will also be prompted for an optional
English description of the unit, which will appear in the Units Table.

The `u u' (`calc-undefine-unit') command removes a user-defined unit.
It is not possible to remove one of the predefined units, however.

If you define a unit with an existing unit name, your new definition
will replace the original definition of that unit.  If the unit was a
predefined unit, the old definition will not be replaced, only
"shadowed."  The built-in definition will reappear if you later use
`u u' to remove the shadowing definition.

To create a new fundamental unit, use either 1 or the unit name itself
as the defining expression.  Otherwise the expression can involve any
other units that you like (except for composite units like `mfi').
You can create a new composite unit with a sum of other units as the
defining expression.  The next unit operation like `u c' or `u v'
will rebuild the internal unit table incorporating your modifications.
Note that erroneous definitions (such as two units defined in terms of
each other) will not be detected until the unit table is next rebuilt;
`u v' is a convenient way to force this to happen.

Temperature units are treated specially inside the Calculator; it is
not possible to create user-defined temperature units.

The `u p' (`calc-permanent-units') command stores the user-defined
units in your `.emacs' file, so that the units will still be available
in subsequent Emacs sessions.  If there was already a set of
user-defined units in your `.emacs' file, it is replaced by the new
set.  (*Note General Mode Commands::, for a way to tell Calc to use a
different file instead of `.emacs'.)



