Info file: calc.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `calc.texinfo'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the author
instead of in the original English.




File: calc.info, Node: Matrix Functions, Next: Algebra, Prev: Scientific Functions, Up: Top

Vector/Matrix Functions
***********************

Many of the commands described here begin with the `v' prefix.  (For
convenience, the shift-`V' prefix is equivalent to `v'.)  The commands
usually apply to both plain vectors and matrices; some apply only to
matrices or only to square matrices.  If the argument has the wrong
dimensions the operation is left in symbolic form.

Vectors are entered and displayed using `[a,b,c]' notation.  Matrices
are vectors of which all elements are vectors of equal length.
(Though none of the standard Calc commands use this concept, a
three-dimensional matrix or rank-3 tensor could be defined as a vector
of matrices, and so on.)

* Menu:

* Packing and Unpacking::
* Building Vectors::
* Extracting Elements::
* Manipulating Vectors::
* Vector and Matrix Arithmetic::
* Set Operations::
* Statistical Operations::
* Reducing and Mapping::
* Vector and Matrix Formats::



File: calc.info, Node: Packing and Unpacking, Next: Building Vectors, Prev: Matrix Functions, Up: Matrix Functions

Packing and Unpacking
=====================

Calc's "pack" and "unpack" commands collect stack entries to build
composite objects such as vectors and complex numbers.  They are
described in this chapter because they are most often used to build
vectors.

The `v p' (`calc-pack') [`pack'] command collects several elements
from the stack into a matrix, complex number, HMS form, error form,
etc.  It uses a numeric prefix argument to specify the kind of object
to be built; this argument is referred to as the "packing mode."  If
the packing mode is a nonnegative integer, a vector of that length is
created.  For example, `C-u 5 v p' will pop the top five stack
elements and push back a single vector of those five elements.  (`C-u
0 v p' simply creates an empty vector.)

The same effect can be had by pressing `[' to push an incomplete
vector on the stack, using TAB (`calc-roll-down') to sneak the
incomplete object up past a certain number of elements, and then
pressing `]' to complete the vector.

Negative packing modes create other kinds of composite objects:

`-1'
     Two values are collected to build a complex number.  For example,
     `5 RET 7 C-u -1 v p' creates the complex number `(5, 7)'.  The
     result is always a rectangular complex number.  The two input
     values must both be real numbers, i.e., integers, fractions, or
     floats.  If they are not, Calc will instead build a formula like
     `a + (0, 1) b'.  (The other packing modes also create a symbolic
     answer if the components are not suitable.)

`-2'
     Two values are collected to build a polar complex number.  The
     first is the magnitude; the second is the phase expressed in
     either degrees or radians according to the current angular mode.

`-3'
     Three values are collected into an HMS form.  The first two
     values (hours and minutes) must be integers or integer-valued
     floats.  The third value may be any real number.

`-4'
     Two values are collected into an error form.  The inputs may be
     real numbers or formulas.

`-5'
     Two values are collected into a modulo form.  The inputs must be
     real numbers.

`-6'
     Two values are collected into the interval `[a .. b]'.  The
     inputs may be real numbers, HMS or date forms, or formulas.

`-7'
     Two values are collected into the interval `[a .. b)'.

`-8'
     Two values are collected into the interval `(a .. b]'.

`-9'
     Two values are collected into the interval `(a .. b)'.

`-10'
     Two integer values are collected into a fraction.

`-11'
     Two values are collected into a floating-point number.  The first
     is the mantissa; the second, which must be an integer, is the
     exponent.  The result is the mantissa times ten to the power of
     the exponent.

`-12'
     This is treated the same as -11 by the `v p' command.  When
     unpacking, -12 specifies that a floating-point mantissa is
     desired.

`-13'
     A real number is converted into a date form.

`-14'
     Three numbers (year, month, day) are packed into a pure date
     form.

`-15'
     Six numbers are packed into a date/time form.

With any of the two-input negative packing modes, either or both of
the inputs may be vectors.  If both are vectors of the same length,
the result is another vector made by packing corresponding elements of
the input vectors.  If one input is a vector and the other is a plain
number, the number is packed along with each vector element to produce
a new vector.  For example, `C-u -4 v p' could be used to convert a
vector of numbers and a vector of errors into a single vector of error
forms; `C-u -5 v p' could convert a vector of numbers and a single
number M into a vector of numbers modulo M.

If you don't give a prefix argument to `v p', it takes the packing
mode from the top of the stack.  The elements to be packed then begin
at stack level 2.  Thus `1 RET 2 RET 4 n v p' is another way to enter
the error form `1 +/- 2'.

If the packing mode taken from the stack is a vector, the result is a
matrix with the dimensions specified by the elements of the vector,
which must each be integers.  For example, if the packing mode is
`[2, 3]', then six numbers will be taken from the stack and
returned in the form `[[a, b, c], [d, e, f]]'.

If any elements of the vector are negative, other kinds of packing are
done at that level as described above.  For example, `[2, 3, -4]'
takes 12 objects and creates a 2x3 matrix of error forms: `[[a +/- b,
c +/- d ... ]]'.  Also, `[-4, -10]' will convert four integers into an
error form consisting of two fractions: `a:b +/- c:d'.

There is an equivalent algebraic function,
`pack(MODE, ITEMS)' where MODE is a
packing mode (an integer or a vector of integers) and ITEMS
is a vector of objects to be packed (re-packed, really) according
to that mode.  For example, `pack([3, -4], [a,b,c,d,e,f])'
yields `[a +/- b, c +/- d, e +/- f]'.  The function is
left in symbolic form if the packing mode is illegal, or if the
number of data items does not match the number of items required
by the mode.

The `v u' (`calc-unpack') command takes the vector, complex number,
HMS form, or other composite object on the top of the stack and
unpacks" it, pushing each of its elements onto the stack as separate
objects.  Thus, it is the "inverse" of `v p'.  If the value at the top
of the stack is a formula, `v u' unpacks it by pushing each of the
arguments of the top-level operator onto the stack.

You can optionally give a numeric prefix argument to `v u'
to specify an explicit (un)packing mode.  If the packing mode is
negative and the input is actually a vector or matrix, the result
will be two or more similar vectors or matrices of the elements.
For example, given the vector `[a +/- b, c^2, d +/- 7]',
the result of `C-u -4 v u' will be the two vectors
`[a, c^2, d]' and `[b, 0, 7]'.

Note that the prefix argument can have an effect even when the input
is not a vector.  For example, if the input is the number -5, then
`c-u -1 v u' yields -5 and 0 (the components of -5 when viewed as a
rectangular complex number); `C-u -2 v u' yields 5 and 180 (assuming
degrees mode); and `C-u -10 v u' yields -5 and 1 (the numerator and
denominator of -5, viewed as a rational number).  Plain `v u' with
this input would complain that the input is not a composite object.

Unpacking mode -11 converts a float into an integer mantissa and an
integer exponent, where the mantissa is not divisible by 10 (except
that 0.0 is represented by a mantissa and exponent of 0).  Unpacking
mode -12 converts a float into a floating-point mantissa and integer
exponent, where the mantissa (for non-zero numbers) is guaranteed to
lie in the range [1 .. 10).  In both cases, the mantissa is shifted
left or right (and the exponent adjusted to compensate) in order to
satisfy these constraints.

Positive unpacking modes are treated differently than for `v p'.  A
mode of 1 is much like plain `v u' with no prefix argument, except
that in addition to the components of the input object, a suitable
packing mode to re-pack the object is also pushed.  Thus, `C-u 1 v u'
followed by `v p' will re-build the original object.

A mode of 2 unpacks two levels of the object; the resulting re-packing
mode will be a vector of length 2.  This might be used to unpack a
matrix, say, or a vector of error forms.  Higher unpacking modes
unpack the input even more deeply.

There are two algebraic functions analogous to `v u'.  The
`unpack(MODE, ITEM)' function unpacks the ITEM using the given MODE,
returning the result as a vector of components.  Here the MODE must be
an integer, not a vector.  For example, `unpack(-4, a +/- b)' returns
`[a, b]', as does `unpack(1, a +/- b)'.

The `unpackt' function is like `unpack' but instead of returning a
simple vector of items, it returns a vector of two things: The mode,
and the vector of items.  For example, `unpackt(1, 2:3 +/- 1:4)'
returns `[-4, [2:3, 1:4]]', and `unpackt(2, 2:3 +/- 1:4)' returns
`[[-4, -10], [2, 3, 1, 4]]'.  The identity for re-building the
original object is `apply(pack, unpackt(N, X)) = X'.  (The `apply'
function builds a function call given the function name and a vector
of arguments.)

Subscript notation is a useful way to extract a particular part of an
object.  For example, to get the numerator of a rational number, you
can use `unpack(-10, X)_1'.



File: calc.info, Node: Building Vectors, Next: Extracting Elements, Prev: Packing and Unpacking, Up: Matrix Functions

Building Vectors
================

Vectors and matrices can be added, subtracted, multiplied, and
divided; *Note Basic Arithmetic::.

The `|' (`calc-concat') command "concatenates" two vectors
into one.  For example, after `[ 1 , 2 ] [ 3 , 4 ] |', the stack
will contain the single vector `[1, 2, 3, 4]'.  If the arguments
are matrices, the rows of the first matrix are concatenated with the
rows of the second.  (In other words, two matrices are just two vectors
of row-vectors as far as `|' is concerned.)

If either argument to `|' is a scalar (a non-vector), it is treated
like a one-element vector for purposes of concatenation: `1 [ 2 , 3 ]
|' produces the vector `[1, 2, 3]'.  Likewise, if one argument is a
matrix and the other is a plain vector, the vector is treated as a
one-row matrix.

The `H |' (`calc-append') [`append'] command concatenates two vectors
without any special cases.  Both inputs must be vectors.  Whether or
not they are matrices is not taken into account.  If either argument
is a scalar, the `append' function is left in symbolic form.  See also
`cons' and `rcons' below.

The `I |' and `H I |' commands are similar, but they use their two
stack arguments in the opposite order.  Thus `I |' is equivalent to
`TAB |', but possibly more convenient and also a bit faster.

The `v d' (`calc-diag') [`diag'] function builds a diagonal square
matrix.  The optional numeric prefix gives the number of rows and
columns in the matrix.  If the value at the top of the stack is a
vector, the elements of the vector are used as the diagonal elements;
the prefix, if specified, must match the size of the vector.  If the
value on the stack is a scalar, it is used for each element on the
diagonal, and the prefix argument is required.

To build a constant square matrix, e.g., a 3x3 matrix filled with ones,
use `0 M-3 v d 1 +', i.e., build a zero matrix first and then add a
constant value to that matrix.  (Another alternative would be to use
`v b' and `v a'; see below.)

The `v i' (`calc-ident') [`idn'] function builds an identity matrix of
the specified size.  It is a convenient form of `v d' where the
diagonal element is always one.  If no prefix argument is given, this
command prompts for one.

In algebraic notation, `idn(a,n)' acts much like `diag(a,n)', except
that `a' is required to be a scalar (non-vector) quantity.  If `n' is
omitted, `idn(a)' represents `a' times an identity matrix of unknown
size.  Calc can operate algebraically on such generic identity
matrices, and if one is combined with a matrix whose size is known, it
is converted automatically to an identity matrix of a suitable
matching size.  The `v i' command with an argument of zero creates a
generic identity matrix, `idn(1)'.  Note that in dimensioned matrix
mode (*Note Matrix Mode::), generic identity matrices are immediately
expanded to the current default dimensions.

The `v x' (`calc-index') [`index'] function builds a vector of
consecutive integers from 1 to N, where N is the numeric prefix
argument.  If you do not provide a prefix argument, you will be
prompted to enter a suitable number.  If N is negative, the result is
a vector of negative integers from N to -1.

With a prefix argument of just `C-u', the `v x' command takes three
values from the stack: N, START, and INCR (with INCR at top-of-stack).
Counting starts at START and increases by INCR for successive vector
elements.  If START or N is in floating-point format, the resulting
vector elements will also be floats.  Note that START and INCR may in
fact be any kind of numbers or formulas.

When START and INCR are specified, a negative N has a different
interpretation: It causes a geometric instead of arithmetic sequence
to be generated.  For example, `index(-3, a, b)' produces `[a, a b, a
b^2]'.  If you omit INCR in the algebraic form, `index(N, START)', the
default value for INCR is one for positive N or two for negative N.

The `v b' (`calc-build-vector') [`cvec'] function builds a vector of N
copies of the value on the top of the stack, where N is the numeric
prefix argument.  In algebraic formulas, `cvec(x,n,m)' can also be
used to build an N-by-M matrix of copies of X.  (Interactively, just
use `v b' twice: once to build a row, then again to build a matrix of
copies of that row.)

The `v h' (`calc-head') [`head'] function returns the first element of
a vector.  The `I v h' (`calc-tail') [`tail'] function returns the
vector with its first element removed.  In both cases, the argument
must be a non-empty vector.

The `v k' (`calc-cons') [`cons'] function takes a value H and a vector
T from the stack, and produces the vector whose head is H and whose
tail is T.  This is similar to `|', except if H is itself a vector,
`|' will concatenate the two vectors whereas `cons' will insert H at
the front of the vector T.

Each of these three functions also accepts the Hyperbolic flag [`rhead',
`rtail', `rcons'] in which case T instead represents
the *last* single element of the vector, with H
representing the remainder of the vector.  Thus the vector
`[a, b, c, d] = cons(a, [b, c, d]) = rcons([a, b, c], d)'.
Also, `head([a, b, c, d]) = a', `tail([a, b, c, d]) = [b, c, d]',
`rhead([a, b, c, d]) = [a, b, c]', and `rtail([a, b, c, d]) = d'.



File: calc.info, Node: Extracting Elements, Next: Manipulating Vectors, Prev: Building Vectors, Up: Matrix Functions

Extracting Vector Elements
==========================

The `v r' (`calc-mrow') [`mrow'] command extracts one row of the
matrix on the top of the stack, or one element of the plain vector on
the top of the stack.  The row or element is specified by the numeric
prefix argument; the default is to prompt for the row or element
number.  The matrix or vector is replaced by the specified row or
element in the form of a vector or scalar, respectively.

With a prefix argument of `C-u' only, `v r' takes the index of the
element or row from the top of the stack, and the vector or matrix
from the second-to-top position.  If the index is itself a vector of
integers, the result is a vector of the corresponding elements of the
input vector, or a matrix of the corresponding rows of the input
matrix.  This command can be used to obtain any permutation of a
vector.

With `C-u', if the index is an interval form with integer components,
it is interpreted as a range of indices and the corresponding
subvector or submatrix is returned.

Subscript notation in algebraic formulas (`a_b') stands for the Calc
function `subscr', which is synonymous with `mrow'.  Thus, `[x, y,
z]_k' produces `x', `y', or `z' if `k' is one, two, or three,
respectively.  A double subscript (`M_i_j', equivalent to
`subscr(subscr(M, i), j)') will access the element at row `i', column
`j' of a matrix.  The `a _' (`calc-subscript') command creates a
subscript formula `a_b' out of two stack entries.  (It is on the `a'
algebra" prefix because subscripted variables are often used purely as
an algebraic notation.)

Given a negative prefix argument, `v r' instead deletes one row or
element from the matrix or vector on the top of the stack.  Thus `C-u
2 v r' replaces a matrix with its second row, but `C-u -2 v r'
replaces the matrix with the same matrix with its second row removed.
In algebraic form this function is called `mrrow'.

Given a prefix argument of zero, `v r' extracts the diagonal elements
of a square matrix in the form of a vector.  In algebraic form this
function is called `getdiag'.

The `v c' (`calc-mcol') [`mcol' or `mrcol'] command is the analogous
operation on columns of a matrix.  Given a plain vector it extracts
(or removes) one element, just like `v r'.  If the index in `C-u v c'
is an interval or vector and the argument is a matrix, the result is a
submatrix with only the specified columns retained (and possibly
permuted in the case of a vector index).

To extract a matrix element at a given row and column, use `v r' to
extract the row as a vector, then `v c' to extract the column element
from that vector.  In algebraic formulas, it is often more convenient
to use subscript notation: `m_i_j' gives row `i', column `j' of matrix
`m'.

The `v s' (`calc-subvector') [`subvec'] command extracts
a subvector of a vector.  The arguments are the vector, the starting
index, and the ending index, with the ending index in the top-of-stack
position.  The starting index indicates the first element of the vector
to take.  The ending index indicates the first element *past* the
range to be taken.  Thus, `subvec([a, b, c, d, e], 2, 4)' produces
the subvector `[b, c]'.  You could get the same result using
`mrow([a, b, c, d, e], [2 .. 4))'.

If either the start or the end index is zero or negative, it is
interpreted as relative to the end of the vector.  Thus `subvec([a, b,
c, d, e], 2, -2)' also produces `[b, c]'.  In the algebraic form, the
end index can be omitted in which case it is taken as zero, i.e.,
elements from the starting element to the end of the vector are used.
The infinity symbol, `inf', also has this effect when used as the
ending index.

With the Inverse flag, `I v s' [`rsubvec'] removes a subvector
from a vector.  The arguments are interpreted the same as for the
normal `v s' command.  Thus, `rsubvec([a, b, c, d, e], 2, 4)'
produces `[a, d, e]'.  It is always true that `subvec' and
`rsubvec' return complementary parts of the input vector.

*Note Selecting Subformulas::, for an alternative way to operate on
vectors one element at a time.



File: calc.info, Node: Manipulating Vectors, Next: Vector and Matrix Arithmetic, Prev: Extracting Elements, Up: Matrix Functions

Manipulating Vectors
====================

The `v l' (`calc-vlength') [`vlen'] command computes the length of a
vector.  The length of a non-vector is considered to be zero.  Note
that matrices are just vectors of vectors for the purposes of this
command.

With the Hyperbolic flag, `H v l' [`mdims'] computes a vector
of the dimensions of a vector, matrix, or higher-order object.  For
example, `mdims([[a,b,c],[d,e,f]])' returns `[2, 3]' since
its argument is a 2x3 matrix.

The `v f' (`calc-vector-find') [`find'] command searches along a
vector for the first element equal to a given target.  The target is
on the top of the stack; the vector is in the second-to-top position.
If a match is found, the result is the index of the matching element.
Otherwise, the result is zero.  The numeric prefix argument, if given,
allows you to select any starting index for the search.

The `v a' (`calc-arrange-vector') [`arrange'] command
rearranges a vector to have a certain number of columns and rows.  The
numeric prefix argument specifies the number of columns; if you do not
provide an argument, you will be prompted for the number of columns.
The vector or matrix on the top of the stack is "flattened" into a
plain vector.  If the number of columns is nonzero, this vector is
then formed into a matrix by taking successive groups of N elements.
If the number of columns does not evenly divide the number of elements
in the vector, the last row will be short and the result will not be
suitable for use as a matrix.  For example, with the matrix
`[[1, 2], [3, 4]]' on the stack, `v a 4' produces
`[[1, 2, 3, 4]]' (a 1x4 matrix), `v a 1' produces
`[[1], [2], [3], [4]]' (a 4x1 matrix), `v a 2' produces
`[[1, 2], [3, 4]]' (the original 2x2 matrix), `v a 3' produces
`[[1, 2, 3], [4]]' (not a matrix), and `v a 0' produces
the flattened list `[1, 2, 3, 4]'.

The `V S' (`calc-sort') [`sort'] command sorts the elements of a
vector into increasing order.  Real numbers, real infinities, and
constant interval forms come first in this ordering; next come other
kinds of numbers, then variables (in alphabetical order), then finally
come formulas and other kinds of objects; these are sorted according
to a kind of lexicographic ordering with the useful property that one
vector is less or greater than another if the first corresponding
unequal elements are less or greater, respectively.  Since quoted
strings are stored by Calc internally as vectors of ASCII character
codes (*Note Strings::), this means vectors of strings are also sorted
into alphabetical order by this command.

The `I V S' [`rsort'] command sorts a vector into decreasing order.

The `V G' (`calc-grade') [`grade', `rgrade'] command produces an index
table or permutation vector which, if applied to the input vector (as
the index of `C-u v r', say), would sort the vector.  A permutation
vector is just a vector of integers from 1 to N, where each integer
occurs exactly once.  One application of this is to sort a matrix of
data rows using one column as the sort key; extract that column, grade
it with `V G', then use the result to reorder the original matrix with
`C-u v r'.  Another interesting property of the `V G' command is that,
if the input is itself a permutation vector, the result will be the
inverse of the permutation.  The inverse of an index table is a rank
table, whose Kth element says where the Kth original vector element
will rest when the vector is sorted.  To get a rank table, just use `V
G V G'.

With the Inverse flag, `I V G' produces an index table that would sort
the input into decreasing order.  Note that `V S' and `V G' use a
stable" sorting algorithm, i.e., any two elements which are equal will
not be moved out of their original order.  Generally there is no way
to tell with `V S', since two elements which are equal look the same,
but with `V G' this can be an important issue.  In the matrix-of-rows
example, suppose you have names and telephone numbers as two columns
and you wish to sort by phone number primarily, and by name when the
numbers are equal.  You can sort the data matrix by names first, and
then again by phone numbers.  Because the sort is stable, any two rows
with equal phone numbers will remain sorted by name even after the
second sort.

The `V H' (`calc-histogram') [`histogram'] command builds a histogram
of a vector of numbers.  Vector elements are assumed to be integers or
real numbers in the range [0..N) for some "number of bins" N, which is
the numeric prefix argument given to the command.  The result is a
vector of N counts of how many times each value appeared in the
original vector.  Non-integers in the input are rounded down to
integers.  Any vector elements outside the specified range are
ignored.  (You can tell if elements have been ignored by noting that
the counts in the result vector don't add up to the length of the
input vector.)

With the Hyperbolic flag, `H V H' pulls two vectors from the stack.
The second-to-top vector is the list of numbers as before.  The top
vector is an equal-sized list of "weights" to attach to the elements
of the data vector.  For example, if the first data element is 4.2 and
the first weight is 10, then 10 will be added to bin 4 of the result
vector.  Without the hyperbolic flag, every element has a weight of
one.

The `v t' (`calc-transpose') [`trn'] command computes the transpose of
the matrix at the top of the stack.  If the argument is a plain
vector, it is treated as a row vector and transposed into a one-column
matrix.

The `v v' (`calc-reverse-vector') [`vec'] command reverses a vector
end-for-end.  Given a matrix, it reverses the order of the rows.  (To
reverse the columns instead, just use `v t v v v t'.  The same
principle can be used to apply other vector commands to the columns of
a matrix.)

The `v m' (`calc-mask-vector') [`vmask'] command uses
one vector as a mask to extract elements of another vector.  The mask
is in the second-to-top position; the target vector is on the top of
the stack.  These vectors must have the same length.  The result is
the same as the target vector, but with all elements which correspond
to zeros in the mask vector deleted.  Thus, for example,
`vmask([1, 0, 1, 0, 1], [a, b, c, d, e])' produces `[a, c, e]'.
*Note Logical Operations::.

The `v e' (`calc-expand-vector') [`vexp'] command expands a vector
according to another mask vector.  The result is a vector the same
length as the mask, but with nonzero elements replaced by successive
elements from the target vector.  The length of the target vector is
normally the number of nonzero elements in the mask.  If the target
vector is longer, its last few elements are lost.  If the target
vector is shorter, the last few nonzero mask elements are left
unreplaced in the result.  Thus `vexp([2, 0, 3, 0, 7], [a, b])'
produces `[a, 0, b, 0, 7]'.

With the Hyperbolic flag, `H v e' takes a filler value from the
top of the stack; the mask and target vectors come from the third and
second elements of the stack.  This filler is used where the mask is
zero:  `vexp([2, 0, 3, 0, 7], [a, b], z)' produces
`[a, z, c, z, 7]'.  If the filler value is itself a vector,
then successive values are taken from it, so that the effect is to
interleave two vectors according to the mask:
`vexp([2, 0, 3, 7, 0, 0], [a, b], [x, y])' produces
`[a, x, b, 7, y, 0]'.

Another variation on the masking idea is to combine `[a, b, c, d, e]'
with the mask `[1, 0, 1, 0, 1]' to produce `[a, 0, c, 0, e]'.  You can
accomplish this with `V M a &', mapping the logical "and" operation
across the two vectors.  *Note Logical Operations::.  Note that the `?
:' operation also discussed there allows other types of masking using
vectors.



File: calc.info, Node: Vector and Matrix Arithmetic, Next: Set Operations, Prev: Manipulating Vectors, Up: Matrix Functions

Vector and Matrix Arithmetic
============================

Basic arithmetic operations like addition and multiplication are defined
for vectors and matrices as well as for numbers.  Division of matrices, in
the sense of multiplying by the inverse, is supported.  (Division by a
matrix actually uses LU-decomposition for greater accuracy and speed.)
*Note Basic Arithmetic::.

The following functions are applied element-wise if their arguments
are vectors or matrices: `change-sign', `conj', `arg', `re', `im',
`polar', `rect', `clean', `float', `frac'.  *Note Function Index::.

The `V J' (`calc-conj-transpose') [`ctrn'] command computes the
conjugate transpose of its argument, i.e., `conj(trn(x))'.

The `A' (`calc-abs') [`abs'] command computes the Frobenius norm of a
vector or matrix argument.  This is the square root of the sum of the
squares of the absolute values of the elements of the vector or
matrix.  If the vector is interpreted as a point in two- or
three-dimensional space, this is the distance from that point to the
origin.

The `v n' (`calc-rnorm') [`rnorm'] command computes the row norm, or
infinity-norm, of a vector or matrix.  For a plain vector, this is the
maximum of the absolute values of the elements.  For a matrix, this is
the maximum of the row-absolute-value-sums, i.e., of the sums of the
absolute values of the elements along the various rows.

The `V N' (`calc-cnorm') [`cnorm'] command computes the column norm,
or one-norm, of a vector or matrix.  For a plain vector, this is the
sum of the absolute values of the elements.  For a matrix, this is the
maximum of the column-absolute-value-sums.  General `k'-norms for `k'
other than one or infinity are not provided.

The `V C' (`calc-cross') [`cross'] command computes the right-handed
cross product of two vectors, each of which must have exactly three
elements.

The `&' (`calc-inv') [`inv'] command computes the inverse of a square
matrix.  If the matrix is singular, the inverse operation is left in
symbolic form.  Matrix inverses are recorded so that once an inverse
(or determinant) of a particular matrix has been computed, the inverse
and determinant of the matrix can be recomputed quickly in the future.

If the argument to `&' is a plain number `x', this command simply
computes `1/x'.  This is okay, because the `/' operator also does a
matrix inversion when dividing one by a matrix.

The `V D' (`calc-mdet') [`det'] command computes the determinant of a
square matrix.

The `V L' (`calc-mlud') [`lud'] command computes the LU decomposition
of a matrix.  The result is a list of three matrices which, when
multiplied together left-to-right, form the original matrix.  The
first is a permutation matrix that arises from pivoting in the
algorithm, the second is lower-triangular with ones on the diagonal,
and the third is upper-triangular.

The `V T' (`calc-mtrace') [`tr'] command computes the trace of a
square matrix.  This is defined as the sum of the diagonal elements of
the matrix.



File: calc.info, Node: Set Operations, Next: Statistical Operations, Prev: Vector and Matrix Arithmetic, Up: Matrix Functions

Set Operations using Vectors
============================

Calc includes several commands which interpret vectors as "sets" of
objects.  A set is a collection of objects; any given object can
appear only once in the set.  Calc stores sets as vectors of objects
in sorted order.  Objects in a Calc set can be any of the usual
things, such as numbers, variables, or formulas.  Two set elements are
considered equal if they are identical, except that numerically equal
numbers like the integer 4 and the float 4.0 are considered equal even
though they are not "identical."  Variables are treated like plain
symbols without attached values by the set operations; subtracting the
set `[b]' from `[a, b]' always yields the set `[a]' even though if the
variables `a' and `b' both equalled 17, you might expect the answer
`[]'.

If a set contains interval forms, then it is assumed to be a set of
real numbers.  In this case, all set operations require the elements
of the set to be only things that are allowed in intervals: Real
numbers, plus and minus infinity, HMS forms, and date forms.  If there
are variables or other non-real objects present in a real set, all set
operations on it will be left in unevaluated form.

If the input to a set operation is a plain number or interval form A,
it is treated like the one-element vector `[A]'.  The result is always
a vector, except that if the set consists of a single interval, the
interval itself is returned instead.

*Note Logical Operations::, for the `in' function which tests if a
certain value is a member of a given set.  To test if the set `A' is a
subset of the set `B', use `vdiff(A, B) = []'.

The `V +' (`calc-remove-duplicates') [`rdup'] command converts an
arbitrary vector into set notation.  It works by sorting the vector as
if by `V S', then removing duplicates.  (For example, `[a, 5, 4, a,
4.0]' is sorted to `[4, 4.0, 5, a, a]' and then reduced to `[4, 5,
a]').  Overlapping intervals are merged as necessary.  You rarely need
to use `V +' explicitly, since all the other set-based commands apply
`V +' to their inputs before using them.

The `V V' (`calc-set-union') [`vunion'] command computes the union of
two sets.  An object is in the union of two sets if and only if it is
in either (or both) of the input sets.  (You could accomplish the same
thing by concatenating the sets with `|', then using `V +'.)

The `V ^' (`calc-set-intersect') [`vint'] command computes
the intersection of two sets.  An object is in the intersection if
and only if it is in both of the input sets.  Thus if the input
sets are disjoint, i.e., if they share no common elements, the result
will be the empty vector `[]'.  Note that the characters `V'
and `^' were chosen to be close to the conventional mathematical
notation for set union and intersection.

The `V -' (`calc-set-difference') [`vdiff'] command computes the
difference between two sets.  An object is in the difference `A - B'
if and only if it is in `A' but not in `B'.  Thus subtracting `[y,z]'
from a set will remove the elements `y' and `z' if they are present.
You can also think of this as a general "set complement" operator; if
`A' is the set of all possible values, then `A - B' is the
complement" of `B'.  Obviously this is only practical if the set of
all possible values in your problem is small enough to list in a Calc
vector (or simple enough to express in a few intervals).

The `V X' (`calc-set-xor') [`vxor'] command computes the
exclusive-or," or "symmetric difference" of two sets.  An object is in
the symmetric difference of two sets if and only if it is in one, but
*not* both, of the sets.  Objects that occur in both sets "cancel
out."

The `V ~' (`calc-set-complement') [`vcompl'] command
computes the complement of a set with respect to the real numbers.
Thus `vcompl(x)' is equivalent to `vdiff([-inf .. inf], x)'.
For example, `vcompl([2, (3 .. 4]])' evaluates to
`[[-inf .. 2), (2 .. 3], (4 .. inf]]'.

The `V F' (`calc-set-floor') [`vfloor'] command
reinterprets a set as a set of integers.  Any non-integer values,
and intervals that do not enclose any integers, are removed.  Open
intervals are converted to equivalent closed intervals.  Successive
integers are converted into intervals of integers.  For example, the
complement of the set `[2, 6, 7, 8]' is messy, but if you wanted
the complement with respect to the set of integers you could type
`V ~ V F' to get `[[-inf .. 1], [3 .. 5], [9 .. inf]]'.

The `V E' (`calc-set-enumerate') [`venum'] command converts a set of
integers into an explicit vector.  Intervals in the set are expanded
out to lists of all integers encompassed by the intervals.  This only
works for finite sets (i.e., sets which do not involve `-inf' or
`inf').

The `V :' (`calc-set-span') [`vspan'] command converts any
set of reals into an interval form that encompasses all its elements.
The lower limit will be the smallest element in the set; the upper
limit will be the largest element.  For an empty set, `vspan([])'
returns the empty interval `[0 .. 0)'.

The `V #' (`calc-set-cardinality') [`vcard'] command counts the number
of integers in a set.  The result is the length of the vector that
would be produced by `V E', although the computation is much more
efficient than actually producing that vector.

Another representation for sets that may be more appropriate in some
cases is binary numbers.  If you are dealing with sets of integers in
the range 0 to 49, you can use a 50-bit binary number where a
particular bit is 1 if the corresponding element is in the set.  *Note
Binary Functions::, for a list of commands that operate on binary
numbers.  Note that many of the above set operations have direct
equivalents in binary arithmetic: `b o' (`calc-or'), `b a'
(`calc-and'), `b d' (`calc-diff'), `b x' (`calc-xor'), and `b n'
(`calc-not'), respectively.  You can use whatever representation for
sets is most convenient to you.

The `b u' (`calc-unpack-bits') [`vunpack'] command converts an integer
that represents a set in binary into a set in vector/interval
notation.  For example, `vunpack(67)' returns `[[0 .. 1], 6]'.  If the
input is negative, the set it represents is semi-infinite:
`vunpack(-4) = [2 .. inf)'.  Use `V E' afterwards to expand intervals
to individual values if you wish.  Note that this command uses the `b'
(binary) prefix key.

The `b p' (`calc-pack-bits') [`vpack'] command
converts the other way, from a vector or interval representing
a set of nonnegative integers into a binary integer describing
the same set.  The set may include positive infinity, but must
not include any negative numbers.  The input is interpreted as a
set of integers in the sense of `V F' (`vfloor').  Beware
that a simple input like `[100]' can result in a huge integer
representation (`2^100', a 31-digit integer, in this case).



File: calc.info, Node: Statistical Operations, Next: Reducing and Mapping, Prev: Set Operations, Up: Matrix Functions

Statistical Operations on Vectors
=================================

The commands in this section take vectors as arguments and compute
various statistical measures on the data stored in the vectors.  The
references used in the definitions of these functions are Bevington's
*Data Reduction and Error Analysis for the Physical Sciences*, and
*Numerical Recipes* by Press, Flannery, Teukolsky and Vetterling.

The statistical commands use the `u' prefix key followed by a shifted
letter or other character.

*Note Manipulating Vectors::, for a description of `V H'
(`calc-histogram').

*Note Curve Fitting::, for the `a F' command for doing least-squares
fits to statistical data.

*Note Probability Distribution Functions::, for several common
probability distribution functions.

* Menu:

* Single-Variable Statistics::
* Paired-Sample Statistics::



File: calc.info, Node: Single-Variable Statistics, Next: Paired-Sample Statistics, Prev: Statistical Operations, Up: Statistical Operations

Single-Variable Statistics
--------------------------

These functions do various statistical computations on single vectors.
Given a numeric prefix argument, they actually pop N objects from the
stack and combine them into a data vector.  Each object may be either
a number or a vector; if a vector, any sub-vectors inside it are
flattened" as if by `v a 0'; *Note Manipulating Vectors::.  By default
one object is popped, which (in order to be useful) is usually a
vector.

If an argument is a variable name, and the value stored in that
variable is a vector, then the stored vector is used.  This method has
the advantage that if your data vector is large, you can avoid the
slow process of manipulating it directly on the stack.

These functions are left in symbolic form if any of their arguments
are not numbers or vectors, e.g., if an argument is a formula, or a
non-vector variable.  However, formulas embedded within vector
arguments are accepted; the result is a symbolic representation of the
computation, based on the assumption that the formula does not itself
represent a vector.  All varieties of numbers such as error forms and
interval forms are acceptable.

Some of the functions in this section also accept a single error form
or interval as an argument.  They then describe a property of the
normal or uniform (respectively) statistical distribution described
by the argument.  The arguments are interpreted in the same way as
the M argument of the random number function `k r'.  In
particular, an interval with integer limits is considered an integer
distribution, so that `[2 .. 6)' is the same as `[2 .. 5]'.
An interval with at least one floating-point limit is a continuous
distribution:  `[2.0 .. 6.0)' is *not* the same as
`[2.0 .. 5.0]'!

The `u #' (`calc-vector-count') [`vcount'] command computes the number
of data values represented by the inputs.  For example, `vcount(1, [2,
3], [[4, 5], [], x, y])' returns 7.  If the argument is a single
vector with no sub-vectors, this simply computes the length of the
vector.

The `u +' (`calc-vector-sum') [`vsum'] command computes the sum of the
data values.  The `u *' (`calc-vector-prod') [`vprod'] command
computes the product of the data values.  If the input is a single
flat vector, these are the same as `V R +' and `V R *' (*Note Reducing
and Mapping::).

The `u X' (`calc-vector-max') [`vmax'] command computes the maximum of
the data values, and the `u N' (`calc-vector-min') [`vmin'] command
computes the minimum.  If the argument is an interval, this finds the
minimum or maximum value in the interval.  (Note that `vmax([2..6)) =
5' as described above.)  If the argument is an error form, this
returns plus or minus infinity.

The `u M' (`calc-vector-mean') [`vmean'] command computes the average
(arithmetic mean) of the data values.  If the inputs are error forms
`x +/- s', this is the weighted mean of the `x' values with weights `1
/ s^2'.  If the inputs are not error forms, this is simply the sum of
the values divided by the count of the values.

Note that a plain number can be considered an error form with error
`s = 0'.  If the input to `u M' is a mixture of plain numbers and
error forms, the result is the mean of the plain numbers, ignoring all
values with non-zero errors.  (By the above definitions it's clear
that a plain number effectively has an infinite weight, next to which
an error form with a finite weight is completely negligible.)

This function also works for distributions (error forms or intervals).
The mean of an error form `a +/- b' is simply `a'.  The mean of an
interval is the mean of the minimum and maximum values of the
interval.

The `I u M' (`calc-vector-mean-error') [`vmeane'] command computes the
mean of the data points expressed as an error form.  This includes the
estimated error associated with the mean.  If the inputs are error
forms, the error is the square root of the reciprocal of the sum of
the reciprocals of the squares of the input errors.  (I.e., the
variance is the reciprocal of the sum of the reciprocals of the
variances.)  If the inputs are plain numbers, the error is equal to
the standard deviation of the values divided by the square root of the
number of values.  (This works out to be equivalent to calculating the
standard deviation and then assuming each value's error is equal to
this standard deviation.)

The `H u M' (`calc-vector-median') [`vmedian'] command computes the
median of the data values.  The values are first sorted into numerical
order; the median is the middle value after sorting.  (If the number
of data values is even, the median is taken to be the average of the
two middle values.)  The median function is different from the other
functions in this section in that the arguments must all be real
numbers; variables are not accepted even when nested inside vectors.
(Otherwise it is not possible to sort the data values.)  If any of the
input values are error forms, their error parts are ignored.

The median function also accepts distributions.  For both normal
(error form) and uniform (interval) distributions, the median is the
same as the mean.

The `H I u M' (`calc-vector-harmonic-mean') [`vhmean'] command
computes the harmonic mean of the data values.  This is defined as the
reciprocal of the arithmetic mean of the reciprocals of the values.

The `u G' (`calc-vector-geometric-mean') [`vgmean'] command computes
the geometric mean of the data values.  This is the Nth root of the
product of the values.  This is also equal to the `exp' of the
arithmetic mean of the logarithms of the data values.

The `H u G' [`agmean'] command computes the "arithmetic-geometric
mean" of two numbers taken from the stack.  This is computed by
replacing the two numbers with their arithmetic mean and geometric
mean, then repeating until the two values converge.

Another commonly used mean, the RMS (root-mean-square), can be
computed for a vector of numbers simply by using the `A' command.

The `u S' (`calc-vector-sdev') [`vsdev'] command computes the standard
deviation of the data values.  If the values are error forms, the
errors are used as weights just as for `u M'.  This is the *sample*
standard deviation, whose value is the square root of the sum of the
squares of the differences between the values and the mean of the `N'
values, divided by `N-1'.

This function also applies to distributions.  The standard deviation
of a single error form is simply the error part.  The standard
deviation of a continuous interval happens to equal the difference
between the limits, divided by `sqrt(12)'.  The standard deviation of
an integer interval is the same as the standard deviation of a vector
of those integers.

The `I u S' (`calc-vector-pop-sdev') [`vpsdev'] command computes the
*population* standard deviation.  It is defined by the same formula as
above but dividing by `N' instead of by `N-1'.  The population
standard deviation is used when the input represents the entire set of
data values in the distribution; the sample standard deviation is used
when the input represents a sample of the set of all data values, so
that the mean computed from the input is itself only an estimate of
the true mean.

For error forms and continuous intervals, `vpsdev' works exactly like
`vsdev'.  For integer intervals, it computes the population standard
deviation of the equivalent vector of integers.

The `H u S' (`calc-vector-variance') [`vvar'] and `H I u S'
(`calc-vector-pop-variance') [`vpvar'] commands compute the variance
of the data values.  The variance is the square of the standard
deviation, i.e., the sum of the squares of the deviations of the data
values from the mean.  (This definition also applies when the argument
is a distribution.)

The `vflat' algebraic function returns a vector of its arguments,
interpreted in the same way as the other functions in this section.
For example, `vflat(1, [2, [3, 4]], 5)' returns `[1, 2, 3, 4, 5]'.



File: calc.info, Node: Paired-Sample Statistics, Prev: Single-Variable Statistics, Up: Statistical Operations

Paired-Sample Statistics
------------------------

The functions in this section take two arguments, which must be
vectors of equal size.  The vectors are each flattened in the same way
as by the single-variable statistical functions.  Given a numeric
prefix argument of 1, these functions instead take one object from the
stack, which must be an Nx2 matrix of data values.  Once again,
variable names can be used in place of actual vectors and matrices.

The `u C' (`calc-vector-covariance') [`vcov'] command computes the
sample covariance of two vectors.  The covariance of vectors X and Y
is the sum of the products of the differences between the elements of
X and the mean of X times the differences between the corresponding
elements of Y and the mean of Y, all divided by `N-1'.  Note that the
variance of a vector is just the covariance of the vector with itself.
Once again, if the inputs are error forms the errors are used as
weight factors.  If both X and Y are composed of error forms, the
error for a given data point is taken as the square root of the sum of
the squares of the two input errors.

The `I u C' (`calc-vector-pop-covariance') [`vpcov'] command computes
the population covariance, which is the same as the sample covariance
computed by `u C' except dividing by `N' instead of `N-1'.

The `H u C' (`calc-vector-correlation') [`vcorr'] command computes the
linear correlation coefficient of two vectors.  This is defined by the
covariance of the vectors divided by the product of their standard
deviations.  (There is no difference between sample or population
statistics here.)



File: calc.info, Node: Reducing and Mapping, Next: Vector and Matrix Formats, Prev: Statistical Operations, Up: Matrix Functions

Reducing and Mapping Vectors
============================

The commands in this section allow for more general operations on the
elements of vectors.

The simplest of these operations is `V A' (`calc-apply')
[`apply'], which applies a given operator to the elements of a vector.
For example, applying the hypothetical function `f' to the vector
`[1, 2, 3]' would produce the function call `f(1, 2, 3)'.
Applying the `+' function to the vector `[a, b]' gives
`a + b'.  Applying `+' to the vector `[a, b, c]' is an
error, since the `+' function expects exactly two arguments.

While `V A' is useful in some cases, you will usually find that either
`V R' or `V M', described below, is closer to what you want.

* Menu:

* Specifying Operators::
* Mapping::
* Reducing::
* Nesting and Fixed Points::
* Generalized Products::



File: calc.info, Node: Specifying Operators, Next: Mapping, Prev: Reducing and Mapping, Up: Reducing and Mapping

Specifying Operators
--------------------

Commands in this section (like `V A') prompt you to press the key
corresponding to the desired operator.  Press `?' for a partial list
of the available operators.  Generally, an operator is any key or
sequence of keys that would normally take one or more arguments from
the stack and replace them with a result.  For example, `V A H C' uses
the hyperbolic cosine operator, `cosh'.  (Since `cosh' expects one
argument, `V A H C' requires a vector with a single element as its
argument.)

You can press `x' at the operator prompt to select any algebraic
function by name to use as the operator.  This includes functions you
have defined yourself using the `Z F' command.  (*Note Algebraic
Definitions::.)  If you give a name for which no function has been
defined, the result is left in symbolic form, as in `f(1, 2, 3)'.
Calc will prompt for the number of arguments the function takes if it
can't figure it out on its own (say, because you named a function that
is currently undefined).  It is also possible to type a digit key
before the function name to specify the number of arguments, e.g., `V
M 3 x f RET' calls `f' with three arguments even if it looks like it
ought to have only two.  This technique may be necessary if the
function allows a variable number of arguments.  For example, the `v
e' [`vexp'] function accepts two or three arguments; if you want to
map with the three-argument version, you will have to type `V M 3 v
e'.

It is also possible to apply any formula to a vector by treating that
formula as a function.  When prompted for the operator to use, press
`'' (the apostrophe) and type your formula as an algebraic entry.
You will then be prompted for the argument list, which defaults to a
list of all variables that appear in the formula, sorted into alphabetic
order.  For example, suppose you enter the formula `x + 2y^x'.
The default argument list would be `(x y)', which means that if
this function is applied to the arguments `[3, 10]' the result will
be `3 + 2*10^3'.  (If you plan to use a certain formula in this
way often, you might consider defining it as a function with `Z F'.)

Another way to specify the arguments to the formula you enter is with
`$', `$$', and so on.  For example, `V A ' $$ + 2$^$$' has the same
effect as the previous example.  The argument list is automatically
taken to be `($$ $)'.  (The order of the arguments may seem backwards,
but it is analogous to the way normal algebraic entry interacts with
the stack.)

If you press `$' at the operator prompt, the effect is similar to the
apostrophe except that the relevant formula is taken from top-of-stack
instead.  The actual vector arguments of the `V A $' or related
command then start at the second-to-top stack position.  You will
still be prompted for an argument list.

A function can be written without a name using the notation `<#1 - #2>',
which means "a function of two arguments that computes the first
argument minus the second argument."  The symbols `#1' and `#2'
are placeholders for the arguments.  You can use any names for these
placeholders if you wish, by including an argument list followed by a
colon:  `<x, y : x - y>'.  When you type `V A ' $$ + 2$^$$ RET',
Calc builds the nameless function `<#1 + 2 #2^#1>' as the function
to map across the vectors.  When you type `V A ' x + 2y^x RET RET',
Calc builds the nameless function `<x, y : x + 2 y^x>'.  In both
cases, Calc also writes the nameless function to the Trail so that you
can get it back later if you wish.

If there is only one argument, you can write `#' in place of `#1'.
(Note that `< >' notation is also used for date forms.  Calc tells
that `<STUFF>' is a nameless function by the presence of `#' signs
inside STUFF, or by the fact that STUFF begins with a list of
variables followed by a colon.)

You can type a nameless function directly to `V A '', or put one on
the stack and use it with `V A $'.  Calc will not prompt for an
argument list in this case, since the nameless function specifies the
argument list as well as the function itself.  In `V A '', you can
omit the `< >' marks if you use `#' notation for the arguments,
so that `V A ' #1+#2 RET' is the same as `V A ' <#1+#2> RET',
which in turn is the same as `V A ' $$+$ RET'.

The internal format for `<x, y : x + y>' is `lambda(x, y, x + y)'.
(The word `lambda' derives from Lisp notation and the theory of
functions.)  The internal format for `<#1 + #2>' is `lambda(ArgA,
ArgB, ArgA + ArgB)'.  Note that there is no actual Calc function
called `lambda'; the whole point is that the `lambda' expression is
used in its symbolic form, not evaluated for an answer until it is
applied to specific arguments by a command like `V A' or `V M'.

(Actually, `lambda' does have one special property: Its arguments are
never evaluated; for example, putting `<(2/3) #>' on the stack will
not simplify the `2/3' until the nameless function is actually
called.)

As usual, commands like `V A' have algebraic function name
equivalents.  For example, `V A k g' with an argument of `v' is
equivalent to `apply(gcd, v)'.  The first argument specifies the
operator name, and is either a variable whose name is the same as the
function name, or a nameless function like `<#^3+1>'.  Operators that
are normally written as algebraic symbols have the names `add', `sub',
`mul', `div', `pow', `neg', `mod', and `vconcat'.

The `call' function builds a function call out of several arguments:
`call(gcd, x, y)' is the same as `apply(gcd, [x, y])', which in turn
is the same as `gcd(x, y)'.  The first argument of `call', like the
other functions described here, may be either a variable naming a
function, or a nameless function (`call(<#1+2#2>, x, y)' is the same
as `x + 2y').

(Experts will notice that it's not quite proper to use a variable to
name a function, since the name `gcd' corresponds to the Lisp variable
`var-gcd' but to the Lisp function `calcFunc-gcd'.  Calc automatically
makes this translation, so you don't have to worry about it.)



