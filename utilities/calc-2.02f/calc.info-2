Info file: calc.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `calc.texinfo'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the author
instead of in the original English.




File: calc.info, Node: Tutorial, Next: Introduction, Prev: Getting Started, Up: Top

Tutorial
********

This chapter explains how to use Calc and its many features, in a
step-by-step, tutorial way.  You are encouraged to run Calc and work
along with the examples as you read (*Note Starting Calc::).  If you
are already familiar with advanced calculators, you may wish to skip
on to the rest of this manual.

This tutorial describes the standard user interface of Calc only.  The
Quick Mode" and "Keypad Mode" interfaces are fairly self-explanatory.
*Note Embedded Mode::, for a description of the "Embedded Mode"
interface.

The easiest way to read this tutorial on-line is to have two windows
on your Emacs screen, one with Calc and one with the Info system.  (If
you have a printed copy of the manual you can use that instead.)
Press `M-# c' to turn Calc on or to switch into the Calc window, and
press `M-# i' to start the Info system or to switch into its window.
Or, you may prefer to use the tutorial in printed form.

This tutorial is designed to be done in sequence.  But the rest of
this manual does not assume you have gone through the tutorial.  The
tutorial does not cover everything in the Calculator, but it touches
on most general areas.

You may wish to print out a copy of the Calc Summary and keep notes on
it as you learn Calc.  *Note Installation::, to see how to make a
printed summary.  *Note Summary::.

* Menu:

* Basic Tutorial::
* Arithmetic Tutorial::
* Vector/Matrix Tutorial::
* Types Tutorial::
* Algebra Tutorial::
* Programming Tutorial::

* Answers to Exercises::



File: calc.info, Node: Basic Tutorial, Next: Arithmetic Tutorial, Prev: Tutorial, Up: Tutorial

Basic Tutorial
==============

In this section, we learn how RPN and algebraic-style calculations
work, how to undo and redo an operation done by mistake, and how to
control various modes of the Calculator.

* Menu:

* RPN Tutorial::            Basic operations with the stack.
* Algebraic Tutorial::      Algebraic entry; variables.
* Undo Tutorial::           If you make a mistake: Undo and the trail.
* Modes Tutorial::          Common mode-setting commands.



File: calc.info, Node: RPN Tutorial, Next: Algebraic Tutorial, Prev: Basic Tutorial, Up: Basic Tutorial

RPN Calculations and the Stack
------------------------------

Calc normally uses RPN notation.  You may be familiar with the RPN
system from Hewlett-Packard calculators, FORTH, or PostScript.
(Reverse Polish Notation, RPN, is named after the Polish mathematician
Jan Lukasiewicz.)

The central component of an RPN calculator is the "stack".  A
calculator stack is like a stack of dishes.  New dishes (numbers) are
added at the top of the stack, and numbers are normally only removed
from the top of the stack.

In an operation like `2+3', the 2 and 3 are called the "operands" and
the `+' is the "operator".  In an RPN calculator you always enter the
operands first, then the operator.  Each time you type a number, Calc
adds or "pushes" it onto the top of the Stack.  When you press an
operator key like `+', Calc "pops" the appropriate number of operands
from the stack and pushes back the result.

Thus we could add the numbers 2 and 3 in an RPN calculator by typing:
`2 RET 3 RET +'.  (The RET key, Return, corresponds to the ENTER key
on traditional RPN calculators.)  Try this now if you wish; type `M-#
c' to switch into the Calc window (you can type `M-# c' again or `M-#
o' to switch back to the Tutorial window).  The first four keystrokes
push" the numbers 2 and 3 onto the stack.  The `+' key "pops" the top
two numbers from the stack, adds them, and pushes the result (5) back
onto the stack.  Here's how the stack will look at various points
throughout the calculation:

	 .          1:  2          2:  2          1:  5              .
                        .1:  3              .
				       .

       M-# c          2 RET          3 RET            +             DEL

The `.' symbol is a marker that represents the top of the stack.  Note
that the "top" of the stack is really shown at the bottom of the Stack
window.  This may seem backwards, but it turns out to be less
distracting in regular use.

The numbers `1:' and `2:' on the left are "stack level numbers".  Old
RPN calculators always had four stack levels called `x', `y', `z', and
`t'.  Calc's stack can grow as large as you like, so it uses numbers
instead of letters.  Some stack-manipulation commands accept a numeric
argument that says which stack level to work on.  Normal commands like
`+' always work on the top few levels of the stack.

The Stack buffer is just an Emacs buffer, and you can move around in
it using the regular Emacs motion commands.  But no matter where the
cursor is, even if you have scrolled the `.' marker out of view, most
Calc commands always move the cursor back down to level 1 before doing
anything.  It is possible to move the `.' marker upwards through the
stack, temporarily "hiding" some numbers from commands like `+'.  This
is called "stack truncation" and we will not cover it in this
tutorial; *Note Truncating the Stack::, if you are interested.

You don't really need the second RET in `2 RET 3 RET +'.  That's
because if you type any operator name or other non-numeric key when
you are entering a number, the Calculator automatically enters that
number and then does the requested command.  Thus `2 RET 3 +' will
work just as well.

Examples in this tutorial will often omit RET even when the stack
displays shown would only happen if you did press RET:

     1:  2          2:  2          1:  5
	 .          1:  3              .
                        .

       2 RET            3              +

Here, after pressing `3' the stack would really show `1: 2' with
`Calc: 3' in the minibuffer.  In these situations, you can press the
optional RET to see the stack as the figure shows.

(*) *Exercise 1.* (This tutorial will include exercises at various
points.  Try them if you wish.  Answers to all the exercises are
located at the end of the Tutorial chapter.  Each exercise will
include a cross-reference to its particular answer.  If you are
reading with the Emacs Info system, press `f' and the exercise number
to go to the answer, then the letter `l' to return to where you were.)

Here's the first exercise: What will the keystrokes `1 RET 2 RET 3 RET
4 + * -' compute?  (`*' is the symbol for multiplication.)  Figure it
out by hand, then try it with Calc to see if you're right.  *Note 1:
RPN Answer 1. (*)

(*) *Exercise 2.* Compute `2*4 + 7*9.5 + 5/4' using the stack.  *Note
2: RPN Answer 2. (*)

The DEL key is called Backspace on some keyboards.  It is whatever key
you would use to correct a simple typing error when regularly using
Emacs.  The DEL key pops and throws away the top value on the stack.
(You can still get that value back from the Trail if you should need
it later on.)  There are many places in this tutorial where we assume
you have used DEL to erase the results of the previous example at the
beginning of a new example.  In the few places where it is really
important to use DEL to clear away old results, the text will remind
you to do so.

(It won't hurt to let things accumulate on the stack, except that
whenever you give a display-mode-changing command Calc will have to
spend a long time reformatting such a large stack.)

Since the `-' key is also an operator (it subtracts the top two stack
elements), how does one enter a negative number?  Calc uses the `_'
(underscore) key to act like the minus sign in a number.  So, typing
`-5 RET' won't work because the `-' key will try to do a subtraction,
but `_5 RET' works just fine.

You can also press `n', which means "change sign."  It changes the
number at the top of the stack (or the number being entered) from
positive to negative or vice-versa: `5 n RET'.

If you press RET when you're not entering a number, the effect is to
duplicate the top number on the stack.  Consider this calculation:

     1:  3          2:  3          1:  9          2:  9          1:  81
	 .          1:  3              .          1:  9              .
                        ..

       3 RET           RET             *             RET             *

(Of course, an easier way to do this would be `3 RET 4 ^', to raise 3
to the fourth power.)

The space-bar key (denoted SPC here) performs the same function as
RET; you could replace all three occurrences of RET in the above
example with SPC and the effect would be the same.

Another stack manipulation key is TAB.  This exchanges the top two
stack entries.  Suppose you have computed `2 RET 3 +' to get 5, and
then you realize what you really wanted to compute was `20 / (2+3)'.

     1:  5          2:  5          2:  20         1:  4
	 .          1:  20         1:  5              .
                        ..

      2 RET 3 +         20            TAB             /

Planning ahead, the calculation would have gone like this:

     1:  20         2:  20         3:  20         2:  20         1:  4
	 .          1:  2          2:  2          1:  5              .
                        .1:  3              .
				       .

       20 RET         2 RET            3              +              /

A related stack command is `M-TAB' (hold META and type TAB).  It
rotates the top three elements of the stack upward, bringing the
object in level 3 to the top.

     1:  10         2:  10         3:  10         3:  20         3:  30
	 .          1:  20         2:  20         2:  30         2:  10
                        .1:  30         1:  10         1:  20
				       .              .              .

       10 RET         20 RET         30 RET         M-TAB          M-TAB

(*) *Exercise 3.* Suppose the numbers 10, 20, and 30 are on the stack.
Figure out how to add one to the number in level 2 without affecting
the rest of the stack.  Also figure out how to add one to the number
in level 3.  *Note 3: RPN Answer 3. (*)

Operations like `+', `-', `*', `/', and `^' pop two arguments from the
stack and push a result.  Operations like `n' and `Q' (square root)
pop a single number and push the result.  You can think of them as
simply operating on the top element of the stack.

     1:  3          1:  9          2:  9          1:  25         1:  5
	 .              .          1:  16             .              .
				       .

       3 RET          RET *        4 RET RET *        +              Q

(Note that capital `Q' means to hold down the Shift key while typing
`q'.  Remember, plain unshifted `q' is the Quit command.)

Here we've used the Pythagorean Theorem to determine the hypotenuse of
a right triangle.  Calc actually has a built-in command for that
called `f h', but let's suppose we can't remember the necessary
keystrokes.  We can still enter it by its full name using `M-x'
notation:

     1:  3          2:  3          1:  5
	 .          1:  4              .
                        .

       3 RET          4 RET      M-x calc-hypot

All Calculator commands begin with the word `calc-'.  Since it gets
tiring to type this, Calc provides an `x' key which is just like the
regular Emacs `M-x' key except that it types the `calc-' prefix for
you:

     1:  3          2:  3          1:  5
	 .          1:  4              .
                        .

       3 RET          4 RET         x hypot

What happens if you take the square root of a negative number?

     1:  4          1:  -4         1:  (0, 2)
	 .              .              .

       4 RET            n              Q

The notation `(a, b)' represents a complex number.
Complex numbers are more traditionally written `a + b i';
Calc can display in this format, too, but for now we'll stick to the
`(a, b)' notation.

If you don't know how complex numbers work, you can safely ignore this
feature.  Complex numbers only arise from operations that would be
errors in a calculator that didn't have complex numbers.  (For
example, taking the square root or logarithm of a negative number
produces a complex result.)

Complex numbers are entered in the notation shown.  The `(' and
`,' and `)' keys manipulate "incomplete complex numbers."

     1:  ( ...      2:  ( ...      1:  (2, ...    1:  (2, ...    1:  (2, 3)
	 .          1:  2              .              3              .
                        ..

	 (              2              ,              3              )

You can perform calculations while entering parts of incomplete
objects.  However, an incomplete object cannot actually participate in
a calculation:

     1:  ( ...      2:  ( ...      3:  ( ...      1:  ( ...      1:  ( ...
	 .          1:  2          2:  2              5              5
                        .1:  3              .              .
				       .
								  (error)
	 (             2 RET           3              +              +

Adding 5 to an incomplete object makes no sense, so the last command
produces an error message and leaves the stack the same.

Incomplete objects can't participate in arithmetic, but they can be
moved around by the regular stack commands.

     2:  2          3:  2          3:  3          1:  ( ...      1:  (2, 3)
     1:  3          2:  3          2:  ( ...          2              .
	 .          1:  ( ...      1:  2              3
                        ..              .

     2 RET 3 RET        (            M-TAB          M-TAB            )

Note that the `,' (comma) key did not have to be used here.  When you
press `)' all the stack entries between the incomplete entry and the
top are collected, so there's never really a reason to use the comma.
It's up to you.

(*) *Exercise 4.*  To enter the complex number `(2, 3)',
your friend Joe typed `( 2 , SPC 3 )'.  What happened?
(Joe thought of a clever way to correct his mistake in only two
keystrokes, but it didn't quite work.  Try it to find out why.)
*Note 4: RPN Answer 4. (*)

Vectors are entered the same way as complex numbers, but with square
brackets in place of parentheses.  We'll meet vectors again later in
the tutorial.

Any Emacs command can be given a "numeric prefix argument" by
typing a series of META-digits beforehand.  If META is
awkward for you, you can instead type `C-u' followed by the
necessary digits.  Numeric prefix arguments can be negative, as in
`M-- M-3 M-5' or `C-u - 3 5'.  Calc commands use numeric
prefix arguments in a variety of ways.  For example, a numeric prefix
on the `+' operator adds any number of stack entries at once:

     1:  10         2:  10         3:  10         3:  10         1:  60
	 .          1:  20         2:  20         2:  20             .
                        .1:  30         1:  30
				       .              .

       10 RET         20 RET         30 RET         C-u 3            +

For stack manipulation commands like RET, a positive numeric prefix
argument operates on the top N stack entries at once.  A negative
argument operates on the entry in level N only.  An argument of zero
operates on the entire stack.  In this example, we copy the
second-to-top element of the stack:

     1:  10         2:  10         3:  10         3:  10         4:  10
	 .          1:  20         2:  20         2:  20         3:  20
                        .1:  30         1:  30         2:  30
				       .              .          1:  20
								     .

       10 RET         20 RET         30 RET         C-u -2          RET

Another common idiom is `M-0 DEL', which clears the stack.  (The `M-0'
numeric prefix tells DEL to operate on the entire stack.)



File: calc.info, Node: Algebraic Tutorial, Next: Undo Tutorial, Prev: RPN Tutorial, Up: Basic Tutorial

Algebraic-Style Calculations
----------------------------

If you are not used to RPN notation, you may prefer to operate the
Calculator in "algebraic mode," which is closer to the way non-RPN
calculators work.  In algebraic mode, you enter formulas in
traditional `2+3' notation.

You don't really need any special "mode" to enter algebraic formulas.
You can enter a formula at any time by pressing the apostrophe (`'')
key.  Answer the prompt with the desired formula, then press RET.
The formula is evaluated and the result is pushed onto the RPN stack.
If you don't want to think in RPN at all, you can enter your whole
computation as a formula, read the result from the stack, then press
DEL to delete it from the stack.

Try pressing the apostrophe key, then `2+3+4', then RET.  The result
should be the number 9.

Algebraic formulas use the operators `+', `-', `*',
`/', and `^'.  You can use parentheses to make the order
of evaluation clear.  In the absence of parentheses, `^' is
evaluated first, then `*', then `/', then finally
`+' and `-'.  For example, the expression

     2 + 3*4*5 / 6*7^8 - 9

is equivalent to

     2 + ((3*4*5) / (6*(7^8)) - 9

or, in large mathematical notation,

	 3 * 4 * 5
     2 + --------- - 9
	       8
	  6 * 7

The result of this expression will be the number -6.99999826533.

Calc's order of evaluation is the same as for most computer languages,
except that `*' binds more strongly than `/', as the above example
shows.  As in normal mathematical notation, the `*' symbol can often
be omitted: `2 a' is the same as `2*a'.

Operators at the same level are evaluated from left to right, except
that `^' is evaluated from right to left.  Thus, `2-3-4' is equivalent
to `(2-3)-4' or -5, whereas `2^3^4' is equivalent to `2^(3^4)' (a very
large integer; try it!).

If you tire of typing the apostrophe all the time, there is an
"algebraic mode" you can select in which Calc automatically senses
when you are about to type an algebraic expression.  To enter this
mode, press the two letters `m a'.  (An `Alg' indicator
should appear in the Calc window's mode line.)

Press `m a', then `2+3+4' with no apostrophe, then RET.

In algebraic mode, when you press any key that would normally begin
entering a number (such as a digit, a decimal point, or the `_' key),
or if you press `(' or `[', Calc automatically begins an algebraic
entry.

Functions which do not have operator symbols like `+' and `*' must be
entered in formulas using function-call notation.  For example, the
function name corresponding to the square-root key `Q' is `sqrt'.  To
compute a square root in a formula, you would use the notation
`sqrt(X)'.

Press the apostrophe, then type `sqrt(5*2) - 3'.  The result should be
`0.16227766017'.

Note that if the formula begins with a function name, you need to use
the apostrophe even if you are in algebraic mode.  If you type
`arcsin' out of the blue, the `a r' will be taken as an Algebraic
Rewrite command, and the `csin' will be taken as the name of the
rewrite rule to use!

Some people prefer to enter complex numbers and vectors in algebraic
form because they find RPN entry with incomplete objects to be too
distracting, even though they otherwise use Calc as an RPN calculator.

Still in algebraic mode, type:

     1:  (2, 3)     2:  (2, 3)     1:  (8, -1)    2:  (8, -1)    1:  (9, -1)
	 .          1:  (1, -2)        .          1:  1              .
                        ..

      (2,3) RET      (1,-2) RET        *              1 RET          +

Algebraic mode allows us to enter complex numbers without pressing an
apostrophe first, but it also means we need to press RET after every
entry, even for a simple number like `1'.

(You can type `C-u m a' to enable a special "incomplete algebraic
mode" in which the `(' and `[' keys use algebraic entry even though
regular numeric keys still use RPN numeric entry.  There is also a
total algebraic mode," started by typing `m t', in which all normal
keys begin algebraic entry.  You must then use the META key to type
Calc commands: `M-m t' to get back out of total algebraic mode, `M-q'
to quit, etc.  Total algebraic mode is not supported under Emacs 19.)

If you're still in algebraic mode, press `m a' again to turn it off.

Actual non-RPN calculators use a mixture of algebraic and RPN styles.
In general, operators of two numbers (like `+' and `*')
use algebraic form, but operators of one number (like `n' and `Q')
use RPN form.  Also, a non-RPN calculator allows you to see the
intermediate results of a calculation as you go along.  You can
accomplish this in Calc by performing your calculation as a series
of algebraic entries, using the `$' sign to tie them together.
In an algebraic formula, `$' represents the number on the top
of the stack.  Here, we perform the calculation `sqrt(2*4+1)',
which on a traditional calculator would be done by pressing
`2 * 4 + 1 =' and then the square-root key.

     1:  8          1:  9          1:  3
	 .              .              .

       ' 2*4 RET        $+1 RET        Q

Notice that we didn't need to press an apostrophe for the `$+1',
because the dollar sign always begins an algebraic entry.

(*) *Exercise 1.*  How could you get the same effect as
pressing `Q' but using an algebraic entry instead?  How about
if the `Q' key on your keyboard were broken?
*Note 1: Algebraic Answer 1. (*)

The notations `$$', `$$$', and so on stand for higher stack entries.
For example, `' $$+$ RET' is just like typing `+'.

Algebraic formulas can include "variables".  To store in a
variable, press `s s', then type the variable name, then press
RET.  (There are actually two flavors of store command:
`s s' stores a number in a variable but also leaves the number
on the stack, while `s t' removes a number from the stack and
stores it in the variable.)  A variable name should consist of one
or more letters or digits, beginning with a letter.

     1:  17             .          1:  a + a^2    1:  306
	 .                             .              .

	 17          s t a RET      ' a+a^2 RET       =

The `=' key "evaluates" a formula by replacing all its variables by
the values that were stored in them.

For RPN calculations, you can recall a variable's value on the stack
either by entering its name as a formula and pressing `=', or by using
the `s r' command.

     1:  17         2:  17         3:  17         2:  17         1:  306
	 .          1:  17         2:  17         1:  289            .
                        .1:  2              .
				       .

       s r a RET     ' a RET =         2              ^              +

If you press a single digit for a variable name (as in `s t 3', you
get one of ten "quick variables" `q0' through `q9'.
They are "quick" simply because you don't have to type the letter
`q' or the RET after their names.  In fact, you can type
simply `s 3' as a shorthand for `s s 3', and likewise for
`t 3' and `r 3'.

Any variables in an algebraic formula for which you have not stored
values are left alone, even when you evaluate the formula.

     1:  2 a + 2 b     1:  34 + 2 b
	 .                 .

      ' 2a+2b RET          =

Calls to function names which are undefined in Calc are also left
alone, as are calls for which the value is undefined.

     1:  2 + log10(0) + log10(x) + log10(5, 6) + foo(3)
	 .

      ' log10(100) + log10(0) + log10(x) + log10(5,6) + foo(3) RET

In this example, the first call to `log10' works, but the other calls
are not evaluated.  In the second call, the logarithm is undefined for
that value of the argument; in the third, the argument is symbolic,
and in the fourth, there are too many arguments.  In the fifth case,
there is no function called `foo'.  You will see a "Wrong number of
arguments" message referring to `log10(5,6)'.  Press the `w' ("why")
key to see any other messages that may have arisen from the last
calculation.  In this case you will get "logarithm of zero," then
number expected: `x'".  Calc automatically displays the first message
only if the message is sufficiently important; for example, Calc
considers "wrong number of arguments" and "logarithm of zero" to be
important enough to report automatically, while a message like "number
expected: `x'" will only show up if you explicitly press the `w' key.

(*) *Exercise 2.*  Joe entered the formula `2 x y',
stored 5 in `x', pressed `=', and got the expected result,
`10 y'.  He then tried the same for the formula `2 x (1+y)',
expecting `10 (1+y)', but it didn't work.  Why not?
*Note 2: Algebraic Answer 2. (*)

(*) *Exercise 3.*  What result would you expect
`1 RET 0 /' to give?  What if you then type `0 *'?
*Note 3: Algebraic Answer 3. (*)

One interesting way to work with variables is to use the
evaluates-to" (`=>') operator.  It works like this: Enter a formula
algebraically in the usual way, but follow the formula with an `=>'
symbol.  (There is also an `s =' command which builds an `=>' formula
using the stack.)  On the stack, you will see two copies of the
formula with an `=>' between them.  The lefthand formula is exactly
like you typed it; the righthand formula has been evaluated as if by
typing `='.

     2:  2 + 3 => 5                     2:  2 + 3 => 5
     1:  2 a + 2 b => 34 + 2 b          1:  2 a + 2 b => 20 + 2 b
	 .                                  .

     ' 2+3 => RET  ' 2a+2b RET s =          10 s t a RET

Notice that the instant we stored a new value in `a', all `=>'
operators already on the stack that referred to `a' were updated to
use the new value.  With `=>', you can push a set of formulas on the
stack, then change the variables experimentally to see the effects on
the formulas' values.

You can also "unstore" a variable when you are through with it:

     2:  2 + 5 => 5
     1:  2 a + 2 b => 2 a + 2 b
	 .

	 s u a RET

We will encounter formulas involving variables and functions again
when we discuss the algebra and calculus features of the Calculator.



File: calc.info, Node: Undo Tutorial, Next: Modes Tutorial, Prev: Algebraic Tutorial, Up: Basic Tutorial

Undo and Redo
-------------

If you make a mistake, you can usually correct it by pressing
shift-`U', the "undo" command.  First, clear the stack (`M-0 DEL') and
exit and restart Calc (`M-# M-# M-# M-#') to make sure things start
off with a clean slate.  Now:

     1:  2          2:  2          1:  8          2:  2          1:  6
	 .          1:  3              .          1:  3              .
                        ..

        2RET           3              ^              U              *

You can undo any number of times.  Calc keeps a complete record of all
you have done since you last opened the Calc window.  After the above
example, you could type:

     1:  6          2:  2          1:  2              .              .
	 .          1:  3              .
                        .
								  (error)
                        UU              U              U

You can also type `D' to "redo" a command that you have undone
mistakenly.

	 .          1:  2          2:  2          1:  6          1:  6
                        .1:  3              .              .
				       .
								  (error)
                        DD              D              D

It was not possible to redo past the `6', since that was placed there
by something other than an undo command.

You can think of undo and redo as a sort of "time machine."  Press `U'
to go backward in time, `D' to go forward.  If you go backward and do
something (like `*') then, as any science fiction reader knows, you
have changed your future and you cannot go forward again.  Thus, the
inability to redo past the `6' even though there was an earlier undo
command.

You can always recall an earlier result using the Trail.  We've
ignored the trail so far, but it has been faithfully recording
everything we did since we loaded the Calculator.  If the Trail is not
displayed, press `t d' now to turn it on.

Let's try grabbing an earlier result.  The `8' we computed was
undone by a `U' command, and was lost even to Redo when we pressed
`*', but it's still there in the trail.  There should be a little
`>' arrow (the "trail pointer") resting on the last trail
entry.  If there isn't, press `t ]' to reset the trail pointer.
Now, press `t p' to move the arrow onto the line containing
`8', and press `t y' to "yank" that number back onto the
stack.

If you press `t ]' again, you will see that even our Yank command went
into the trail.

Let's go further back in time.  Earlier in the tutorial we computed a
huge integer using the formula `2^3^4'.  We don't remember what it
was, but the first digits were "241".  Press `t r' (which stands for
trail-search-reverse), then type `241'.  The trail cursor will jump
back to the next previous occurrence of the string "241" in the trail.
This is just a regular Emacs incremental search; you can now press
`C-s' or `C-r' to continue the search forwards or backwards as you
like.

To finish the search, press RET.  This halts the incremental search
and leaves the trail pointer at the thing we found.  Now we can type
`t y' to yank that number onto the stack.  If we hadn't remembered the
241", we could simply have searched for `2^3^4', then pressed `RET t
n' to halt and then move to the next item.

You may have noticed that all the trail-related commands begin with
the letter `t'.  (The store-and-recall commands, on the other hand,
all began with `s'.)  Calc has so many commands that there aren't
enough keys for all of them, so various commands are grouped into
two-letter sequences where the first letter is called the "prefix"
key.  If you type a prefix key by accident, you can press `C-g' to
cancel it.  (In fact, you can press `C-g' to cancel almost anything in
Emacs.)  To get help on a prefix key, press that key followed by `?'.
Some prefixes have several lines of help, so you need to press `?'
repeatedly to see them all.  This may not work under Lucid Emacs, but
you can also type `h h' to see all the help at once.

Try pressing `t ?' now.  You will see a line of the form,

     trail/time: Display; Fwd, Back; Next, Prev, Here, [, ]; Yank:  [MORE]  t-

The word "trail" indicates that the `t' prefix key contains
trail-related commands.  Each entry on the line shows one command,
with a single capital letter showing which letter you press to get
that command.  We have used `t n', `t p', `t ]', and `t y' so far.
The `[MORE]' means you can press `?'  again to see more `t'-prefix
comands.  Notice that the commands are roughly divided (by semicolons)
into related groups.

When you are in the help display for a prefix key, the prefix is still
active.  If you press another key, like `y' for example, it will be
interpreted as a `t y' command.  If all you wanted was to look at the
help messages, press `C-g' afterwards to cancel the prefix.

One more way to correct an error is by editing the stack entries.  The
actual Stack buffer is marked read-only and must not be edited
directly, but you can press ``' (the backquote or accent grave) to
edit a stack entry.

Try entering `3.141439' now.  If this is supposed to represent `pi',
it's got several errors.  Press ``' to edit this number.  Now use the
normal Emacs cursor motion and editing keys to change the second 4 to
a 5, and to transpose the 3 and the 9.  When you press RET, the number
on the stack will be replaced by your new number.  This works for
formulas, vectors, and all other types of values you can put on the
stack.  The ``' key also works during entry of a number or algebraic
formula.



File: calc.info, Node: Modes Tutorial, Prev: Undo Tutorial, Up: Basic Tutorial

Mode-Setting Commands
---------------------

Calc has many types of "modes" that affect the way it interprets your
commands or the way it displays data.  We have already seen one mode,
namely algebraic mode.  There are many others, too; we'll try some of
the most common ones here.

Perhaps the most fundamental mode in Calc is the current "precision".
Notice the `12' on the Calc window's mode line:

     --%%-Calc: 12 Deg       (Calculator)----All------

Most of the symbols there are Emacs things you don't need to worry
about, but the `12' and the `Deg' are mode indicators.  The `12' means
that calculations should always be carried to 12 significant figures.
That is why, when we type `1 RET 7 /', we get `0.142857142857' with
exactly 12 digits, not counting leading and trailing zeros.

You can set the precision to anything you like by pressing `p', then
entering a suitable number.  Try pressing `p 30 RET', then doing `1
RET 7 /' again:

     1:  0.142857142857
     2:  0.142857142857142857142857142857
	 .

Although the precision can be set arbitrarily high, Calc always has to
have *some* value for the current precision.  After all, the true
value `1/7' is an infinitely repeating decimal; Calc has to stop
somewhere.

Of course, calculations are slower the more digits you request.
Press `p 12' now to set the precision back down to the default.

Calculations always use the current precision.  For example, even
though we have a 30-digit value for `1/7' on the stack, if
we use it in a calculation in 12-digit mode it will be rounded
down to 12 digits before it is used.  Try it; press RET to
duplicate the number, then `1 +'.  Notice that the RET
key didn't round the number, because it doesn't do any calculation.
But the instant we pressed `+', the number was rounded down.

     1:  0.142857142857
     2:  0.142857142857142857142857142857
     3:  1.14285714286
	 .

In fact, since we added a digit on the left, we had to lose one digit
on the right from even the 12-digit value of `1/7'.

How did we get more than 12 digits when we computed `2^3^4'?  The
answer is that Calc makes a distinction between "integers" and
floating-point" numbers, or "floats".  An integer is a number that
does not contain a decimal point.  There is no such thing as an
infinitely repeating fraction integer," so Calc doesn't have to limit
itself.  If you asked for `2^10000' (don't try this!), you would have
to wait a long time but you would eventually get an exact answer.  If
you ask for `2.^10000', you will quickly get an answer which is
correct only to 12 places.  The decimal point tells Calc that it
should use floating-point arithmetic to get the answer, not exact
integer arithmetic.

You can use the `F' (`calc-floor') command to convert a floating-point
value to an integer, and `c f' (`calc-float') to convert an integer to
floating-point form.

Let's try entering that last calculation:

     1:  2.         2:  2.         1:  1.99506311689e3010
	 .          1:  10000          .
                        .

       2.0 RET          10000 RET      ^

Notice the letter `e' in there.  It represents "times ten to the power
of," and is used by Calc automatically whenever writing the number out
fully would introduce more extra zeros than you probably want to see.
You can enter numbers in this notation, too.

     1:  2.         2:  2.         1:  1.99506311678e3010
	 .          1:  10000.         .
                        .

       2.0 RET          1e4 RET        ^

Hey, the answer is different!  Look closely at the middle columns of
the two examples.  In the first, the stack contained the exact integer
`10000', but in the second it contained a floating-point value with a
decimal point.  When you raise a number to an integer power, Calc uses
repeated squaring and multiplication to get the answer.  When you use
a floating-point power, Calc uses logarithms and exponentials.  As you
can see, a slight error crept in during one of these methods.  Which
one should we trust?  Let's raise the precision a bit and find out:

	 .          1:  2.         2:  2.         1:  1.995063116880828e3010
                        .1:  10000.         .
				       .

      p 16 RET        2. RET           1e4            ^    p 12 RET

Presumably, it doesn't matter whether we do this higher-precision
calculation using an integer or floating-point power, since we have
added enough "guard digits" to trust the first 12 digits no matter
what.  And the verdict is...  Integer powers were more accurate; in
fact, the result was only off by one unit in the last place.

Calc does many of its internal calculations to a slightly higher
precision, but it doesn't always bump the precision up enough.  In
each case, Calc added about two digits of precision during its
calculation and then rounded back down to 12 digits afterward.  In one
case, it was enough; in the the other, it wasn't.  If you really need
X digits of precision, it never hurts to do the calculation with a few
extra guard digits.

What if we want guard digits but don't want to look at them?
We can set the "float format".  Calc supports four major
formats for floating-point numbers, called "normal",
"fixed-point", "scientific notation", and "engineering
notation".  You get them by pressing `d n', `d f',
`d s', and `d e', respectively.  In each case, you can
supply a numeric prefix argument which says how many digits
should be displayed.  As an example, let's put a few numbers
onto the stack and try some different display modes.  First,
use `M-0 DEL' to clear the stack, then enter the four
numbers shown here:

     4:  12345      4:  12345      4:  12345      4:  12345      4:  12345
     3:  12345.     3:  12300.     3:  1.2345e4   3:  1.23e4     3:  12345.000
     2:  123.45     2:  123.       2:  1.2345e2   2:  1.23e2     2:  123.450
     1:  12.345     1:  12.3       1:  1.2345e1   1:  1.23e1     1:  12.345
	 .              .              .              .              .

        dn          M-3 d n          d s          M-3 d s        M-3 d f

Notice that when we typed `M-3 d n', the numbers were rounded down to
three significant digits, but then when we typed `d s' all five
significant figures reappeared.  The float format does not affect how
numbers are stored, it only affects how they are displayed.  Only the
current precision governs the actual rounding of numbers in the
Calculator's memory.

Engineering notation, not shown here, is like scientific notation
except the exponent (the power-of-ten part) is always adjusted to be a
multiple of three (as in "kilo," "micro," etc.).  As a result there
will be one, two, or three digits before the decimal point.

Whenever you change a display-related mode, Calc redraws everything in
the stack.  This may be slow if there are many things on the stack, so
Calc allows you to type shift-`H' before any mode command to prevent
it from updating the stack.  Anything Calc displays after the
mode-changing command will appear in the new format.

     4:  12345      4:  12345      4:  12345      4:  12345      4:  12345
     3:  12345.000  3:  12345.000  3:  12345.000  3:  1.2345e4   3:  12345.
     2:  123.450    2:  123.450    2:  1.2345e1   2:  1.2345e1   2:  123.45
     1:  12.345     1:  1.2345e1   1:  1.2345e2   1:  1.2345e2   1:  12.345
	 .              .              .              .              .

	 H d s          DEL U          TAB            d SPC          d n

Here the `H d s' command changes to scientific notation but without
updating the screen.  Deleting the top stack entry and undoing it back
causes it to show up in the new format; swapping the top two stack
entries reformats both entries.  The `d SPC' command refreshes the
whole stack.  The `d n' command changes back to the normal float
format; since it doesn't have an `H' prefix, it also updates all the
stack entries to be in `d n' format.

Notice that the integer `12345' was not affected by any of the float
formats.  Integers are integers, and are always displayed exactly.

Large integers have their own problems.  Let's look back at the result
of `2^3^4'.

     2417851639229258349412352

Quick--how many digits does this have?  Try typing `d g':

     2,417,851,639,229,258,349,412,352

Now how many digits does this have?  It's much easier to tell!  We can
actually group digits into clumps of any size.  Some people prefer
`M-5 d g':

     24178,51639,22925,83494,12352

Let's see what happens to floating-point numbers when they are
grouped.  First, type `p 25 RET' to make sure we have enough precision
to get ourselves into trouble.  Now, type `1e13 /':

     24,17851,63922.9258349412352

The integer part is grouped but the fractional part isn't.  Now try
`M-- M-5 d g' (that's meta-minus-sign, meta-five):

     24,17851,63922.92583,49412,352

If you find it hard to tell the decimal point from the commas, try
changing the grouping character to a space with `d , SPC':

     24 17851 63922.92583 49412 352

Type `d , ,' to restore the normal grouping character, then `d g'
again to turn grouping off.  Also, press `p 12' to restore the default
precision.

Press `U' enough times to get the original big integer back.  (Notice
that `U' does not undo each mode-setting command; if you want to undo
a mode-setting command, you have to do it yourself.)  Now, type `d r
16 RET':

     16#200000000000000000000

The number is now displayed in "hexadecimal", or "base-16" form.
Suddenly it looks pretty simple; this should be no surprise, since we
got this number by computing a power of two, and 16 is a power of 2.
In fact, we can use `d r 2 RET' to see it in actual binary
form:

     2#1000000000000000000000000000000000000000000000000000000 ...

We don't have enough space here to show all the zeros!  They won't fit
on a typical screen, either, so you will have to use horizontal
scrolling to see them all.  Press `<' and `>' to scroll the stack
window left and right by half its width.  Another way to view
something large is to press ``' (back-quote) to edit the top of stack
in a separate window.  (Press `M-# M-#' when you are done.)

You can enter non-decimal numbers using the `#' symbol, too.  Let's
see what the hexadecimal number `5FE' looks like in binary.  Type
`16#5FE' (the letters can be typed in upper or lower case; they will
always appear in upper case).  It will also help to turn grouping on
with `d g':

     2#101,1111,1110

Notice that `d g' groups by fours by default if the display radix is
binary or hexadecimal, but by threes if it is decimal, octal, or any
other radix.

Now let's see that number in decimal; type `d r 10':

     1,534

Numbers are not *stored* with any particular radix attached.  They're
just numbers; they can be entered in any radix, and are always
displayed in whatever radix you've chosen with `d r'.  The current
radix applies to integers, fractions, and floats.

(*) *Exercise 1.*  Your friend Joe tried to enter one-third
as `3#0.1' in `d r 3' mode with a precision of 12.  He got
`3#0.0222222...' (with 25 2's) in the display.  When he multiplied
that by three, he got `3#0.222222...' instead of the expected
`3#1'.  Next, Joe entered `3#0.2' and, to his great relief,
saw `3#0.2' on the screen.  But when he typed `2 /', he got
`3#0.10000001' (some zeros omitted).  What's going on here?
*Note 1: Modes Answer 1. (*)

(*) *Exercise 2.* Scientific notation works in non-decimal modes in
the natural way (the exponent is a power of the radix instead of a
power of ten, although the exponent itself is always written in
decimal).  Thus `8#1.23e3 = 8#1230.0'.  Suppose we have the
hexadecimal number `f.e8f' times 16 to the 15th power: We write
`16#f.e8fe15'.  What is wrong with this picture?  What could we write
instead that would work better?  *Note 2: Modes Answer 2. (*)

The `m' prefix key has another set of modes, relating to the way Calc
interprets your inputs and does computations.  Whereas `d'-prefix
modes generally affect the way things look, `m'-prefix modes affect
the way they are actually computed.

The most popular `m'-prefix mode is the "angular mode".  Notice the
`Deg' indicator in the mode line.  This means that if you use a
command that interprets a number as an angle, it will assume the angle
is measured in degrees.  For example,

     1:  45         1:  0.707106781187   1:  0.500000000001    1:  0.5
	 .              .                    .                     .

	 45             S                    2 ^                   c 1

The shift-`S' command computes the sine of an angle.  The sine of 45
degrees is `sqrt(2)/2'; squaring this yields `2/4 = 0.5'.  However,
there has been a slight roundoff error because the representation of
`sqrt(2)/2' wasn't exact.  The `c 1' command is a handy way to clean
up numbers in this case; it temporarily reduces the precision by one
digit while it re-rounds the number on the top of the stack.

(*) *Exercise 3.* Your friend Joe computed the sine of 45 degrees as
shown above, then, hoping to avoid an inexact result, he increased the
precision to 16 digits before squaring.  What happened?  *Note 3:
Modes Answer 3. (*)

To do this calculation in radians, we would type `m r' first.
(The indicator changes to `Rad'.)  45 degrees corresponds to
`pi/4' radians.  To get `pi', press the `P' key.  (Once
again, this is a shifted capital `P'.  Remember, unshifted
`p' sets the precision.)

     1:  3.14159265359   1:  0.785398163398   1:  0.707106781187
	 .                   .                .

	 P                   4 /       m r    S

Likewise, inverse trigonometric functions generate results in either
radians or degrees, depending on the current angular mode.

     1:  0.707106781187   1:  0.785398163398   1:  45.
	 .                    .                    .

	 .5 Q        m r      I S        m d       U I S

Here we compute the Inverse Sine of `sqrt(0.5)', first in radians,
then in degrees.

Use `c d' and `c r' to convert a number from radians to degrees and
vice-versa.

     1:  45         1:  0.785398163397     1:  45.
	 .              .                      .

	 45             c r                    c d

Another interesting mode is "fraction mode".  Normally, dividing two
integers produces a floating-point result if the quotient can't be
expressed as an exact integer.  Fraction mode causes integer division
to produce a fraction, i.e., a rational number, instead.

     2:  12         1:  1.33333333333    1:  4:3
     1:  9              .                    .
	 .

      12 RET 9          /          m f       U /      m f

In the first case, we get an approximate floating-point result.  In
the second case, we get an exact fractional result (four-thirds).

You can enter a fraction at any time using `:' notation.  (Calc uses
`:' instead of `/' as the fraction separator because `/' is already
used to divide the top two stack elements.)  Calculations involving
fractions will always produce exact fractional results; fraction mode
only says what to do when dividing two integers.

(*) *Exercise 4.*  If fractional arithmetic is exact,
why would you ever use floating-point numbers instead?
*Note 4: Modes Answer 4. (*)

Typing `m f' doesn't change any existing values in the stack.  In the
above example, we had to Undo the division and do it over again when
we changed to fraction mode.  But if you use the evaluates-to operator
you can get commands like `m f' to recompute for you.

     1:  12 / 9 => 1.33333333333    1:  12 / 9 => 1.333    1:  12 / 9 => 4:3
	 .                              .                      .

        '12/9 => RET                   p 4 RET                m f

In this example, the righthand side of the `=>' operator on the stack
is recomputed when we change the precision, then again when we change
to fraction mode.  All `=>' expressions on the stack are recomputed
every time you change any mode that might affect their values.



File: calc.info, Node: Arithmetic Tutorial, Next: Vector/Matrix Tutorial, Prev: Basic Tutorial, Up: Tutorial

Arithmetic Tutorial
===================

In this section, we explore the arithmetic and scientific functions
available in the Calculator.

The standard arithmetic commands are `+', `-', `*', `/', and `^'.
Each normally takes two numbers from the top of the stack and pushes
back a result.  The `n' and `&' keys perform change-sign and
reciprocal operations, respectively.

     1:  5          1:  0.2        1:  5.         1:  -5.        1:  5.
	 .              .              .              .              .

	 5              &              &              n              n

You can apply a "binary operator" like `+' across any number of stack
entries by giving it a numeric prefix.  You can also apply it pairwise
to several stack elements along with the top one if you use a negative
prefix.

     3:  2          1:  9          3:  2          4:  2          3:  12
     2:  3              .          2:  3          3:  3          2:  13
     1:  4                         1:  4          2:  4          1:  14
	 .                             .          1:  10             .
						      .

     2 RET 3 RET 4     M-3 +           U              10          M-- M-3 +

You can apply a "unary operator" like `&' to the top N stack entries
with a numeric prefix, too.

     3:  2          3:  0.5                3:  0.5
     2:  3          2:  0.333333333333     2:  3.
     1:  4          1:  0.25               1:  4.
	 .              .                      .

     2 RET 3 RET 4      M-3 &                  M-2 &

Notice that the results here are left in floating-point form.  We can
convert them back to integers by pressing `F', the "floor" function.
This function rounds down to the next lower integer.  There is also
`R', which rounds to the nearest integer.

     7:  2.         7:  2          7:  2
     6:  2.4        6:  2          6:  2
     5:  2.5        5:  2          5:  3
     4:  2.6        4:  2          4:  3
     3:  -2.        3:  -2         3:  -2
     2:  -2.4       2:  -3         2:  -2
     1:  -2.6       1:  -3         1:  -3
	 .              .              .

		       M-7 F        U M-7 R

Since dividing-and-flooring (i.e., "integer quotient") is such a
common operation, Calc provides a special command for that purpose,
the backslash `\'.  Another common arithmetic operator is `%', which
computes the remainder that would arise from a `\' operation, i.e.,
the "modulo" of two numbers.  For example,

     2:  1234       1:  12         2:  1234       1:  34
     1:  100            .          1:  100            .
	 .                             .

     1234 RET 100       \              U              %

These commands actually work for any real numbers, not just integers.

     2:  3.1415     1:  3          2:  3.1415     1:  0.1415
     1:  1              .          1:  1              .
	 .                             .

     3.1415 RET 1       \              U              %

(*) *Exercise 1.* The `\' command would appear to be a frill, since
you could always do the same thing with `/ F'.  Think of a situation
where this is not true---`/ F' would be inadequate.  Now think of a
way you could get around the problem if Calc didn't provide a `\'
command.  *Note 1: Arithmetic Answer 1. (*)

We've already seen the `Q' (square root) and `S' (sine)
commands.  Other commands along those lines are `C' (cosine),
`T' (tangent), `E' (`e^x') and `L' (natural
logarithm).  These can be modified by the `I' (inverse) and
`H' (hyperbolic) prefix keys.

Let's compute the sine and cosine of an angle, and verify the
identity `sin(x)^2 + cos(x)^2 = 1'.  We'll
arbitrarily pick -64 degrees as a good value for `x'.  With
the angular mode set to degrees (type `m d'), do:

     2:  -64        2:  -64        2:  -0.89879   2:  -0.89879   1:  1.
     1:  -64        1:  -0.89879   1:  -64        1:  0.43837        .
	 .              .              .              .

      64 n RET RET      S              TAB            C              f h

(For brevity, we're showing only five digits of the results here.  You
can of course do these calculations to any precision you like.)

Remember, `f h' is the `calc-hypot', or square-root of sum of squares,
command.

Another identity is `tan(x) = sin(x) / cos(x)'.

     2:  -0.89879   1:  -2.0503    1:  -64.
     1:  0.43837        .              .
	 .

	 U              /              I T

A physical interpretation of this calculation is that if you move
`0.89879' units downward and `0.43837' units to the right, your
direction of motion is -64 degrees from horizontal.  Suppose we move
in the opposite direction, up and to the left:

     2:  -0.89879   2:  0.89879    1:  -2.0503    1:  -64.
     1:  0.43837    1:  -0.43837       .              .
	 .              .

	 U U            M-2 n          /              I T

How can the angle be the same?  The answer is that the `/' operation
loses information about the signs of its inputs.  Because the quotient
is negative, we know exactly one of the inputs was negative, but we
can't tell which one.  There is an `f T' [`arctan2'] function which
computes the inverse tangent of the quotient of a pair of numbers.
Since you feed it the two original numbers, it has enough information
to give you a full 360-degree answer.

     2:  0.89879    1:  116.       3:  116.       2:  116.       1:  180.
     1:  -0.43837       .          2:  -0.89879   1:  -64.           .
	 .                         1:  0.43837        .
				       .

	 U U            f T         M-RET M-2 n       f T            -

The resulting angles differ by 180 degrees; in other words, they point
in opposite directions, just as we would expect.

The META-RET we used in the third step is the
"last-arguments" command.  It is sort of like Undo, except that it
restores the arguments of the last command to the stack without removing
the command's result.  It is useful in situations like this one,
where we need to do several operations on the same inputs.  We could
have accomplished the same thing by using `M-2 RET' to duplicate
the top two stack elements right after the `U U', then a pair of
`M-TAB' commands to cycle the 116 up around the duplicates.

A similar identity is supposed to hold for hyperbolic sines and
cosines, except that it is the *difference* `cosh(x)^2 - sinh(x)^2'
that always equals one.  Let's try to verify this identity.

     2:  -64        2:  -64        2:  -64        2:  9.7192e54  2:  9.7192e54
     1:  -64        1:  -3.1175e27 1:  9.7192e54  1:  -64        1:  9.7192e54
	 .              .              .              .              .

      64 n RET RET      H C            2 ^            TAB            H S 2 ^

Something's obviously wrong, because when we subtract these numbers
the answer will clearly be zero!  But if you think about it, if these
numbers *did* differ by one, it would be in the 55th decimal place.
The difference we seek has been lost entirely to roundoff error.

We could verify this hypothesis by doing the actual calculation with,
say, 60 decimal places of precision.  This will be slow, but not
enormously so.  Try it if you wish; sure enough, the answer is
0.99999, reasonably close to 1.

Of course, a more reasonable way to verify the identity is to use a
more reasonable value for `x'!

Some Calculator commands use the Hyperbolic prefix for other purposes.
The logarithm and exponential functions, for example, work to the base
`e' normally but use base-10 instead if you use the Hyperbolic prefix.

     1:  1000       1:  6.9077     1:  1000       1:  3
	 .              .              .              .

	 1000           L              U              H L

First, we mistakenly compute a natural logarithm.  Then we undo and
compute a common logarithm instead.

The `B' key computes a general base-B logarithm for any value of B.

     2:  1000       1:  3          1:  1000.      2:  1000.      1:  6.9077
     1:  10             .              .          1:  2.71828        .
	 .                                            .

      1000 RET 10       B              H E            H P            B

Here we first use `B' to compute the base-10 logarithm, then use the
hyperbolic" exponential as a cheap hack to recover the number 1000,
then use `B' again to compute the natural logarithm.  Note that `P'
with the hyperbolic prefix pushes the constant `e' onto the stack.

You may have noticed that both times we took the base-10 logarithm of
1000, we got an exact integer result.  Calc always tries to give an
exact rational result for calculations involving rational numbers
where possible.  But when we used `H E', the result was a
floating-point number for no apparent reason.  In fact, if we had
computed `10 RET 3 ^' we *would* have gotten an exact integer 1000.
But the `H E' command is rigged to generate a floating-point result
all of the time so that `1000 H E' will not waste time computing a
thousand-digit integer when all you probably wanted was `1e1000'.

(*) *Exercise 2.* Find a pair of integer inputs to the `B' command for
which Calc could find an exact rational result but doesn't.  *Note 2:
Arithmetic Answer 2. (*)

The Calculator also has a set of functions relating to combinatorics
and statistics.  You may be familiar with the "factorial" function,
which computes the product of all the integers up to a given number.

     1:  100        1:  93326215443...    1:  100.       1:  9.3326e157
	 .              .                     .              .

	 100            !                     U c f          !

Recall, the `c f' command converts the integer or fraction at the top
of the stack to floating-point format.  If you take the factorial of a
floating-point number, you get a floating-point result accurate to the
current precision.  But if you give `!' an exact integer, you get an
exact integer result (158 digits long in this case).

If you take the factorial of a non-integer, Calc uses a generalized
factorial function defined in terms of Euler's Gamma function
`gamma(n)' (which is itself available as the `f g' command).

     3:  4.         3:  24.               1:  5.5        1:  52.342777847
     2:  4.5        2:  52.3427777847         .              .
     1:  5.         1:  120.
	 .              .

                        M-3 !              M-0 DEL 5.5       f g

Here we verify the identity `N! = gamma(N+1)'.

The binomial coefficient N-choose-M is defined by `n! / m! (n-m)!' for
all reals `n' and `m'.  The intermediate results in this formula can
become quite large even if the final result is small; the `k c'
command computes a binomial coefficient in a way that avoids large
intermediate values.

The `k' prefix key defines several common functions out of
combinatorics and number theory.  Here we compute the binomial
coefficient 30-choose-20, then determine its prime factorization.

     2:  30         1:  30045015   1:  [3, 3, 5, 7, 11, 13, 23, 29]
     1:  20             .              .
	 .

      30 RET 20         k c            k f

You can verify these prime factors by using `v u' to "unpack" this
vector into 8 separate stack entries, then `M-8 *' to multiply them
back together.  The result is the original number, 30045015.

Suppose a program you are writing needs a hash table with at least
10000 entries.  It's best to use a prime number as the actual size of
a hash table.  Calc can compute the next prime number after 10000:

     1:  10000      1:  10007      1:  9973
	 .              .              .

	 10000          k n            I k n

Just for kicks we've also computed the next prime *less* than 10000.

*Note Financial Functions::, for a description of the Calculator
commands that deal with business and financial calculations (functions
like `pv', `rate', and `sln').

*Note Binary Functions::, to read about the commands for operating on
binary numbers (like `and', `xor', and `lsh').



