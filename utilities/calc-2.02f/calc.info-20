Info file: calc.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `calc.texinfo'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the author
instead of in the original English.




File: calc.info, Node: Yanking Into Stack, Next: Grabbing From Buffers, Prev: Killing From Stack, Up: Kill and Yank

Yanking into the Stack
======================

The `C-y' command yanks the most recently killed text back into the
Calculator.  It pushes this value onto the top of the stack regardless
of the cursor position.  In general it re-parses the killed text as a
number or formula (or a list of these separated by commas or
newlines).  However if the thing being yanked is something that was
just killed from the Calculator itself, its full internal structure is
yanked.  For example, if you have set the floating-point display mode
to show only four significant digits, then killing and re-yanking
3.14159 (which displays as 3.142) will yank the full 3.14159, even
though yanking it into any other buffer would yank the number in its
displayed form, 3.142.  (Since the default display modes show all
objects to their full precision, this feature normally makes no
difference.)



File: calc.info, Node: Grabbing From Buffers, Next: Yanking Into Buffers, Prev: Yanking Into Stack, Up: Kill and Yank

Grabbing from Other Buffers
===========================

The `M-# g' (`calc-grab-region') command takes the text between
point and mark in the current buffer and attempts to parse it as a
vector of values.  Basically, it wraps the text in vector brackets
`[ ]' unless the text already is enclosed in vector brackets,
then reads the text as if it were an algebraic entry.  The contents
of the vector may be numbers, formulas, or any other Calc objects.
If the `M-# g' command works successfully, it does an automatic
`M-# c' to enter the Calculator buffer.

A numeric prefix argument grabs the specified number of lines around
point, ignoring the mark.  A positive prefix grabs from point to the
`n'th following newline (so that `M-1 M-# g' grabs from point to the
end of the current line); a negative prefix grabs from point back to
the `n+1'st preceding newline.  In these cases the text that is
grabbed is exactly the same as the text that `C-k' would delete given
that prefix argument.

A prefix of zero grabs the current line; point may be anywhere on the
line.

A plain `C-u' prefix interprets the region between point and mark
as a single number or formula rather than a vector.  For example,
`M-# g' on the text `2 a b' produces the vector of three
values `[2, a, b]', but `C-u M-# g' on the same region
reads a formula which is a product of three things:  `2 a b'.
(The text `a + b', on the other hand, will be grabbed as a
vector of one element by plain `M-# g' because the interpretation
`[a, +, b]' would be a syntax error.)

If a different language has been specified (*Note Language Modes::),
the grabbed text will be interpreted according to that language.

The `M-# r' (`calc-grab-rectangle') command takes the text between
point and mark and attempts to parse it as a matrix.  If point and
mark are both in the leftmost column, the lines in between are parsed
in their entirety.  Otherwise, point and mark define the corners of a
rectangle whose contents are parsed.

Each line of the grabbed area becomes a row of the matrix.  The result
will actually be a vector of vectors, which Calc will treat as a
matrix only if every row contains the same number of values.

If a line contains a portion surrounded by square brackets (or curly
braces), that portion is interpreted as a vector which becomes a row
of the matrix.  Any text surrounding the bracketed portion on the line
is ignored.

Otherwise, the entire line is interpreted as a row vector as if it
were surrounded by square brackets.  Leading line numbers (in the
format used in the Calc stack buffer) are ignored.  If you wish to
force this interpretation (even if the line contains bracketed
portions), give a negative numeric prefix argument to the
`M-# r' command.

If you give a numeric prefix argument of zero or plain `C-u', each
line is instead interpreted as a single formula which is converted into
a one-element vector.  Thus the result of `C-u M-# r' will be a
one-column matrix.  For example, suppose one line of the data is the
expression `2 a'.  A plain `M-# r' will interpret this as
`[2 a]', which in turn is read as a two-element vector that forms
one row of the matrix.  But a `C-u M-# r' will interpret this row
as `[2*a]'.

If you give a positive numeric prefix argument N, then each line will
be split up into columns of width N; each column is parsed separately
as a matrix element.  If a line contained `2 +/- 3 4 +/- 5', then
grabbing with a prefix argument of 8 would correctly split the line
into two error forms.

*Note Matrix Functions::, to see how to pull the matrix apart into its
constituent rows and columns.  (If it is a 1x1 matrix, just hit `v u'
(`calc-unpack') twice.)

The `M-# :' (`calc-grab-sum-down') command is a handy way to
grab a rectangle of data and sum its columns.  It is equivalent to
typing `M-# r', followed by `V R : +' (the vector reduction
command that sums the columns of a matrix; *Note Reducing::).  The
result of the command will be a vector of numbers, one for each column
in the input data.  The `M-# _' (`calc-grab-sum-across') command
similarly grabs a rectangle and sums its rows by executing `V R _ +'.

As well as being more convenient, `M-# :' and `M-# _' are also much
faster because they don't actually place the grabbed vector on the
stack.  In a `M-# r V R : +' sequence, formatting the vector for
display on the stack takes a large fraction of the total time (unless
you have planned ahead and used `v .' and `t .' modes).

For example, suppose we have a column of numbers in a file which we
wish to sum.  Go to one corner of the column and press `C-@' to set
the mark; go to the other corner and type `M-# :'.  Since there is
only one column, the result will be a vector of one number, the sum.
(You can type `v u' to unpack this vector into a plain number if you
want to do further arithmetic with it.)

To compute the product of the column of numbers, we would have to do
it "by hand" since there's no special grab-and-multiply command.  Use
`M-# r' to grab the column of numbers into the calculator in the form
of a column matrix.  The statistics command `u *' is a handy way to
find the product of a vector or matrix of numbers.  *Note Statistical
Operations::.  Another approach would be to use an explicit column
reduction command, `V R : *'.



File: calc.info, Node: Yanking Into Buffers, Next: X Cut and Paste, Prev: Grabbing From Buffers, Up: Kill and Yank

Yanking into Other Buffers
==========================

The plain `y' (`calc-copy-to-buffer') command inserts the number at
the top of the stack into the most recently used normal editing
buffer.  (More specifically, this is the most recently used buffer
which is displayed in a window and whose name does not begin with `*'.
If there is no such buffer, this is the most recently used buffer
except for Calculator and Calc Trail buffers.)  The number is inserted
exactly as it appears and without a newline.  (If line-numbering is
enabled, the line number is normally not included.)  The number is
*not* removed from the stack.

With a prefix argument, `y' inserts several numbers, one per line.  A
positive argument inserts the specified number of values from the top
of the stack.  A negative argument inserts the `n'th value from the
top of the stack.  An argument of zero inserts the entire stack.  Note
that `y' with an argument of 1 is slightly different from `y' with no
argument; the former always copies full lines, whereas the latter
strips off the trailing newline.

With a lone `C-u' as a prefix argument, `y' *replaces* the region in
the other buffer with the yanked text, then quits the Calculator,
leaving you in that buffer.  A typical use would be to use `M-# g' to
read a region of data into the Calculator, operate on the data to
produce a new matrix, then type `C-u y' to replace the original data
with the new data.  One might wish to alter the matrix display style
(*Note Vector and Matrix Formats::) or change the current display
language (*Note Language Modes::) before doing this.  Also, note that
this command replaces a linear region of text (as grabbed by `M-# g'),
not a rectangle (as grabbed by `M-# r').

If the editing buffer is in overwrite (as opposed to insert) mode, and
the `C-u' prefix was not used, then the yanked number will overwrite
the characters following point rather than being inserted before those
characters.  The usual conventions of overwrite mode are observed; for
example, characters will be inserted at the end of a line rather than
overflowing onto the next line.  Yanking a multi-line object such as a
matrix in overwrite mode overwrites the next N lines in the buffer,
lengthening or shortening each line as necessary.  Finally, if the
thing being yanked is a simple integer or floating-point number (like
`-1.2345e-3') and the characters following point also make up such a
number, then Calc will replace that number with the new number,
lengthening or shortening as necessary.  The concept of "overwrite
mode" has thus been generalized from overwriting characters to
overwriting one complete number with another.

The `M-# y' key sequence is equivalent to `y' except that it can be
typed anywhere, not just in Calc.  This provides an easy way to
guarantee that Calc knows which editing buffer you want to use!



File: calc.info, Node: X Cut and Paste, Prev: Yanking Into Buffers, Up: Kill and Yank

X Cut and Paste
===============

If you are using Emacs with the X window system, there is an easier
way to move small amounts of data into and out of the calculator: Use
the mouse-oriented cut and paste facilities of X.

The default bindings for a three-button mouse cause the left button to
move the Emacs cursor to the given place, the right button to select
the text between the cursor and the clicked location, and the middle
button to yank the selection into the buffer at the clicked location.
So, if you have a Calc window and an editing window on your Emacs
screen, you can use left-click/right-click to select a number, vector,
or formula from one window, then middle-click to paste that value into
the other window.  When you paste text into the Calc window, Calc
interprets it as an algebraic entry.  It doesn't matter where you
click in the Calc window; the new value is always pushed onto the top
of the stack.

The `xterm' program that is typically used for general-purpose shell
windows in X interprets the mouse buttons in the same way.  So you can
use the mouse to move data between Calc and any other Unix program.
One nice feature of `xterm' is that a double left-click selects one
word, and a triple left-click selects a whole line.  So you can
usually transfer a single number into Calc just by double-clicking on
it in the shell, then middle-clicking in the Calc window.



File: calc.info, Node: Keypad Mode, Next: Embedded Mode, Prev: Kill and Yank, Up: Introduction

"Keypad" Mode
*************

The `M-# k' (`calc-keypad') command starts the Calculator and displays
a picture of a calculator-style keypad.  If you are using the X window
system, you can click on any of the "keys" in the keypad using the
left mouse button to operate the calculator.  The original window
remains the selected window; in keypad mode you can type in your file
while simultaneously performing calculations with the mouse.

If you have used `M-# b' first, `M-# k' instead invokes the
`full-calc-keypad' command, which takes over the whole Emacs screen
and displays the keypad, the Calc stack, and the Calc trail all at
once.  This mode would normally be used when running Calc standalone
(*Note Standalone Operation::).

If you aren't using the X window system, you must switch into the
`*Calc Keypad*' window, place the cursor on the desired "key," and
type SPC or RET.  If you think this is easier than using Calc
normally, go right ahead.

Calc commands are more or less the same in keypad mode.  Certain
keypad keys differ slightly from the corresponding normal Calc
keystrokes; all such deviations are described below.

Keypad Mode includes many more commands than will fit on the keypad at
once.  Click the right mouse button [`calc-keypad-menu'] to switch to
the next menu.  The bottom five rows of the keypad stay the same; the
top three rows change to a new set of commands.  To return to earlier
menus, click the middle mouse button [`calc-keypad-menu-back'] or
simply advance through the menus until you wrap around.  Typing TAB
inside the keypad window is equivalent to clicking the right mouse
button there.

You can always click the EXEC button and type any normal Calc key
sequence.  This is equivalent to switching into the Calc buffer,
typing the keys, then switching back to your original buffer.

* Menu:

* Keypad Main Menu::
* Keypad Functions Menu::
* Keypad Binary Menu::
* Keypad Vectors Menu::
* Keypad Modes Menu::



File: calc.info, Node: Keypad Main Menu, Next: Keypad Functions Menu, Prev: Keypad Mode, Up: Keypad Mode

Main Menu
=========

     |----+-----Calc 2.00-----+----1
     |FLR |CEIL|RND |TRNC|CLN2|FLT |
     |----+----+----+----+----+----|
     | LN |EXP |    |ABS |IDIV|MOD |
     |----+----+----+----+----+----|
     |SIN |COS |TAN |SQRT|y^x |1/x |
     |----+----+----+----+----+----|
     |  ENTER  |+/- |EEX |UNDO| <- |
     |-----+---+-+--+--+-+---++----|
     | INV |  7  |  8  |  9  |  /  |
     |-----+-----+-----+-----+-----|
     | HYP |  4  |  5  |  6  |  *  |
     |-----+-----+-----+-----+-----|
     |EXEC |  1  |  2  |  3  |  -  |
     |-----+-----+-----+-----+-----|
     | OFF |  0  |  .  | PI  |  +  |
     |-----+-----+-----+-----+-----+

This is the menu that appears the first time you start Keypad Mode.
It will show up in a vertical window on the right side of your screen.
Above this menu is the traditional Calc stack display.  On a 24-line
screen you will be able to see the top three stack entries.

The ten digit keys, decimal point, and EEX key are used for entering
numbers in the obvious way.  EEX begins entry of an exponent in
scientific notation.  Just as with regular Calc, the number is pushed
onto the stack as soon as you press ENTER or any other function key.

The +/- key corresponds to normal Calc's `n' key.  During numeric
entry it changes the sign of the number or of the exponent.  At other
times it changes the sign of the number on the top of the stack.

The INV and HYP keys modify other keys.  As well as having the effects
described elsewhere in this manual, Keypad Mode defines several other
inverse" operations.  These are described below and in the following
sections.

The ENTER key finishes the current numeric entry, or otherwise
duplicates the top entry on the stack.

The UNDO key undoes the most recent Calc operation.  `INV UNDO' is the
redo" command, and `HYP UNDO' is "last arguments" (`M-RET').

The <- key acts as a "backspace" during numeric entry.  At other times
it removes the top stack entry.  `INV <-' clears the entire stack.
`HYP <-' takes an integer from the stack, then removes that many
additional stack elements.

The EXEC key prompts you to enter any keystroke sequence that would
normally work in Calc mode.  This can include a numeric prefix if you
wish.  It is also possible simply to switch into the Calc window and
type commands in it; there is nothing "magic" about this window when
Keypad Mode is active.

The other keys in this display perform their obvious calculator
functions.  CLN2 rounds the top-of-stack by temporarily reducing the
precision by 2 digits.  FLT converts an integer or fraction on the top
of the stack to floating-point.

The INV and HYP keys combined with several of these keys give you
access to some common functions even if the appropriate menu is not
displayed.  Obviously you don't need to learn these keys unless you
find yourself wasting time switching among the menus.

`INV +/-'
     is the same as 1/x.
`INV +'
     is the same as SQRT.
`INV -'
     is the same as CONJ.
`INV *'
     is the same as y^x.
`INV /'
     is the same as INV y^x (the `x'th root of `y').
`HYP/INV 1'
     are the same as SIN / `INV SIN'.
`HYP/INV 2'
     are the same as COS / `INV COS'.
`HYP/INV 3'
     are the same as TAN / `INV TAN'.
`INV/HYP 4'
     are the same as LN / `HYP LN'.
`INV/HYP 5'
     are the same as EXP / `HYP EXP'.
`INV 6'
     is the same as ABS.
`INV 7'
     is the same as RND (`calc-round').
`INV 8'
     is the same as CLN2.
`INV 9'
     is the same as FLT (`calc-float').
`INV 0'
     is the same as IMAG.
`INV .'
     is the same as PREC.
`INV ENTER'
     is the same as SWAP.
`HYP ENTER'
     is the same as RLL3.
`INV HYP ENTER'
     is the same as OVER.
`HYP +/-'
     packs the top two stack entries as an error form.
`HYP EEX'
     packs the top two stack entries as a modulo form.
`INV EEX'
     creates an interval form; this removes an integer which is one of
     0 `[]', 1 `[)', 2 `(]' or 3 `()', followed by the two limits of
     the interval.

The `OFF' key turns Calc off; typing `M-# k' or `M-# M-#'
again has the same effect.  This is analogous to typing `q' or
hitting `M-# c' again in the normal calculator.  If Calc is
running standalone (the `full-calc-keypad' command appeared in the
command line that started Emacs), then `OFF' is replaced with
`EXIT'; clicking on this actually exits Emacs itself.



File: calc.info, Node: Keypad Functions Menu, Next: Keypad Binary Menu, Prev: Keypad Main Menu, Up: Keypad Mode

Functions Menu
==============

     |----+----+----+----+----+----2
     |IGAM|BETA|IBET|ERF |BESJ|BESY|
     |----+----+----+----+----+----|
     |IMAG|CONJ| RE |ATN2|RAND|RAGN|
     |----+----+----+----+----+----|
     |GCD |FACT|DFCT|BNOM|PERM|NXTP|
     |----+----+----+----+----+----|

This menu provides various operations from the `f' and `k' prefix
keys.

IMAG multiplies the number on the stack by the imaginary number `i =
(0, 1)'.

RE extracts the real part a complex number.  `INV RE' extracts the
imaginary part.

RAND takes a number from the top of the stack and computes a random
number greater than or equal to zero but less than that number.
(*Note Random Numbers::.)  RAGN is the "random again" command; it
computes another random number using the same limit as last time.

INV GCD computes the LCM (least common multiple) function.

INV FACT is the gamma function.  `gamma(x) = (x-1)!'.

PERM is the number-of-permutations function, which is on the
`H k c' key in normal Calc.

NXTP finds the next prime after a number.  `INV NXTP' finds the
previous prime.



File: calc.info, Node: Keypad Binary Menu, Next: Keypad Vectors Menu, Prev: Keypad Functions Menu, Up: Keypad Mode

Binary Menu
===========

     |----+----+----+----+----+----3
     |AND | OR |XOR |NOT |LSH |RSH |
     |----+----+----+----+----+----|
     |DEC |HEX |OCT |BIN |WSIZ|ARSH|
     |----+----+----+----+----+----|
     | A  | B  | C  | D  | E  | F  |
     |----+----+----+----+----+----|

The keys in this menu perform operations on binary integers.
Note that both logical and arithmetic right-shifts are provided.
INV LSH rotates one bit to the left.

The "difference" function (normally on `b d') is on INV AND.
The "clip" function (normally on `b c') is on INV NOT.

The DEC, HEX, OCT, and BIN keys select the current radix for display
and entry of numbers: Decimal, hexadecimal, octal, or binary.  The six
letter keys A through F are used for entering hexadecimal numbers.

The WSIZ key displays the current word size for binary operations and
allows you to enter a new word size.  You can respond to the prompt
using either the keyboard or the digits and ENTER from the keypad.
The initial word size is 32 bits.



File: calc.info, Node: Keypad Vectors Menu, Next: Keypad Modes Menu, Prev: Keypad Binary Menu, Up: Keypad Mode

Vectors Menu
============

     |----+----+----+----+----+----4
     |SUM |PROD|MAX |MAP*|MAP^|MAP$|
     |----+----+----+----+----+----|
     |MINV|MDET|MTRN|IDNT|CRSS|"x" |
     |----+----+----+----+----+----|
     |PACK|UNPK|INDX|BLD |LEN |... |
     |----+----+----+----+----+----|

The keys in this menu operate on vectors and matrices.

PACK removes an integer N from the top of the stack; the next N stack
elements are removed and packed into a vector, which is replaced onto
the stack.  Thus the sequence `1 ENTER 3 ENTER 5 ENTER 3 PACK' enters
the vector `[1, 3, 5]' onto the stack.  To enter a matrix, build each
row on the stack as a vector, then use a final PACK to collect the
rows into a matrix.

UNPK unpacks the vector on the stack, pushing each of its components
separately.

INDX removes an integer N, then builds a vector of integers from 1 to
N.  `INV INDX' takes three numbers from the stack: The vector size N,
the starting number, and the increment.  `BLD' takes an integer N and
any value X and builds a vector of N copies of X.

IDNT removes an integer N, then builds an N-by-N identity matrix.

LEN replaces a vector by its length, an integer.

... turns on or off "abbreviated" display mode for large vectors.

MINV, MDET, MTRN, and CROSS are the matrix inverse, determinant, and
transpose, and vector cross product.

SUM replaces a vector by the sum of its elements.  It is
equivalent to `u +' in normal Calc (*Note Statistical Operations::).
PROD computes the product of the elements of a vector, and
MAX computes the maximum of all the elements of a vector.

INV SUM computes the alternating sum of the first element
minus the second, plus the third, minus the fourth, and so on.
INV MAX computes the minimum of the vector elements.

HYP SUM computes the mean of the vector elements.
HYP PROD computes the sample standard deviation.
HYP MAX computes the median.

MAP* multiplies two vectors elementwise.  It is equivalent to the `V M
*' command.  MAP^ computes powers elementwise.  The arguments must be
vectors of equal length, or one must be a vector and the other must be
a plain number.  For example, `2 MAP^' squares all the elements of a
vector.

MAP$ maps the formula on the top of the stack across the vector in the
second-to-top position.  If the formula contains several variables,
Calc takes that many vectors starting at the second-to-top position
and matches them to the variables in alphabetical order.  The result
is a vector of the same size as the input vectors, whose elements are
the formula evaluated with the variables set to the various sets of
numbers in those vectors.  For example, you could simulate MAP^ using
MAP$ with the formula `x^y'.

The `"x"' key pushes the variable name `x' onto the
stack.  To build the formula `x^2 + 6', you would use the
key sequence `"x" 2 y^x 6 +'.  This formula would then be
suitable for use with the MAP$ key described above.
With INV, HYP, or INV and HYP, the
`"x"' key pushes the variable names `y', `z', and
`t', respectively.



File: calc.info, Node: Keypad Modes Menu, Prev: Keypad Vectors Menu, Up: Keypad Mode

Modes Menu
==========

     |----+----+----+----+----+----5
     |FLT |FIX |SCI |ENG |GRP |    |
     |----+----+----+----+----+----|
     |RAD |DEG |FRAC|POLR|SYMB|PREC|
     |----+----+----+----+----+----|
     |SWAP|RLL3|RLL4|OVER|STO |RCL |
     |----+----+----+----+----+----|

The keys in this menu manipulate modes, variables, and the stack.

The FLT, FIX, SCI, and ENG keys select floating-point, fixed-point,
scientific, or engineering notation.  FIX displays two digits after
the decimal by default; the others display full precision.  With the
INV prefix, these keys pop a number-of-digits argument from the stack.

The GRP key turns grouping of digits with commas on or off.  `INV GRP'
enables grouping to the right of the decimal point as well as to the
left.

The RAD and DEG keys switch between radians and degrees for
trigonometric functions.

The FRAC key turns Fraction mode on or off.  This affects whether
commands like `/' with integer arguments produce fractional or
floating-point results.

The POLR key turns Polar mode on or off, determining whether polar or
rectangular complex numbers are used by default.

The SYMB key turns Symbolic mode on or off, in which operations that
would produce inexact floating-point results are left unevaluated as
algebraic formulas.

The PREC key selects the current precision.  Answer with the keyboard
or with the keypad digit and ENTER keys.

The SWAP key exchanges the top two stack elements.  The RLL3 key
rotates the top three stack elements upwards.  The RLL4 key rotates
the top four stack elements upwards.  The OVER key duplicates the
second-to-top stack element.

The STO and RCL keys are analogous to `s t' and `s r' in regular Calc.
*Note Store and Recall::.  Click the STO or RCL key, then one of the
ten digits.  (Named variables are not available in Keypad Mode.)  You
can also use, for example, `STO + 3' to add to register 3.



File: calc.info, Node: Embedded Mode, Next: Programming, Prev: Keypad Mode, Up: Top

Embedded Mode
*************

Embedded Mode in Calc provides an alternative to copying numbers and
formulas back and forth between editing buffers and the Calc stack.
In Embedded Mode, your editing buffer becomes temporarily linked to
the stack and this copying is taken care of automatically.

* Menu:

* Basic Embedded Mode::
* More About Embedded Mode::
* Assignments in Embedded Mode::
* Mode Settings in Embedded Mode::
* Customizing Embedded Mode::



File: calc.info, Node: Basic Embedded Mode, Next: More About Embedded Mode, Prev: Embedded Mode, Up: Embedded Mode

Basic Embedded Mode
===================

To enter Embedded mode, position the Emacs point (cursor) on a formula
in any buffer and press `M-# e' (`calc-embedded').  Note that `M-# e'
is not to be used in the Calc stack buffer like most Calc commands,
but rather in regular editing buffers that are visiting your own
files.

Calc normally scans backward and forward in the buffer for the nearest
opening and closing "formula delimiters".  The simplest delimiters are
blank lines.  Other delimiters that Embedded Mode understands are:

  1. The TeX and LaTeX math delimiters `$ $', `$$ $$',
     `\[ \]', and `\( \)';
  2. Lines beginning with `\begin' and `\end';
  3. Lines beginning with `@' (Texinfo delimiters).
  4. Lines beginning with `.EQ' and `.EN' ("eqn" delimiters);
  5. Lines containing a single `%' or `.\"' symbol and nothing else.

*Note Customizing Embedded Mode::, to see how to make Calc recognize
your own favorite delimiters.  Delimiters like `$ $' can appear on
their own separate lines or in-line with the formula.

If you give a positive or negative numeric prefix argument, Calc
instead uses the current point as one end of the formula, and moves
forward or backward (respectively) by that many lines to find the
other end.  Explicit delimiters are not necessary in this case.

With a prefix argument of zero, Calc uses the current region
(delimited by point and mark) instead of formula delimiters.

With a prefix argument of `C-u' only, Calc scans for the first
non-numeric character (i.e., the first character that is not a digit,
sign, decimal point, or upper- or lower-case `e') forward and backward
to delimit the formula.  `M-# w' (`calc-embedded-word') is equivalent
to `C-u M-# e'.

When you enable Embedded mode for a formula, Calc reads the text
between the delimiters and tries to interpret it as a Calc formula.
It's best if the current Calc language mode is correct for the
formula, but Calc can generally identify TeX formulas and Big-style
formulas even if the language mode is wrong.  If Calc can't make sense
of the formula, it beeps and refuses to enter Embedded mode.  But if
the current language is wrong, Calc can sometimes parse the formula
successfully (but incorrectly); for example, the C expression
`atan(a[1])' can be parsed in Normal language mode, but the `atan'
won't correspond to the built-in `arctan' function, and the `a[1]'
will be interpreted as `a' times the vector `[1]'!

If you press `M-# e' or `M-# w' to activate an embedded formula which
is blank, say with the cursor on the space between the two delimiters
`$ $', Calc will immediately prompt for an algebraic entry.

Only one formula in one buffer can be enabled at a time.  If you move
to another area of the current buffer and give Calc commands, Calc
turns Embedded mode off for the old formula and then tries to restart
Embedded mode at the new position.  Other buffers are not affected by
Embedded mode.

When Embedded mode begins, Calc pushes the current formula onto the
stack.  No Calc stack window is created; however, Calc copies the
top-of-stack position into the original buffer at all times.  You can
create a Calc window by hand with `M-# o' if you find you need to see
the entire stack.

For example, typing `M-# e' while somewhere in the formula `n>2' in
the following line enables Embedded mode on that inequality:

     We define $F_n = F_(n-1)+F_(n-2)$ for all $n>2$.

The formula `n>2' will be pushed onto the Calc stack, and the top of
stack will be copied back into the editing buffer.  This means that
spaces will appear around the `>' symbol to match Calc's usual display
style:

     We define $F_n = F_(n-1)+F_(n-2)$ for all $n > 2$.

No spaces have appeared around the `+' sign because it's in a
different formula, one which we have not yet touched with Embedded
mode.

Now that Embedded mode is enabled, keys you type in this buffer are
interpreted as Calc commands.  At this point we might use the
commute" command `j C' to reverse the inequality.  This is a
selection-based command for which we first need to move the cursor
onto the operator (`>' in this case) that needs to be commuted.

     We define $F_n = F_(n-1)+F_(n-2)$ for all $2 < n$.

The `M-# o' command is a useful way to open a Calc window
without actually selecting that window.  Giving this command
verifies that `2 < n' is also on the Calc stack.  Typing
`17 RET' would produce:

     We define $F_n = F_(n-1)+F_(n-2)$ for all $17$.

with `2 < n' and `17' on the stack; typing TAB at this point will
exchange the two stack values and restore `2 < n' to the embedded
formula.  Even though you can't normally see the stack in Embedded
mode, it is still there and it still operates in the same way.  But,
as with old-fashioned RPN calculators, you can only see the value at
the top of the stack at any given time (unless you use `M-# o').

Typing `M-# e' again turns Embedded mode off.  The Calc
window reveals that the formula `2 < n' is automatically
removed from the stack, but the `17' is not.  Entering
Embedded mode always pushes one thing onto the stack, and
leaving Embedded mode always removes one thing.  Anything else
that happens on the stack is entirely your business as far as
Embedded mode is concerned.

If you press `M-# e' in the wrong place by accident, it is possible
that Calc will be able to parse the nearby text as a formula and will
mangle that text in an attempt to redisplay it "properly" in the
current language mode.  If this happens, press `M-# e' again to exit
Embedded mode, then give the regular Emacs "undo" command (`C-_' or
`C-x u') to put the text back the way it was before Calc edited it.
Note that Calc's own Undo command (typed before you turn Embedded mode
back off) will not do you any good, because as far as Calc is
concerned you haven't done anything with this formula yet.



File: calc.info, Node: More About Embedded Mode, Next: Assignments in Embedded Mode, Prev: Basic Embedded Mode, Up: Embedded Mode

More About Embedded Mode
========================

When Embedded mode "activates" a formula, i.e., when it examines the
formula for the first time since the buffer was created or loaded,
Calc tries to sense the language in which the formula was written.  If
the formula contains any TeX-like `\' sequences, it is parsed (i.e.,
read) in TeX mode.  If the formula appears to be written in multi-line
Big mode, it is parsed in Big mode.  Otherwise, it is parsed according
to the current language mode.

Note that Calc does not change the current language mode according to
what it finds.  Even though it can read a TeX formula when not in TeX
mode, it will immediately rewrite this formula using whatever language
mode is in effect.  You must then type `d T' to switch Calc
permanently into TeX mode if that is what you desire.


Calc's parser is unable to read certain kinds of formulas.  For
example, with `v ]' (`calc-matrix-brackets') you can specify matrix
display styles which the parser is unable to recognize as matrices.
The `d p' (`calc-show-plain') command turns on a mode in which a
plain" version of a formula is placed in front of the fully-formatted
version.  When Calc reads a formula that has such a plain version in
front, it reads the plain version and ignores the formatted version.

Plain formulas are preceded and followed by `%%%' signs by default.
This notation has the advantage that the `%' character begins a
comment in TeX, so if your formula is embedded in a TeX document its
plain version will be invisible in the final printed copy.  *Note
Customizing Embedded Mode::, to see how to change the "plain" formula
delimiters, say to something that "eqn" or some other formatter will
treat as a comment.

There are several notations which Calc's parser for "big" formatted
formulas can't yet recognize.  In particular, it can't read the large
symbols for `sum', `prod', and `integ', and it can't handle `=>' with
the righthand argument omitted.  Also, Calc won't recognize special
formats you have defined with the `Z C' command (*Note User-Defined
Compositions::).  In these cases it is important to use "plain" mode
to make sure Calc will be able to read your formula later.

Another example where "plain" mode is important is if you have
specified a float mode with few digits of precision.  Normally any
digits that are computed but not displayed will simply be lost when
you save and re-load your embedded buffer, but "plain" mode allows you
to make sure that the complete number is present in the file as well
as the rounded-down number.


Embedded buffers remember active formulas for as long as they
exist in Emacs memory.  Suppose you have an embedded formula
which is `pi' to the normal 12 decimal places, and then
type `C-u 5 d n' to display only five decimal places.
If you then type `d n', all 12 places reappear because the
full number is still there on the Calc stack.  More surprisingly,
even if you exit Embedded mode and later re-enter it for that
formula, typing `d n' will restore all 12 places because
each buffer remembers all its active formulas.  However, if you
save the buffer in a file and reload it in a new Emacs session,
all non-displayed digits will have been lost unless you used
"plain" mode.


In some applications of Embedded mode, you will want to have a
sequence of copies of a formula that show its evolution as you work on
it.  For example, you might want to have a sequence like this in your
file (elaborating here on the example from the "Getting Started"
chapter):

     The derivative of

				   ln(ln(x))

     is

		       (the derivative of ln(ln(x)))

     whose value at x = 2 is

				 (the value)

     and at x = 3 is

				 (the value)

The `M-# d' (`calc-embedded-duplicate') command is a handy way to make
sequences like this.  If you type `M-# d', the formula under the
cursor (which may or may not have Embedded mode enabled for it at the
time) is copied immediately below and Embedded mode is then enabled
for that copy.

For this example, you would start with just

     The derivative of

				   ln(ln(x))

and press `M-# d' with the cursor on this formula.  The result is

     The derivative of

				   ln(ln(x))


				   ln(ln(x))

with the second copy of the formula enabled in Embedded mode.  You can
now press `a d x RET' to take the derivative, and `M-# d M-# d' to
make two more copies of the derivative.  To complete the computations,
type `3 s l x RET' to evaluate the last formula, then move up to the
second-to-last formula and type `2 s l x RET'.

Finally, you would want to press `M-# e' to exit Embedded mode, then
go up and insert the necessary text in between the various formulas
and numbers.


The `M-# f' (`calc-embedded-new-formula') command
creates a new embedded formula at the current point.  It inserts
some default delimiters, which are usually just blank lines,
and then does an algebraic entry to get the formula (which is
then enabled for Embedded mode).  This is just shorthand for
typing the delimiters yourself, positioning the cursor between
the new delimiters, and pressing `M-# e'.  The key sequence
`M-# '' is equivalent to `M-# f'.

The `M-# n' (`calc-embedded-next') and `M-# p'
(`calc-embedded-previous') commands move the cursor to the next or
previous active embedded formula in the buffer.  They can take
positive or negative prefix arguments to move by several formulas.
Note that these commands do not actually examine the text of the
buffer looking for formulas; they only see formulas which have
previously been activated in Embedded mode.  In fact, `M-# n' and `M-#
p' are a useful way to tell which embedded formulas are currently
active.  Also, note that these commands do not enable Embedded mode on
the next or previous formula, they just move the cursor.  (By the way,
`M-# n' is not as awkward to type as it may seem, because `M-#'
ignores Shift and Meta on the second keystroke: `M-# M-N' can be typed
by holding down Shift and Meta and alternately typing two keys.)

The `M-# `' (`calc-embedded-edit') command edits the
embedded formula at the current point as if by ``' (`calc-edit').
Embedded mode does not have to be enabled for this to work.  Press
`M-# M-#' to finish the edit, or `M-# x' to cancel.



File: calc.info, Node: Assignments in Embedded Mode, Next: Mode Settings in Embedded Mode, Prev: More About Embedded Mode, Up: Embedded Mode

Assignments in Embedded Mode
============================

The `:=' (assignment) and `=>' ("evaluates-to") operators are
especially useful in Embedded mode.  They allow you to make a
definition in one formula, then refer to that definition in other
formulas embedded in the same buffer.

An embedded formula which is an assignment to a variable, as in

     foo := 5

records `5' as the stored value of `foo' for the purposes of Embedded
mode operations in the current buffer.  It does *not* actually store
`5' as the "global" value of `foo', however.  Regular Calc operations,
and Embedded formulas in other buffers, will not see this assignment.

One way to use this assigned value is simply to create an Embedded
formula elsewhere that refers to `foo', and to press `=' in that
formula.  However, this permanently replaces the `foo' in the formula
with its current value.  More interesting is to use `=>' elsewhere:

     foo + 7 => 12

*Note Evaluates-To Operator::, for a general discussion of `=>'.

If you move back and change the assignment to `foo', any
`=>' formulas which refer to it are automatically updated.

     foo := 17

     foo + 7 => 24

The obvious question then is, *how* can one easily change the
assignment to `foo'?  If you simply select the formula in Embedded
mode and type 17, the assignment itself will be replaced by the 17.
The effect on the other formula will be that the variable `foo'
becomes unassigned:

     17

     foo + 7 => foo + 7

The right thing to do is first to use a selection command (`j 2' will
do the trick) to select the righthand side of the assignment.  Then,
`17 TAB DEL' will swap the 17 into place (*Note Selecting
Subformulas::, to see how this works).

The `M-# j' (`calc-embedded-select') command provides an easy way to
operate on assigments.  It is just like `M-# e', except that if the
enabled formula is an assignment, it uses `j 2' to select the
righthand side.  If the enabled formula is an evaluates-to, it uses `j
1' to select the lefthand side.  A formula can also be a combination
of both:

     bar := foo + 3 => 20

in which case `M-# j' will select the middle part (`foo + 3').

The formula is automatically deselected when you leave Embedded mode.

Another way to change the assignment to `foo' would simply be to edit
the number using regular Emacs editing rather than Embedded mode.
Then, we have to find a way to get Embedded mode to notice the change.
The `M-# u' or `M-# =' (`calc-embedded-update-formula') command is a
convenient way to do this.

     foo := 6

     foo + 7 => 13

Pressing `M-# u' is much like pressing `M-# e = M-# e', that is,
temporarily enabling Embedded mode for the formula under the cursor
and then evaluating it with `='.  But `M-# u' does not actually use
`M-# e', and in fact another formula somewhere else can be enabled in
Embedded mode while you use `M-# u' and that formula will not be
disturbed.

With a numeric prefix argument, `M-# u' updates all active `=>'
formulas in the buffer.  Formulas which have not yet been activated in
Embedded mode, and formulas which do not have `=>' as their top-level
operator, are not affected by this.  (This is useful only if you have
used `m C'; see below.)

With a plain `C-u' prefix, `C-u M-# u' updates only in the region
between mark and point rather than in the whole buffer.

`M-# u' is also a handy way to activate a formula, such as an `=>'
formula that has freshly been typed in or loaded from a file.

The `M-# a' (`calc-embedded-activate') command scans through the
current buffer and activates all embedded formulas that contain `:='
or `=>' symbols.  This does not mean that Embedded mode is actually
turned on, but only that the formulas' positions are registered with
Embedded mode so that the `=>' values can be properly updated as
assignments are changed.

It is a good idea to type `M-# a' right after loading a file that uses
embedded `=>' operators.  Emacs includes a nifty "buffer-local
variables" feature that you can use to do this automatically.  The
idea is to place near the end of your file a few lines that look like
this:

     --- Local Variables: ---
     --- eval:(calc-embedded-activate) ---
     --- End: ---

where the leading and trailing `---' can be replaced by any suitable
strings (which must be the same on all three lines) or omitted
altogether; in a TeX file, `%' would be a good leading string and no
trailing string would be necessary.  In a C program, `/*' and `*/'
would be good leading and trailing strings.

When Emacs loads a file into memory, it checks for a Local Variables
section like this one at the end of the file.  If it finds this
section, it does the specified things (in this case, running `M-# a'
automatically) before editing of the file begins.  The Local Variables
section must be within 3000 characters of the end of the file for
Emacs to find it, and it must be in the last page of the file if the
file has any page separators.  *Note Local Variables in Files:
(emacs)File Variables.

Note that `M-# a' does not update the formulas it finds.
To do this, type, say, `M-1 M-# u' after `M-# a'.
Generally this should not be a problem, though, because the
formulas will have been up-to-date already when the file was
saved.

Normally, `M-# a' activates all the formulas it finds, but
any previous active formulas remain active as well.  With a
positive numeric prefix argument, `M-# a' first deactivates
all current active formulas, then actives the ones it finds in
its scan of the buffer.  With a negative prefix argument,
`M-# a' simply deactivates all formulas.

Embedded mode has two symbols, `Active' and `~Active', which it puts
next to the major mode name in a buffer's mode line.  It puts `Active'
if it has reason to believe that all formulas in the buffer are
active, because you have typed `M-# a' and Calc has not since had to
deactivate any formulas (which can happen if Calc goes to update an
`=>' formula somewhere because a variable changed, and finds that the
formula is no longer there due to some kind of editing outside of
Embedded mode).  Calc puts `~Active' in the mode line if some, but
probably not all, formulas in the buffer are active.  This happens if
you activate a few formulas one at a time but never use `M-# a', or if
you used `M-# a' but then Calc had to deactivate a formula because it
lost track of it.  If neither of these symbols appears in the mode
line, no embedded formulas are active in the buffer (e.g., before
Embedded mode has been used, or after a `M-- M-# a').

Embedded formulas can refer to assignments both before and after them
in the buffer.  If there are several assignments to a variable, the
nearest preceding assignment is used if there is one, otherwise the
following assignment is used.

     x => 1

     x := 1

     x => 1

     x := 2

     x => 2

As well as simple variables, you can also assign to subscript
expressions of the form `VAR_NUMBER' (as in `x_0'), or `VAR_VAR' (as
in `x_max').  Assignments to other kinds of objects can be represented
by Calc, but the automatic linkage between assignments and references
works only for plain variables and these two kinds of subscript
expressions.

If there are no assignments to a given variable, the global
stored value for the variable is used (*Note Storing Variables::),
or, if no value is stored, the variable is left in symbolic form.
Note that global stored values will be lost when the file is saved
and loaded in a later Emacs session, unless you have used the
`s p' (`calc-permanent-variable') command to save them;
*Note Operations on Variables::.

The `m C' (`calc-auto-recompute') command turns automatic
recomputation of `=>' forms on and off.  If you turn automatic
recomputation off, you will have to use `M-# u' to update these
formulas manually after an assignment has been changed.  If you plan
to change several assignments at once, it may be more efficient to
type `m C', change all the assignments, then use `M-1 M-# u' to update
the entire buffer afterwards.  The `m C' command also controls `=>'
formulas on the stack; *Note Evaluates-To Operator::.  When you turn
automatic recomputation back on, the stack will be updated but the
Embedded buffer will not; you must use `M-# u' to update the buffer by
hand.



File: calc.info, Node: Mode Settings in Embedded Mode, Next: Customizing Embedded Mode, Prev: Assignments in Embedded Mode, Up: Embedded Mode

Mode Settings in Embedded Mode
==============================

Embedded Mode has a rather complicated mechanism for handling mode
settings in Embedded formulas.  It is possible to put annotations in
the file that specify mode settings either global to the entire file
or local to a particular formula or formulas.  In the latter case,
different modes can be specified for use when a formula is the enabled
Embedded Mode formula.

When you give any mode-setting command, like `m f' (for fraction mode)
or `d s' (for scientific notation), Embedded Mode adds a line like the
following one to the file just before the opening delimiter of the
formula.

     % [calc-mode: fractions: t]
     % [calc-mode: float-format: (sci 0)]

When Calc interprets an embedded formula, it scans the text before the
formula for mode-setting annotations like these and sets the Calc
buffer to match these modes.  Modes not explicitly described in the
file are not changed.  Calc scans all the way to the top of the file,
or up to a line of the form

     % [calc-defaults]

which you can insert at strategic places in the file if this backward
scan is getting too slow, or just to provide a barrier between one
zone" of mode settings and another.

If the file contains several annotations for the same mode, the
closest one before the formula is used.  Annotations after the formula
are never used (except for global annotations, described below).

The scan does not look for the leading `% ', only for the square
brackets and the text they enclose.  You can edit the mode annotations
to a style that works better in context if you wish.  *Note
Customizing Embedded Mode::, to see how to change the style that Calc
uses when it generates the annotations.  You can write mode
annotations into the file yourself if you know the syntax; the easiest
way to find the syntax for a given mode is to let Calc write the
annotation for it once and see what it does.

If you give a mode-changing command for a mode that already has a
suitable annotation just above the current formula, Calc will modify
that annotation rather than generating a new, conflicting one.

Mode annotations have three parts, separated by colons.  (Spaces after
the colons are optional.)  The first identifies the kind of mode
setting, the second is a name for the mode itself, and the third is
the value in the form of a Lisp symbol, number, or list.  Annotations
with unrecognizable text in the first or second parts are ignored.
The third part is not checked to make sure the value is of a legal
type or range; if you write an annotation by hand, be sure to give a
proper value or results will be unpredictable.  Mode-setting
annotations are case-sensitive.

While Embedded Mode is enabled, the word `Local' appears in
the mode line.  This is to show that mode setting commands generate
annotations that are "local" to the current formula or set of
formulas.  The `m R' (`calc-mode-record-mode') command
causes Calc to generate different kinds of annotations.  Pressing
`m R' repeatedly cycles through the possible modes.

`LocEdit' and `LocPerm' modes generate annotations that look like
this, respectively:

     % [calc-edit-mode: float-format: (sci 0)]
     % [calc-perm-mode: float-format: (sci 5)]

The first kind of annotation will be used only while a formula is
enabled in Embedded Mode.  The second kind will be used only when the
formula is *not* enabled.  (Whether the formula is "active" or not,
i.e., whether Calc has seen this formula yet, is not relevant here.)

`Global' mode generates an annotation like this at the end of the
file:

     % [calc-global-mode: fractions t]

Global mode annotations affect all formulas throughout the file, and
may appear anywhere in the file.  This allows you to tuck your mode
annotations somewhere out of the way, say, on a new page of the file,
as long as those mode settings are suitable for all formulas in the
file.

Enabling a formula with `M-# e' causes a fresh scan for local mode
annotations; you will have to use this after adding annotations above
a formula by hand to get the formula to notice them.  Updating a
formula with `M-# u' will also re-scan the local modes, but global
modes are only re-scanned by `M-# a'.

Another way that modes can get out of date is if you add a local mode
annotation to a formula that has another formula after it.  In this
example, we have used the `d s' command while the first of the two
embedded formulas is active.  But the second formula has not changed
its style to match, even though by the rules of reading annotations
the `(sci 0)' applies to it, too.

     % [calc-mode: float-format: (sci 0)]
     1.23e2

     456.

We would have to go down to the other formula and press `M-# u' on it
in order to get it to notice the new annotation.

Two more mode-recording modes selectable by `m R' are `Save' (which
works even outside of Embedded Mode), in which mode settings are
recorded permanently in your Emacs startup file `~/.emacs' rather than
by annotating the current document, and no-recording mode (where there
is no symbol like `Save' or `Local' in the mode line), in which
mode-changing commands do not leave any annotations at all.

When Embedded Mode is not enabled, mode-recording modes except for
`Save' have no effect.



