Info file: calc.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `calc.texinfo'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the author
instead of in the original English.




File: calc.info, Node: Formulas, Prev: Variables, Up: Data Types

Formulas
========

When you press the apostrophe key you may enter any expression or
formula in algebraic form.  (Calc uses the terms "expression" and
formula" interchangeably.)  An expression is built up of numbers,
variable names, and function calls, combined with various arithmetic
operators.  Parentheses may be used to indicate grouping.  Spaces are
ignored within formulas, except that spaces are not permitted within
variable names or numbers.  Arithmetic operators, in order from
highest to lowest precedence, and with their equivalent function
names, are:

`_' [`subscr'] (subscripts);

postfix `%' [`percent'] (as in `25% = 0.25');

prefix `+' and `-' [`neg'] (as in `-x') and prefix `!' [`lnot']
(logical "not," as in `!x');

`+/-' [`sdev'] (the standard deviation symbol) and
`mod' [`makemod'] (the symbol for modulo forms);

postfix `!' [`fact'] (factorial, as in `n!')  and postfix `!!'
[`dfact'] (double factorial);

`^' [`pow'] (raised-to-the-power-of);

`*' [`mul'];

`/' [`div'], `%' [`mod'] (modulo), and
`\' [`idiv'] (integer division);

infix `+' [`add'] and `-' [`sub'] (as in `x-y');

`|' [`vconcat'] (vector concatenation);

relations `=' [`eq'], `!=' [`neq'], `<' [`lt'],
`>' [`gt'], `<=' [`leq'], and `>=' [`geq'];

`&&' [`land'] (logical "and");

`||' [`lor'] (logical "or");

the C-style "if" operator `a?b:c' [`if'];

`!!!' [`pnot'] (rewrite pattern "not");

`&&&' [`pand'] (rewrite pattern "and");

`|||' [`por'] (rewrite pattern "or");

`:=' [`assign'] (for assignments and rewrite rules);

`::' [`condition'] (rewrite pattern condition);

`=>' [`evalto'].

Note that, unlike in usual computer notation, multiplication binds more
strongly than division:  `a*b/c*d' is equivalent to `(a*b)/(c*d)'.

The multiplication sign `*' may be omitted in many cases.  In
particular, if the righthand side is a number, variable name, or
parenthesized expression, the `*' may be omitted.  Implicit
multiplication has the same precedence as the explicit `*' operator.
The one exception to the rule is that a variable name followed by a
parenthesized expression, as in `f(x)', is interpreted as a function
call, not an implicit `*'.  In many cases you must use a space if you
omit the `*': `2a' is the same as `2*a', and `a b' is the same as
`a*b', but `ab' is a variable called `ab', *not* the product of `a'
and `b'!  Also note that `f (x)' is still a function call.

The rules are slightly different for vectors written with square
brackets.  In vectors, the space character is interpreted (like the
comma) as a separator of elements of the vector.  Thus `[ 2a b+c d ]'
is equivalent to `[2*a, b+c, d]', whereas `2a b+c d' is equivalent to
`2*a*b + c*d'.  Note that spaces around the brackets, and around
explicit commas, are ignored.  To force spaces to be interpreted as
multiplication you can enclose a formula in parentheses as in `[(a b)
2(c d)]', which is interpreted as `[a*b, 2*c*d]'.  An implicit comma
is also inserted between `][', as in the matrix `[[1 2][3 4]]'.

Vectors that contain commas (not embedded within nested parentheses or
brackets) do not treat spaces specially:  `[a b, 2 c d]' is a vector
of two elements.  Also, if it would be an error to treat spaces as
separators, but not otherwise, then Calc will ignore spaces:
`[a - b]' is a vector of one element, but `[a -b]' is
a vector of two elements.  Finally, vectors entered with curly braces
instead of square brackets do not give spaces any special treatment.
When Calc displays a vector that does not contain any commas, it will
insert parentheses if necessary to make the meaning clear:
`[(a b)]'.

The expression `5%-2' is ambiguous; is this five-percent minus two, or
five modulo minus-two?  Calc always interprets the leftmost symbol as
an infix operator preferentially (modulo, in this case), so you would
need to write `(5%)-2' to get the former interpretation.

A function call is, e.g., `sin(1+x)'.  Function names follow the same
rules as variable names except that the default prefix `calcFunc-' is
used (instead of `var-') for the internal Lisp form.  Most
mathematical Calculator commands like `calc-sin' have function
equivalents like `sin'.  If no Lisp function is defined for a function
called by a formula, the call is left as it is during algebraic
manipulation: `f(x+y)' is left alone.  Beware that many
innocent-looking short names like `in' and `re' have predefined
meanings which could surprise you; however, single letters or single
letters followed by digits are always safe to use for your own
function names.  *Note Function Index::.

In the documentation for particular commands, the notation `H S'
(`calc-sinh') [`sinh'] means that the key sequence `H S', the command
`M-x calc-sinh', and the algebraic function `sinh(x)' all represent
the same operation.

Commands that interpret ("parse") text as algebraic formulas include
algebraic entry (`''), editing commands like ``' which parse
the contents of the editing buffer when you finish, the `M-# g'
and `M-# r' commands, the `C-y' command, the X window system
"paste" mouse operation, and Embedded Mode.  All of these operations
use the same rules for parsing formulas; in particular, language modes
(*Note Language Modes::) affect them all in the same way.

When you read a large amount of text into the Calculator (say a vector
which represents a big set of rewrite rules; *Note Rewrite Rules::),
you may wish to include comments in the text.  Calc's formula parser
ignores the symbol `%%' and anything following it on a line:

     [ a + b,   %% the sum of "a" and "b"
       c + d,
       %% last line is coming up:
       e + f ]

This is parsed exactly the same as `[ a + b, c + d, e + f ]'.

*Note Syntax Tables::, for a way to create your own operators and
other input notations.  *Note Compositions::, for a way to create new
display formats.

*Note Algebra::, for commands for manipulating formulas symbolically.



File: calc.info, Node: Stack and Trail, Next: Mode Settings, Prev: Data Types, Up: Top

Stack and Trail Commands
************************

This chapter describes the Calc commands for manipulating objects on
the stack and in the trail buffer.  (These commands operate on objects
of any type, such as numbers, vectors, formulas, and incomplete
objects.)

* Menu:

* Stack Manipulation::
* Editing Stack Entries::
* Trail Commands::
* Keep Arguments::



File: calc.info, Node: Stack Manipulation, Next: Editing Stack Entries, Prev: Stack and Trail, Up: Stack and Trail

Stack Manipulation Commands
===========================

To duplicate the top object on the stack, press RET or SPC (two
equivalent keys for the `calc-enter' command).  Given a positive
numeric prefix argument, these commands duplicate several elements at
the top of the stack.  Given a negative argument, these commands
duplicate the specified element of the stack.  Given an argument of
zero, they duplicate the entire stack.  For example, with `10 20 30'
on the stack, RET creates `10 20 30 30', `C-u 2 RET' creates `10 20 30
20 30', `C-u - 2 RET' creates `10 20 30 20', and `C-u 0 RET' creates
`10 20 30 10 20 30'.

The LFD (`calc-over') command (on a key marked Line-Feed if you have
it, else on `C-j') is like `calc-enter' except that the sign of the
numeric prefix argument is interpreted oppositely.  Also, with no
prefix argument the default argument is 2.  Thus with `10 20 30' on
the stack, LFD and `C-u 2 LFD' are both equivalent to `C-u - 2 RET',
producing `10 20 30 20'.

To remove the top element from the stack, press DEL (`calc-pop').  The
`C-d' key is a synonym for DEL.  (If the top element is an incomplete
object with at least one element, the last element is removed from
it.)  Given a positive numeric prefix argument, several elements are
removed.  Given a negative argument, the specified element of the
stack is deleted.  Given an argument of zero, the entire stack is
emptied.  For example, with `10 20 30' on the stack, DEL leaves `10
20', `C-u 2 DEL' leaves `10', `C-u - 2 DEL' leaves `10 30', and `C-u 0
DEL' leaves an empty stack.

The M-DEL (`calc-pop-above') command is to DEL what LFD is to RET: It
interprets the sign of the numeric prefix argument in the opposite
way, and the default argument is 2.  Thus M-DEL by itself removes the
second-from-top stack element, leaving the first, third, fourth, and
so on; `M-3 M-DEL' deletes the third stack element.

To exchange the top two elements of the stack, press TAB
(`calc-roll-down').  Given a positive numeric prefix argument, the
specified number of elements at the top of the stack are rotated
downward.  Given a negative argument, the entire stack is rotated
downward the specified number of times.  Given an argument of zero,
the entire stack is reversed top-for-bottom.  For example, with `10 20
30 40 50' on the stack, TAB creates `10 20 30 50 40', `C-u 3 TAB'
creates `10 20 50 30 40', `C-u - 2 TAB' creates `40 50 10 20 30', and
`C-u 0 TAB' creates `50 40 30 20 10'.

The command M-TAB (`calc-roll-up') is analogous to TAB except that it
rotates upward instead of downward.  Also, the default with no prefix
argument is to rotate the top 3 elements.  For example, with `10 20 30
40 50' on the stack, M-TAB creates `10 20 40 50 30', `C-u 4 M-TAB'
creates `10 30 40 50 20', `C-u - 2 M-TAB' creates `30 40 50 10 20',
and `C-u 0 M-TAB' creates `50 40 30 20 10'.

A good way to view the operation of TAB and M-TAB is in terms of
moving a particular element to a new position in the stack.  With a
positive argument n, TAB moves the top stack element down to level n,
making room for it by pulling all the intervening stack elements
toward the top.  M-TAB moves the element at level n up to the top.
(Compare with LFD, which copies instead of moving the element in level
n.)

With a negative argument -n, TAB rotates the stack to move the object
in level n to the deepest place in the stack, and the object in level
n+1 to the top.  M-TAB rotates the deepest stack element to be in
level n, also putting the top stack element in level n+1.

*Note Selecting Subformulas::, for a way to apply these commands to
any portion of a vector or formula on the stack.



File: calc.info, Node: Editing Stack Entries, Next: Trail Commands, Prev: Stack Manipulation, Up: Stack and Trail

Editing Stack Entries
=====================

The backquote, ``' (`calc-edit') command creates a temporary buffer
(`*Calc Edit*') for editing the top-of-stack value using regular Emacs
commands.  With a numeric prefix argument, it edits the specified
number of stack entries at once.  (An argument of zero edits the
entire stack; a negative argument edits one specific stack entry.)

When you are done editing, press `M-# M-#' to finish and return to
Calc.  The RET and LFD keys also work to finish most sorts of editing,
though in some cases Calc leaves RET with its usual meaning ("insert a
newline") if it's a situation where you might want to insert new lines
into the editing buffer.  The traditional Emacs "finish" key sequence,
`C-c C-c', also works to finish editing and may be easier to type,
depending on your keyboard.

When you finish editing, the Calculator parses the lines of text in
the `*Calc Edit*' buffer as numbers or formulas, replaces the original
stack elements in the original buffer with these new values, then
kills the `*Calc Edit*' buffer.  The original Calculator buffer
continues to exist during editing, but for best results you should be
careful not to change it until you have finished the edit.  You can
also cancel the edit by pressing `M-# x'.

The formula is normally reevaluated as it is put onto the stack.  For
example, editing `a + 2' to `3 + 2' and pressing `M-# M-#' will push 5
on the stack.  If you use LFD to finish, Calc will put the result on
the stack without evaluating it.

If you give a prefix argument to `M-# M-#' (or `C-c C-c'), Calc will
not kill the `*Calc Edit*' buffer.  You can switch back to that buffer
and continue editing if you wish.  However, you should understand that
if you initiated the edit with ``', the `M-# M-#' operation will be
programmed to replace the top of the stack with the new edited value,
and it will do this even if you have rearranged the stack in the
meanwhile.  This is not so much of a problem with other editing
commands, though, such as `s e' (`calc-edit-variable'; *Note
Operations on Variables::).

If the `calc-edit' command involves more than one stack entry,
each line of the `*Calc Edit*' buffer is interpreted as a
separate formula.  Otherwise, the entire buffer is interpreted as
one formula, with line breaks ignored.  (You can use `C-o' or
`C-q C-j' to insert a newline in the buffer without pressing RET.)

The ``' key also works during numeric or algebraic entry.  The text
entered so far is moved to the `*Calc Edit*' buffer for more extensive
editing than is convenient in the minibuffer.



File: calc.info, Node: Trail Commands, Next: Keep Arguments, Prev: Editing Stack Entries, Up: Stack and Trail

Trail Commands
==============

The commands for manipulating the Calc Trail buffer are two-key
sequences beginning with the `t' prefix.

The `t d' (`calc-trail-display') command turns display of the
trail on and off.  Normally the trail display is toggled on if it was off,
off if it was on.  With a numeric prefix of zero, this command always
turns the trail off; with a prefix of one, it always turns the trail on.
The other trail-manipulation commands described here automatically turn
the trail on.  Note that when the trail is off values are still recorded
there; they are simply not displayed.  To set Emacs to turn the trail
off by default, type `t d' and then save the mode settings with
`m m' (`calc-save-modes').

The `t i' (`calc-trail-in') and `t o' (`calc-trail-out') commands
switch the cursor into and out of the Calc Trail window.  In practice
they are rarely used, since the commands shown below are a more
convenient way to move around in the trail, and they work "by remote
control" when the cursor is still in the Calculator window.

There is a "trail pointer" which selects some entry of the trail at
any given time.  The trail pointer looks like a `>' symbol right
before the selected number.  The following commands operate on the
trail pointer in various ways.

The `t y' (`calc-trail-yank') command reads the selected value in the
trail and pushes it onto the Calculator stack.  It allows you to
re-use any previously computed value without retyping.  With a numeric
prefix argument N, it yanks the value N lines above the current trail
pointer.

The `t <' (`calc-trail-scroll-left') and `t >'
(`calc-trail-scroll-right') commands horizontally scroll the trail
window left or right by one half of its width.

The `t n' (`calc-trail-next') and `t p' (`calc-trail-previous)'
commands move the trail pointer down or up one line.  The `t f'
(`calc-trail-forward') and `t b' (`calc-trail-backward') commands move
the trail pointer down or up one screenful at a time.  All of these
commands accept numeric prefix arguments to move several lines or
screenfuls at a time.

The `t [' (`calc-trail-first') and `t ]' (`calc-trail-last') commands
move the trail pointer to the first or last line of the trail.  The `t
h' (`calc-trail-here') command moves the trail pointer to the cursor
position; unlike the other trail commands, `t h' works only when Calc
Trail is the selected window.

The `t s' (`calc-trail-isearch-forward') and `t r'
(`calc-trail-isearch-backward') commands perform an incremental search
forward or backward through the trail.  You can press RET to terminate
the search; the trail pointer moves to the current line.  If you
cancel the search with `C-g', the trail pointer stays where it was
when the search began.

The `t m' (`calc-trail-marker') command allows you to enter a line of
text of your own choosing into the trail.  The text is inserted after
the line containing the trail pointer; this usually means it is added
to the end of the trail.  Trail markers are useful mainly as the
targets for later incremental searches in the trail.

The `t k' (`calc-trail-kill') command removes the selected line from
the trail.  The line is saved in the Emacs kill ring suitable for
yanking into another buffer, but it is not easy to yank the text back
into the trail buffer.  With a numeric prefix argument, this command
kills the N lines below or above the selected one.

The `t .' (`calc-full-trail-vectors') command is described elsewhere;
*Note Vector and Matrix Formats::.



File: calc.info, Node: Keep Arguments, Prev: Trail Commands, Up: Stack and Trail

Keep Arguments
==============

The `K' (`calc-keep-args') command acts like a prefix for the
following command.  It prevents that command from removing its
arguments from the stack.  For example, after `2 RET 3 +', the stack
contains the sole number 5, but after `2 RET 3 K +', the stack
contains the arguments and the result: `2 3 5'.

This works for all commands that take arguments off the stack.  As
another example, `K a s' simplifies a formula, pushing the simplified
version of the formula onto the stack after the original formula
(rather than replacing the original formula).

Note that you could get the same effect by typing `RET a s', copying
the formula and then simplifying the copy.  One difference is that for
a very large formula the time taken to format the intermediate copy in
`RET a s' could be noticeable; `K a s' would avoid this extra work.

Even stack manipulation commands are affected.  TAB works by popping
two values and pushing them back in the opposite order, so `2 RET 3 K
TAB' produces `2 3 3 2'.

A few Calc commands provide other ways of doing the same thing.  For
example, `' sin($)' replaces the number on the stack with its sine
using algebraic entry; to push the sine and keep the original argument
you could use either `' sin($1)' or `K ' sin($)'.  *Note Algebraic
Entry::.  Also, the `s s' command is effectively the same as `K s t'.
*Note Storing Variables::.

Keyboard macros may interact surprisingly with the `K' prefix.  If you
have defined a keyboard macro to be, say, `Q +' to add one number to
the square root of another, then typing `K X' will execute `K Q +',
probably not what you expected.  The `K' prefix will apply to just the
first command in the macro rather than the whole macro.

If you execute a command and then decide you really wanted to keep
the argument, you can press `M-RET' (`calc-last-args').
This command pushes the last arguments that were popped by any command
onto the stack.  Note that the order of things on the stack will be
different than with `K':  `2 RET 3 + M-RET' leaves
`5 2 3' on the stack instead of `2 3 5'.  *Note Undo::.



File: calc.info, Node: Mode Settings, Next: Arithmetic, Prev: Stack and Trail, Up: Top

Mode Settings
*************

This chapter describes commands that set modes in the Calculator.
They do not affect the contents of the stack, although they may change
the *appearance* or *interpretation* of the stack's contents.

* Menu:

* General Mode Commands::
* Precision::
* Inverse and Hyperbolic::
* Calculation Modes::
* Simplification Modes::
* Declarations::
* Display Modes::
* Language Modes::
* Modes Variable::
* Calc Mode Line::



File: calc.info, Node: General Mode Commands, Next: Precision, Prev: Mode Settings, Up: Mode Settings

General Mode Commands
=====================

You can save all of the current mode settings in your `.emacs' file
with the `m m' (`calc-save-modes') command.  This will cause Emacs to
reestablish these modes each time it starts up.  The modes saved in
the file include everything controlled by the `m' and `d' prefix keys,
the current precision and binary word size, whether or not the trail
is displayed, the current height of the Calc window, and more.  The
current interface (used when you type `M-# M-#') is also saved.  If
there were already saved mode settings in the file, they are replaced.
Otherwise, the new mode information is appended to the end of the
file.

The `m R' (`calc-mode-record-mode') command tells Calc to record the
new mode settings (as if by pressing `m m') every time a mode setting
changes.  If Embedded Mode is enabled, other options are available;
*Note Mode Settings in Embedded Mode::.

The `m F' (`calc-settings-file-name') command allows you to choose a
different place than your `.emacs' file for `m m', `Z P', and similar
commands to save permanent information.  You are prompted for a file
name.  All Calc modes are then reset to their default values, then
settings from the file you named are loaded if this file exists, and
this file becomes the one that Calc will use in the future for
commands like `m m'.  The default settings file name is `~/.emacs'.
You can see the current file name by giving a blank response to the `m
F' prompt.  See also the discussion of the `calc-settings-file'
variable; *Note Installation::.

If the file name you give contains the string `.emacs' anywhere inside
it, `m F' will not automatically load the new file.  This is because
you are presumably switching to your `~/.emacs' file, which may
contain other things you don't want to reread.  You can give a numeric
prefix argument of 1 to `m F' to force it to read the file no matter
what its name.  Conversely, an argument of -1 tells `m F' *not* to
read the new file.  An argument of 2 or -2 tells `m F' not to reset
the modes to their defaults beforehand, which is useful if you intend
your new file to have a variant of the modes present in the file you
were using before.

The `m x' (`calc-always-load-extensions') command enables a mode in
which the first use of Calc loads the entire program, including all
extensions modules.  Otherwise, the extensions modules will not be
loaded until the various advanced Calc features are used.  Since this
mode only has effect when Calc is first loaded, `m x' is usually
followed by `m m' to make the mode-setting permanent.  To load all of
Calc just once, rather than always in the future, you can press `M-#
L'.

The `m S' (`calc-shift-prefix') command enables a mode in which all of
Calc's letter prefix keys may be typed shifted as well as unshifted.
If you are typing, say, `a S' (`calc-solve-for') quite often you might
find it easier to turn this mode on so that you can type `A S'
instead.  When this mode is enabled, the commands that used to be on
those single shifted letters (e.g., `A' (`calc-abs')) can now be
invoked by pressing the shifted letter twice: `A A'.  Note that the
`v' prefix key always works both shifted and unshifted, and the `z'
and `Z' prefix keys are always distinct.  Also, the `h' prefix is not
affected by this mode.  Press `m S' again to disable shifted-prefix
mode.



File: calc.info, Node: Precision, Next: Inverse and Hyperbolic, Prev: General Mode Commands, Up: Mode Settings

Precision
=========

The `p' (`calc-precision') command controls the precision to which
floating-point calculations are carried.  The precision must be at
least 3 digits and may be arbitrarily high, within the limits of
memory and time.  This affects only floats: Integer and rational
calculations are always carried out with as many digits as necessary.

The `p' key prompts for the current precision.  If you wish you can
instead give the precision as a numeric prefix argument.

Many internal calculations are carried to one or two digits higher
precision than normal.  Results are rounded down afterward to the
current precision.  Unless a special display mode has been selected,
floats are always displayed with their full stored precision, i.e.,
what you see is what you get.  Reducing the current precision does not
round values already on the stack, but those values will be rounded
down before being used in any calculation.  The `c 0' through `c 9'
commands (*Note Conversions::) can be used to round an existing value
to a new precision.

It is important to distinguish the concepts of "precision" and
accuracy".  In the normal usage of these words, the number 123.4567
has a precision of 7 digits but an accuracy of 4 digits.  The
precision is the total number of digits not counting leading or
trailing zeros (regardless of the position of the decimal point).  The
accuracy is simply the number of digits after the decimal point (again
not counting trailing zeros).  In Calc you control the precision, not
the accuracy of computations.  If you were to set the accuracy
instead, then calculations like `exp(100)' would generate many more
digits than you would typically need, while `exp(-100)' would probably
round to zero!  In Calc, both these computations give you exactly 12
(or the requested number of) significant digits.

The only Calc features that deal with accuracy instead of precision
are fixed-point display mode for floats (`d f'; *Note Float
Formats::), and the rounding functions like `floor' and `round' (*Note
Integer Truncation::).  Also, `c 0' through `c 9' deal with both
precision and accuracy depending on the magnitudes of the numbers
involved.

If you need to work with a particular fixed accuracy (say, dollars and
cents with two digits after the decimal point), one solution is to
work with integers and an "implied" decimal point.  For example, $8.99
divided by 6 would be entered `899 RET 6 /', yielding 149.833
(actually $1.49833 with our implied decimal point); pressing `R' would
round this to 150 cents, i.e., $1.50.

*Note Floats::, for still more on floating-point precision and related
issues.



File: calc.info, Node: Inverse and Hyperbolic, Next: Calculation Modes, Prev: Precision, Up: Mode Settings

Inverse and Hyperbolic Flags
============================

There is no single-key equivalent to the `calc-arcsin' function.
Instead, you must first press `I' (`calc-inverse') to set the "Inverse
Flag", then press `S' (`calc-sin').  The `I' key actually toggles the
Inverse Flag.  When this flag is set, the word `Inv' appears in the
mode line.

Likewise, the `H' key (`calc-hyperbolic') sets or clears the
Hyperbolic Flag, which transforms `calc-sin' into `calc-sinh'.  If
both of these flags are set at once, the effect will be
`calc-arcsinh'.  (The Hyperbolic flag is also used by some
non-trigonometric commands; for example `H L' computes a base-10,
instead of base-e, logarithm.)

Command names like `calc-arcsin' are provided for completeness, and
may be executed with `x' or `M-x'.  Their effect is simply to toggle
the Inverse and/or Hyperbolic flags and then execute the corresponding
base command (`calc-sin' in this case).

The Inverse and Hyperbolic flags apply only to the next Calculator
command, after which they are automatically cleared.  (They are also
cleared if the next keystroke is not a Calc command.)  Digits you type
after `I' or `H' (or `K') are treated as prefix arguments for the next
command, not as numeric entries.  The same is true of `C-u', but not
of the minus sign (`K -' means to subtract and keep arguments).

The third Calc prefix flag, `K' (keep-arguments), is discussed
elsewhere.  *Note Keep Arguments::.



File: calc.info, Node: Calculation Modes, Next: Simplification Modes, Prev: Inverse and Hyperbolic, Up: Mode Settings

Calculation Modes
=================

The commands in this section are two-key sequences beginning with the
`m' prefix.  (That's the letter `m', not the META key.)  The `m a'
(`calc-algebraic-mode') command is described elsewhere (*Note
Algebraic Entry::).

* Menu:

* Angular Modes::
* Polar Mode::
* Fraction Mode::
* Infinite Mode::
* Symbolic Mode::
* Matrix Mode::
* Automatic Recomputation::
* Working Message::



File: calc.info, Node: Angular Modes, Next: Polar Mode, Prev: Calculation Modes, Up: Calculation Modes

Angular Modes
-------------

The Calculator supports three notations for angles: radians, degrees,
and degrees-minutes-seconds.  When a number is presented to a function
like `sin' that requires an angle, the current angular mode is used to
interpret the number as either radians or degrees.  If an HMS form is
presented to `sin', it is always interpreted as
degrees-minutes-seconds.

Functions that compute angles produce a number in radians, a number in
degrees, or an HMS form depending on the current angular mode.  If the
result is a complex number and the current mode is HMS, the number is
instead expressed in degrees.  (Complex-number calculations would
normally be done in radians mode, though.  Complex numbers are converted
to degrees by calculating the complex result in radians and then
multiplying by 180 over `pi'.)

The `m r' (`calc-radians-mode'), `m d' (`calc-degrees-mode'), and `m
h' (`calc-hms-mode') commands control the angular mode.  The current
angular mode is displayed on the Emacs mode line.  The default angular
mode is degrees.



File: calc.info, Node: Polar Mode, Next: Fraction Mode, Prev: Angular Modes, Up: Calculation Modes

Polar Mode
----------

The Calculator normally "prefers" rectangular complex numbers in the
sense that rectangular form is used when the proper form can not be
decided from the input.  This might happen by multiplying a
rectangular number by a polar one, by taking the square root of a
negative real number, or by entering `( 2 SPC 3 )'.

The `m p' (`calc-polar-mode') command toggles complex-number
preference between rectangular and polar forms.  In polar mode, all of
the above example situations would produce polar complex numbers.



File: calc.info, Node: Fraction Mode, Next: Infinite Mode, Prev: Polar Mode, Up: Calculation Modes

Fraction Mode
-------------

Division of two integers normally yields a floating-point number if
the result cannot be expressed as an integer.  In some cases you would
rather get an exact fractional answer.  One way to accomplish this is
to multiply fractions instead: `6 RET 1:4 *' produces `3:2' even
though `6 RET 4 /' produces `1.5'.

To set the Calculator to produce fractional results for normal integer
divisions, use the `m f' (`calc-frac-mode') command.  For example,
`8/4' produces `2' in either mode, but `6/4' produces `3:2' in
Fraction Mode, `1.5' in Float Mode.

At any time you can use `c f' (`calc-float') to convert a fraction to
a float, or `c F' (`calc-fraction') to convert a float to a fraction.
*Note Conversions::.



File: calc.info, Node: Infinite Mode, Next: Symbolic Mode, Prev: Fraction Mode, Up: Calculation Modes

Infinite Mode
-------------

The Calculator normally treats results like `1 / 0' as errors;
formulas like this are left in unsimplified form.  But Calc can be put
into a mode where such calculations instead produce "infinite"
results.

The `m i' (`calc-infinite-mode') command turns this mode on and off.
When the mode is off, infinities do not arise except in calculations
that already had infinities as inputs.  (One exception is that
infinite open intervals like `[0 .. inf)' can be generated; however,
intervals closed at infinity (`[0 .. inf]') will not be generated when
infinite mode is off.)

With infinite mode turned on, `1 / 0' will generate `uinf', an
undirected infinity.  *Note Infinities::, for a discussion of the
difference between `inf' and `uinf'.  Also, `0 / 0' evaluates to
`nan', the "indeterminate" symbol.  Various other functions can also
return infinities in this mode; for example, `ln(0) = -inf', and
`gamma(-7) = uinf'.  Once again, note that `exp(inf) = inf' regardless
of infinite mode because this calculation has infinity as an input.

The `m i' command with a numeric prefix argument of zero, i.e., `C-u 0
m i', turns on a "positive infinite mode" in which zero is treated as
positive instead of being directionless.  Thus, `1 / 0 = inf' and `-1
/ 0 = -inf' in this mode.  Note that zero never actually has a sign in
Calc; there are no separate representations for +0 and -0.  Positive
infinite mode merely changes the interpretation given to the single
symbol, `0'.  One consequence of this is that, while you might expect
`1 / -0 = -inf', actually `1 / -0' is equivalent to `1 / 0', which is
equal to positive `inf'.



File: calc.info, Node: Symbolic Mode, Next: Matrix Mode, Prev: Infinite Mode, Up: Calculation Modes

Symbolic Mode
-------------

Calculations are normally performed numerically wherever possible.
For example, the `calc-sqrt' command, or `sqrt' function in an
algebraic expression, produces a numeric answer if the argument is a
number or a symbolic expression if the argument is an expression:
`2 Q' pushes 1.4142 but `' x+1 RET Q' pushes `sqrt(x+1)'.

In "symbolic mode", controlled by the `m s' (`calc-symbolic-mode')
command, functions which would produce inexact, irrational results are
left in symbolic form.  Thus `16 Q' pushes 4, but `2 Q' pushes
`sqrt(2)'.

The shift-`N' (`calc-eval-num') command evaluates numerically the
expression at the top of the stack, by temporarily disabling
`calc-symbolic-mode' and executing `=' (`calc-evaluate').  Given a
numeric prefix argument, it also sets the floating-point precision to
the specified value for the duration of the command.

To evaluate a formula numerically without expanding the variables it
contains, you can use the key sequence `m s a v m s' (this uses
`calc-alg-evaluate', which resimplifies but doesn't evaluate
variables.)



File: calc.info, Node: Matrix Mode, Next: Automatic Recomputation, Prev: Symbolic Mode, Up: Calculation Modes

Matrix and Scalar Modes
-----------------------

Calc sometimes makes assumptions during algebraic manipulation that
are awkward or incorrect when vectors and matrices are involved.  Calc
has two modes, "matrix mode" and "scalar mode", which modify its
behavior around vectors in useful ways.

Press `m v' (`calc-matrix-mode') once to enter matrix mode.  In this
mode, all objects are assumed to be matrices unless provably
otherwise.  One major effect is that Calc will no longer consider
multiplication to be commutative.  (Recall that in matrix arithmetic,
`A*B' is not the same as `B*A'.)  This assumption affects rewrite
rules and algebraic simplification.  Another effect of this mode is
that calculations that would normally produce constants like 0 and 1
(e.g., `a - a' and `a / a', respectively) will now produce function
calls that represent "generic" zero or identity matrices: `idn(0)',
`idn(1)'.  The `idn' function `idn(A,N)' returns A times an NxN
identity matrix; if N is omitted, it doesn't know what dimension to
use and so the `idn' call remains in symbolic form.  However, if this
generic identity matrix is later combined with a matrix whose size is
known, it will be converted into a true identity matrix of the
appropriate size.  On the other hand, if it is combined with a scalar
(as in `idn(1) + 2'), Calc will assume it really was a scalar after
all and produce, e.g., 3.

Press `m v' a second time to get scalar mode.  Here, objects are
assumed *not* to be vectors or matrices unless provably so.  For
example, normally adding a variable to a vector, as in `[x, y, z] +
a', will leave the sum in symbolic form because as far as Calc knows,
`a' could represent either a number or another 3-vector.  In scalar
mode, `a' is assumed to be a non-vector, and the addition is evaluated
to `[x+a, y+a, z+a]'.

Press `m v' a third time to return to the normal mode of operation.

If you press `m v' with a numeric prefix argument N, you get a special
dimensioned matrix mode" in which matrices of unknown size are assumed
to be NxN square matrices.  Then, the function call `idn(1)' will
expand into an actual matrix rather than representing a "generic"
matrix.

Of course these modes are approximations to the true state of
affairs, which is probably that some quantities will be matrices
and others will be scalars.  One solution is to "declare"
certain variables or functions to be scalar-valued.
*Note Declarations::, to see how to make declarations in Calc.

There is nothing stopping you from declaring a variable to be scalar
and then storing a matrix in it; however, if you do, the results you
get from Calc may not be valid.  Suppose you let Calc get the result
`[x+a, y+a, z+a]' shown above, and then stored `[1, 2, 3]' in `a'.
The result would not be the same as for `[x, y, z] + [1, 2, 3]', but
that's because you have broken your earlier promise to Calc that `a'
would be scalar.

Another way to mix scalars and matrices is to use selections (*Note
Selecting Subformulas::).  Use matrix mode when operating on your
formula normally; then, to apply scalar mode to a certain part of the
formula without affecting the rest just select that part, change into
scalar mode and press `=' to resimplify the part under this mode, then
change back to matrix mode before deselecting.



File: calc.info, Node: Automatic Recomputation, Next: Working Message, Prev: Matrix Mode, Up: Calculation Modes

Automatic Recomputation
-----------------------

The "evaluates-to" operator, `=>', has the special property that any
`=>' formulas on the stack are recomputed whenever variable values or
mode settings that might affect them are changed.  *Note Evaluates-To
Operator::.

The `m C' (`calc-auto-recompute') command turns this automatic
recomputation on and off.  If you turn it off, Calc will not update
`=>' operators on the stack (nor those in the attached Embedded Mode
buffer, if there is one).  They will not be updated unless you
explicitly do so by pressing `=' or until you press `m C' to turn
recomputation back on.  (While automatic recomputation is off, you can
think of `m C m C' as a command to update all `=>' operators while
leaving recomputation off.)

To update `=>' operators in an Embedded buffer while
automatic recomputation is off, use `M-# u'.
*Note Embedded Mode::.



File: calc.info, Node: Working Message, Prev: Automatic Recomputation, Up: Calculation Modes

Working Messages
----------------

Since the Calculator is written entirely in Emacs Lisp, which is not
designed for heavy numerical work, many operations are quite slow.
The Calculator normally displays the message `Working...' in the echo
area during any command that may be slow.  In addition, iterative
operations such as square roots and trigonometric functions display
the intermediate result at each step.  Both of these types of messages
can be disabled if you find them distracting.

Type `m w' (`calc-working') with a numeric prefix of 0 to disable all
working" messages.  Use a numeric prefix of 1 to enable only the plain
`Working...' message.  Use a numeric prefix of 2 to see intermediate
results as well.  With no numeric prefix this displays the current
mode.

While it may seem that the "working" messages will slow Calc down
considerably, experiments have shown that their impact is actually
quite small.  But if your terminal is slow you may find that it helps
to turn the messages off.



File: calc.info, Node: Simplification Modes, Next: Declarations, Prev: Calculation Modes, Up: Mode Settings

Simplification Modes
====================

The current "simplification mode" controls how numbers and formulas
are "normalized" when being taken from or pushed onto the stack.  Some
normalizations are unavoidable, such as rounding floating-point
results to the current precision, and reducing fractions to simplest
form.  Others, such as simplifying a formula like `a+a' (or `2+3'),
are done by default but can be turned off when necessary.

When you press a key like `+' when `2' and `3' are on the stack, Calc
pops these numbers, normalizes them, creates the formula `2+3',
normalizes it, and pushes the result.  Of course the standard rules
for normalizing `2+3' will produce the result `5'.

Simplification mode commands consist of the lower-case `m' prefix key
followed by a shifted letter.

The `m O' (`calc-no-simplify-mode') command turns off all optional
simplifications.  These would leave a formula like `2+3' alone.  In
fact, nothing except simple numbers are ever affected by normalization
in this mode.

The `m N' (`calc-num-simplify-mode') command turns off simplification
of any formulas except those for which all arguments are constants.
For example, `1+2' is simplified to `3', and `a+(2-2)' is simplified
to `a+0' but no further, since one argument of the sum is not a
constant.  Unfortunately, `(a+2)-2' is *not* simplified because the
top-level `-' operator's arguments are not both constant numbers (one
of them is the formula `a+2').  A constant is a number or other
numeric object (such as a constant error form or modulo form), or a
vector all of whose elements are constant.

The `m D' (`calc-default-simplify-mode') command restores the
default simplifications for all formulas.  This includes many easy and
fast algebraic simplifications such as `a+0' to `a', and
`a + 2 a' to `3 a', as well as evaluating functions like
`deriv(x^2, x)' to `2 x'.

The `m B' (`calc-bin-simplify-mode') mode applies the default
simplifications to a result and then, if the result is an integer,
uses the `b c' (`calc-clip') command to clip the integer according to
the current binary word size.  *Note Binary Functions::.  Real numbers
are rounded to the nearest integer and then clipped; other kinds of
results (after the default simplifications) are left alone.

The `m A' (`calc-alg-simplify-mode') mode does algebraic
simplification; it applies all the default simplifications, and also
the more powerful (and slower) simplifications made by `a s'
(`calc-simplify').  *Note Algebraic Simplifications::.

The `m E' (`calc-ext-simplify-mode') mode does "extended" algebraic
simplification, as by the `a e' (`calc-simplify-extended') command.
*Note Unsafe Simplifications::.

The `m U' (`calc-units-simplify-mode') mode does units simplification;
it applies the command `u s' (`calc-simplify-units'), which in turn is
a superset of `a s'.  In this mode, variable names which are
identifiable as unit names (like `mm' for "millimeters") are
simplified with their unit definitions in mind.

A common technique is to set the simplification mode down to the
lowest amount of simplification you will allow to be applied
automatically, then use manual commands like `a s' and `c c'
(`calc-clean') to perform higher types of simplifications on demand.
*Note Algebraic Definitions::, for another sample use of
no-simplification mode.



File: calc.info, Node: Declarations, Next: Display Modes, Prev: Simplification Modes, Up: Mode Settings

Declarations
============

A "declaration" is a statement you make that promises you will use a
certain variable or function in a restricted way.  This may give Calc
the freedom to do things that it couldn't do if it had to take the
fully general situation into account.

* Menu:

* Declaration Basics::
* Kinds of Declarations::
* Functions for Declarations::



File: calc.info, Node: Declaration Basics, Next: Kinds of Declarations, Prev: Declarations, Up: Declarations

Declaration Basics
------------------

The `s d' (`calc-declare-variable') command is the easiest way to make
a declaration for a variable.  This command prompts for the variable
name, then prompts for the declaration.  The default at the
declaration prompt is the previous declaration, if any.  You can edit
this declaration, or press `C-k' to erase it and type a new
declaration.  (Or, erase it and press RET to clear the declaration,
effectively "undeclaring" the variable.)

A declaration is in general a vector of "type symbols" and "range"
values.  If there is only one type symbol or range value, you can
write it directly rather than enclosing it in a vector.  For example,
`s d foo RET real RET' declares `foo' to be a real number, and `s d
bar RET [int, const, [1..6]] RET' declares `bar' to be a constant
integer between 1 and 6.  (Actually, you can omit the outermost
brackets and Calc will provide them for you: `s d bar RET int, const,
[1..6] RET'.)

Declarations in Calc are kept in a special variable called `Decls'.
This variable encodes the set of all outstanding declarations in the
form of a matrix.  Each row has two elements: A variable or vector of
variables declared by that row, and the declaration specifier as
described above.  You can use the `s D' command to edit this variable
if you wish to see all the declarations at once.  *Note Operations on
Variables::, for a description of this command and the `s p' command
that allows you to save your declarations permanently if you wish.

Items being declared can also be function calls.  The arguments in the
call are ignored; the effect is to say that this function returns
values of the declared type for any valid arguments.  The `s d'
command declares only variables, so if you wish to make a function
declaration you will have to edit the `Decls' matrix yourself.

For example, the declaration matrix

     [ [ foo,       real       ]
       [ [j, k, n], int        ]
       [ f(1,2,3),  [0 .. inf) ] ]

declares that `foo' represents a real number, `j', `k' and `n'
represent integers, and the function `f' always returns a real number
in the interval shown.

If there is a declaration for the variable `All', then that
declaration applies to all variables that are not otherwise declared.
It does not apply to function names.  For example, using the row
`[All, real]' says that all your variables are real unless they are
explicitly declared without `real' in some other row.  The `s d'
command declares `All' if you give a blank response to the
variable-name prompt.



File: calc.info, Node: Kinds of Declarations, Next: Functions for Declarations, Prev: Declaration Basics, Up: Declarations

Kinds of Declarations
---------------------

The type-specifier part of a declaration (that is, the second prompt
in the `s d' command) can be a type symbol, an interval, or a vector
consisting of zero or more type symbols followed by zero or more
intervals or numbers that represent the set of possible values for the
variable.

     [ [ a, [1, 2, 3, 4, 5] ]
       [ b, [1 .. 5]        ]
       [ c, [int, 1 .. 5]   ] ]

Here `a' is declared to contain one of the five integers shown; `b' is
any number in the interval from 1 to 5 (any real number since we
haven't specified), and `c' is any integer in that interval.  Thus the
declarations for `a' and `c' are nearly equivalent (see below).

The type-specifier can be the empty vector `[]' to say that
nothing is known about a given variable's value.  This is the same
as not declaring the variable at all except that it overrides any
`All' declaration which would otherwise apply.

The initial value of `Decls' is the empty vector `[]'.  If `Decls' has
no stored value or if the value stored in it is not valid, it is
ignored and there are no declarations as far as Calc is concerned.
(The `s d' command will replace such a malformed value with a fresh
empty matrix, `[]', before recording the new declaration.)
Unrecognized type symbols are ignored.

The following type symbols describe what sorts of numbers will be
stored in a variable:

`int'
     Integers.
`numint'
     Numerical integers.  (Integers or integer-valued floats.)
`frac'
     Fractions.  (Rational numbers which are not integers.)
`rat'
     Rational numbers.  (Either integers or fractions.)
`float'
     Floating-point numbers.
`real'
     Real numbers.  (Integers, fractions, or floats.  Actually,
     intervals and error forms with real components also count as
     reals here.)
`pos'
     Positive real numbers.  (Strictly greater than zero.)
`nonneg'
     Nonnegative real numbers.  (Greater than or equal to zero.)
`number'
     Numbers.  (Real or complex.)

Calc uses this information to determine when certain simplifications
of formulas are safe.  For example, `(x^y)^z' cannot be simplified to
`x^(y z)' in general; for example, `((-3)^2)^1:2' is 3, but
`(-3)^(2*1:2) = (-3)^1' is -3.  However, this simplification *is* safe
if `z' is known to be an integer, or if `x' is known to be a
nonnegative real number.  If you have given declarations that allow
Calc to deduce either of these facts, Calc will perform this
simplification of the formula.

Calc can apply a certain amount of logic when using declarations.  For
example, `(x^y)^(2n+1)' will be simplified if `n' has been declared
`int'; Calc knows that an integer times an integer, plus an integer,
must always be an integer.  (In fact, Calc would simplify
`(-x)^(2n+1)' to `-(x^(2n+1))' since it is able to determine that
`2n+1' must be an odd integer.)

Similarly, `(abs(x)^y)^z' will be simplified to `abs(x)^(y z)'
because Calc knows that the `abs' function always returns a
nonnegative real.  If you had a `myabs' function that also had
this property, you could get Calc to recognize it by adding the row
`[myabs(), nonneg]' to the `Decls' matrix.

One instance of this simplification is `sqrt(x^2)' (since the `sqrt'
function is effectively a one-half power).  Normally Calc leaves this
formula alone.  After the command `s d x RET real RET', however, it
can simplify the formula to `abs(x)'.  And after `s d x RET nonneg
RET', Calc can simplify this formula all the way to `x'.

If there are any intervals or real numbers in the type specifier,
they comprise the set of possible values that the variable or
function being declared can have.  In particular, the type symbol
`real' is effectively the same as the range `[-inf .. inf]'
(note that infinity is included in the range of possible values);
`pos' is the same as `(0 .. inf]', and `nonneg' is
the same as `[0 .. inf]'.  Saying `[real, [-5 .. 5]]' is
redundant because the fact that the variable is real can be
deduced just from the interval, but `[int, [-5 .. 5]]' and
`[rat, [-5 .. 5]]' are useful combinations.

Note that the vector of intervals or numbers is in the same format
used by Calc's set-manipulation commands.  *Note Set Operations::.

The type specifier `[1, 2, 3]' is equivalent to `[numint, 1, 2, 3]',
*not* to `[int, 1, 2, 3]'.  In other words, the range of possible
values means only that the variable's value must be numerically equal
to a number in that range, but not that it must be equal in type as
well.  Calc's set operations act the same way; `in(2, [1., 2., 3.])'
and `in(1.5, [1:2, 3:2, 5:2])' both report "true."

If you use a conflicting combination of type specifiers, the results
are unpredictable.  An example is `[pos, [0 .. 5]]', where the
interval does not lie in the range described by the type symbol.

"Real" declarations mostly affect simplifications involving powers
like the one described above.  Another case where they are used is in
the `a P' command which returns a list of all roots of a polynomial;
if the variable has been declared real, only the real roots (if any)
will be included in the list.

"Integer" declarations are used for simplifications which are valid
only when certain values are integers (such as `(x^y)^z' shown above).

Another command that makes use of declarations is `a s', when
simplifying equations and inequalities.  It will cancel `x' from both
sides of `a x = b x' only if it is sure `x' is non-zero, say, because
it has a `pos' declaration.  To declare specifically that `x' is real
and non-zero, use `[[-inf .. 0), (0 .. inf]]'.  (There is no way in
the current notation to say that `x' is nonzero but not necessarily
real.)  The `a e' command does "unsafe" simplifications, including
cancelling `x' from the equation when `x' is not known to be nonzero.

Another set of type symbols distinguish between scalars and vectors.

`scalar'
     The value is not a vector.
`vector'
     The value is a vector.
`matrix'
     The value is a matrix (a rectangular vector of vectors).

These type symbols can be combined with the other type symbols
described above; `[int, matrix]' describes an object which is a matrix
of integers.

Scalar/vector declarations are used to determine whether certain
algebraic operations are safe.  For example, `[a, b, c] + x' is
normally not simplified to `[a + x, b + x, c + x]', but it will be if
`x' has been declared `scalar'.  On the other hand, multiplication is
usually assumed to be commutative, but the terms in `x y' will never
be exchanged if both `x' and `y' are known to be vectors or matrices.
(Calc currently never distinguishes between `vector' and `matrix'
declarations.)

*Note Matrix Mode::, for a discussion of "matrix mode" and "scalar
mode," which are similar to declaring `[All, matrix]' or `[All,
scalar]' but much more convenient.

One more type symbol that is recognized is used with the `H a d'
command for taking total derivatives of a formula.  *Note Calculus::.

`const'
     The value is a constant with respect to other variables.

Calc does not check the declarations for a variable when you store a
value in it.  However, storing -3.5 in a variable that has been
declared `pos', `int', or `matrix' may have unexpected effects; Calc
may evaluate `sqrt(x^2)' to `3.5' if it substitutes the value first,
or to `-3.5' if `x' was declared `pos' and the formula `sqrt(x^2)' is
simplified to `x' before the value is substituted.  Before using a
variable for a new purpose, it is best to use `s d' or `s D' to check
to make sure you don't still have an old declaration for the variable
that will conflict with its new meaning.



