Info file: calc.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `calc.texinfo'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the author
instead of in the original English.




File: calc.info, Node: Interpolation, Prev: Curve Fitting Details, Up: Curve Fitting

Polynomial Interpolation
------------------------

The `a p' (`calc-poly-interp') [`polint'] command does a polynomial
interpolation at a particular `x' value.  It takes two arguments from
the stack: A data matrix of the sort used by `a F', and a single
number which represents the desired `x' value.  Calc effectively does
an exact polynomial fit as if by `a F i', then substitutes the `x'
value into the result in order to get an approximate `y' value based
on the fit.  (Calc does not actually use `a F i', however; it uses a
direct method which is both more efficient and more numerically
stable.)

The result of `a p' is actually a vector of two values: The `y' value
approximation, and an error measure `dy' that reflects Calc's
estimation of the probable error of the approximation at that value of
`x'.  If the input `x' is equal to any of the `x' values in the data
matrix, the output `y' will be the corresponding `y' value from the
matrix, and the output `dy' will be exactly zero.

A prefix argument of 2 causes `a p' to take separate x- and y-vectors
from the stack instead of one data matrix.

If `x' is a vector of numbers, `a p' will return a matrix of
interpolated results for each of those `x' values.  (The matrix will
have two columns, the `y' values and the `dy' values.)  If `x' is a
formula instead of a number, the `polint' function remains in symbolic
form; use the `a "' command to expand it out to a formula that
describes the fit in symbolic terms.

In all cases, the `a p' command leaves the data vectors or matrix on
the stack.  Only the `x' value is replaced by the result.

The `H a p' [`ratint'] command does a rational function interpolation.
It is used exactly like `a p', except that it uses as its model the
quotient of two polynomials.  If there are `N' data points, the
numerator and denominator polynomials will each have degree `N/2' (if
`N' is odd, the denominator will have degree one higher than the
numerator).

Rational approximations have the advantage that they can accurately
describe functions that have poles (points at which the function's
value goes to infinity, so that the denominator polynomial of the
approximation goes to zero).  If `x' corresponds to a pole of the
fitted rational function, then the result will be a division by zero.
If Infinite mode is enabled, the result will be `[uinf, uinf]'.

There is no way to get the actual coefficients of the rational function
used by `H a p'.  (The algorithm never generates these coefficients
explicitly, and quotients of polynomials are beyond `a F''s
capabilities to fit.)



File: calc.info, Node: Summations, Next: Logical Operations, Prev: Curve Fitting, Up: Algebra

Summations
==========

The `a +' (`calc-summation') [`sum'] command computes the sum of a
formula over a certain range of index values.  The formula is taken
from the top of the stack; the command prompts for the name of the
summation index variable, the lower limit of the sum (any formula),
and the upper limit of the sum.  If you enter a blank line at any of
these prompts, that prompt and any later ones are answered by reading
additional elements from the stack.  Thus, `' k^2 RET ' k RET 1 RET 5
RET a + RET' produces the result 55.

The choice of index variable is arbitrary, but it's best not to
use a variable with a stored value.  In particular, while
`i' is often a favorite index variable, it should be avoided
in Calc because `i' has the imaginary constant `(0, 1)'
as a value.  If you pressed `=' on a sum over `i', it would
be changed to a nonsensical sum over the "variable" `(0, 1)'!
If you really want to use `i' as an index variable, use
`s u i RET' first to "unstore" this variable.
(*Note Storing Variables::.)

A numeric prefix argument steps the index by that amount rather than
by one.  Thus `' a_k RET C-u -2 a + k RET 10 RET 0 RET' yields `a_10 +
a_8 + a_6 + a_4 + a_2 + a_0'.  A prefix argument of plain `C-u' causes
`a +' to prompt for the step value, in which case you can enter any
formula or enter a blank line to take the step value from the stack.
With the `C-u' prefix, `a +' can take up to five arguments from the
stack: The formula, the variable, the lower limit, the upper limit,
and (at the top of the stack), the step value.

Calc knows how to do certain sums in closed form.  For example,
`sum(6 k^2, k, 1, n) = 2 n^3 + 3 n^2 + n'.  In particular,
this is possible if the formula being summed is polynomial or
exponential in the index variable.  Sums of logarithms are
transformed into logarithms of products.  Sums of trigonometric
and hyperbolic functions are transformed to sums of exponentials
and then done in closed form.  Also, of course, sums in which the
lower and upper limits are both numbers can always be evaluated
just by grinding them out, although Calc will use closed forms
whenever it can for the sake of efficiency.

The notation for sums in algebraic formulas is `sum(EXPR, VAR, LOW,
HIGH, STEP)'.  If STEP is omitted, it defaults to one.  If HIGH is
omitted, LOW is actually the upper limit and the lower limit is one.
If LOW is also omitted, the limits are `-inf' and `inf', respectively.

Infinite sums can sometimes be evaluated: `sum(.5^k, k, 1, inf)'
returns `1'.  This is done by evaluating the sum in closed form (to
`1. - 0.5^n' in this case), then evaluating this formula with `n' set
to `inf'.  Calc's usual rules for "infinite" arithmetic can find the
answer from there.  If infinite arithmetic yields a `nan', or if the
sum cannot be solved in closed form, Calc leaves the `sum' function in
symbolic form.  *Note Infinities::.

As a special feature, if the limits are infinite (or omitted, as
described above) but the formula includes vectors subscripted by
expressions that involve the iteration variable, Calc narrows
the limits to include only the range of integers which result in
legal subscripts for the vector.  For example, the sum
`sum(k [a,b,c,d,e,f,g]_(2k),k)' evaluates to `b + 2 d + 3 f'.

The limits of a sum do not need to be integers.  For example,
`sum(a_k, k, 0, 2 n, n)' produces `a_0 + a_n + a_(2 n)'.  Calc
computes the number of iterations using the formula `1 + (HIGH - LOW)
/ STEP', which must, after simplification as if by `a s', evaluate to
an integer.

If the number of iterations according to the above formula does not
come out to an integer, the sum is illegal and will be left in
symbolic form.  However, closed forms are still supplied, and you are
on your honor not to misuse the resulting formulas by substituting
mismatched bounds into them.  For example, `sum(k, k, 1, 10, 2)' is
invalid, but Calc will go ahead and evaluate the closed form solution
for the limits 1 and 10 to get the rather dubious answer, 29.25.

If the lower limit is greater than the upper limit (assuming a
positive step size), the result is generally zero.  However, Calc only
guarantees a zero result when the upper limit is exactly one step less
than the lower limit, i.e., if the number of iterations is -1.  Thus
`sum(f(k), k, n, n-1)' is zero but the sum from `n' to `n-2' may
report a nonzero value if Calc used a closed form solution.

Calc's logical predicates like `a < b' return 1 for "true" and 0 for
false."  *Note Logical Operations::.  This can be used to advantage
for building conditional sums.  For example, `sum(prime(k)*k^2, k, 1,
20)' is the sum of the squares of all prime numbers from 1 to 20; the
`prime' predicate returns 1 if its argument is prime and 0 otherwise.
You can read this expression as "the sum of `k^2', where `k' is
prime."  Indeed, `sum(prime(k)*k^2, k)' would represent the sum of
*all* primes squared, since the limits default to plus and minus
infinity, but there are no such sums that Calc's built-in rules can do
in closed form.

As another example, `sum((k != k_0) * f(k), k, 1, n)' is the sum of
`f(k)' for all `k' from 1 to `n', excluding one value `k_0'.  Slightly
more tricky is the summand `(k != k_0) / (k - k_0)', which is an
attempt to describe the sum of all `1/(k-k_0)' except at `k = k_0',
where this would be a division by zero.  But at `k = k_0', this
formula works out to the indeterminate form `0 / 0', which Calc will
not assume is zero.  Better would be to use `(k != k_0) ? 1/(k-k_0) :
0'; the `? :' operator does an "if-then-else" test: This expression
says, "if `k != k_0', then `1/(k-k_0)', else zero."  Now the formula
`1/(k-k_0)' will not even be evaluated by Calc when `k = k_0'.

The `a -' (`calc-alt-summation') [`asum'] command computes an
alternating sum.  Successive terms of the sequence are given
alternating signs, with the first term (corresponding to the lower
index value) being positive.  Alternating sums are converted to normal
sums with an extra term of the form `(-1)^(k-LOW)'.  This formula is
adjusted appropriately if the step value is other than one.  For
example, the Taylor series for the sine function is `asum(x^k / k!, k,
1, inf, 2)'.  (Calc cannot evaluate this infinite series, but it can
approximate it if you replace `inf' with any particular odd number.)
Calc converts this series to a regular sum with a step of one, namely
`sum((-1)^k x^(2k+1) / (2k+1)!, k, 0, inf)'.

The `a *' (`calc-product') [`prod'] command is the analogous way to
take a product of many terms.  Calc also knows some closed forms for
products, such as `prod(k, k, 1, n) = n!'.  Conditional products can
be written `prod(k^prime(k), k, 1, n)' or `prod(prime(k) ? k : 1, k,
1, n)'.

The `a T' (`calc-tabulate') [`table'] command evaluates a formula at a
series of iterated index values, just like `sum' and `prod', but its
result is simply a vector of the results.  For example, `table(a_i, i,
1, 7, 2)' produces `[a_1, a_3, a_5, a_7]'.



File: calc.info, Node: Logical Operations, Next: Rewrite Rules, Prev: Summations, Up: Algebra

Logical Operations
==================

The following commands and algebraic functions return true/false values,
where 1 represents "true" and 0 represents "false."  In cases where
a truth value is required (such as for the condition part of a rewrite
rule, or as the condition for a `Z [ Z ]' control structure), any
nonzero value is accepted to mean "true."  (Specifically, anything
for which `dnonzero' returns 1 is "true," and anything for
which `dnonzero' returns 0 or cannot decide is assumed "false."
Note that this means that `Z [ Z ]' will execute the "then"
portion if its condition is provably true, but it will execute the
"else" portion for any condition like `a = b' that is not
provably true, even if it might be true.  Algebraic functions that
have conditions as arguments, like `? :' and `&&', remain
unevaluated if the condition is neither provably true nor provably
false.  *Note Declarations::.)

The `a =' (`calc-equal-to') command, or `eq(a,b)' function (which can
also be written `a = b' or `a == b' in an algebraic formula) is true
if `a' and `b' are equal, either because they are identical
expressions, or because they are numbers which are numerically equal.
(Thus the integer 1 is considered equal to the float 1.0.)  If the
equality of `a' and `b' cannot be determined, the comparison is left
in symbolic form.  Note that as a command, this operation pops two
values from the stack and pushes back either a 1 or a 0, or a formula
`a = b' if the values' equality cannot be determined.

Many Calc commands use `=' formulas to represent "equations".  For
example, the `a S' (`calc-solve-for') command rearranges an equation
to solve for a given variable.  The `a M' (`calc-map-equation')
command can be used to apply any function to both sides of an
equation; for example, `2 a M *' multiplies both sides of the equation
by two.  Note that just `2 *' would not do the same thing; it would
produce the formula `2 (a = b)' which represents 2 if the equality is
true or zero if not.

The `eq' function with more than two arguments (e.g., `C-u 3 a =' or
`a = b = c') tests if all of its arguments are equal.  In algebraic
notation, the `=' operator is unusual in that it is neither left- nor
right-associative: `a = b = c' is not the same as `(a = b) = c' or
`a = (b = c)' (which each compare one variable with the 1 or 0 that
results from comparing two other variables).

The `a #' (`calc-not-equal-to') command, or `neq(a,b)' or `a != b'
function, is true if `a' and `b' are not equal.  This also works with
more than two arguments; `a != b != c != d' tests that all four of
`a', `b', `c', and `d' are distinct numbers.

The `a <' (`calc-less-than') [`lt(a,b)' or `a < b']
operation is true if `a' is less than `b'.  Similar functions
are `a >' (`calc-greater-than') [`gt(a,b)' or `a > b'],
`a [' (`calc-less-equal') [`leq(a,b)' or `a <= b'], and
`a ]' (`calc-greater-equal') [`geq(a,b)' or `a >= b'].

While the inequality functions like `lt' do not accept more
than two arguments, the syntax `a <= b < c' is translated to an
equivalent expression involving intervals: `b in [a .. c)'.
(See the description of `in' below.)  All four combinations
of `<' and `<=' are allowed, or any of the four combinations
of `>' and `>='.  Four-argument constructions like
`a < b < c < d', and mixtures like `a < b = c' that
involve both equalities and inequalities, are not allowed.

The `a .' (`calc-remove-equal') [`rmeq'] command extracts the
righthand side of the equation or inequality on the top of the stack.
It also works elementwise on vectors.  For example, if `[x = 2.34, y =
z / 2]' is on the stack, then `a .' produces `[2.34, z / 2]'.  As a
special case, if the righthand side is a variable and the lefthand
side is a number (as in `2.34 = x'), then Calc keeps the lefthand side
instead.  Finally, this command works with assignments `x := 2.34' as
well as equations, always taking the the righthand side, and for `=>'
(evaluates-to) operators, always taking the lefthand side.

The `a &' (`calc-logical-and') [`land(a,b)' or `a && b'] function is
true if both of its arguments are true, i.e., are non-zero numbers.
In this case, the result will be either `a' or `b', chosen
arbitrarily.  If either argument is zero, the result is zero.
Otherwise, the formula is left in symbolic form.

The `a |' (`calc-logical-or') [`lor(a,b)' or `a || b'] function is
true if either or both of its arguments are true (nonzero).  The
result is whichever argument was nonzero, choosing arbitrarily if both
are nonzero.  If both `a' and `b' are zero, the result is zero.

The `a !' (`calc-logical-not') [`lnot(a)' or `! a'] function is true
if `a' is false (zero), or false if `a' is true (nonzero).  It is left
in symbolic form if `a' is not a number.

The `a :' (`calc-logical-if') [`if(a,b,c)' or `a ? b : c']
function is equal to either `b' or `c' if `a' is a nonzero
number or zero, respectively.  If `a' is not a number, the test is
left in symbolic form and neither `b' nor `c' is evaluated in
any way.  In algebraic formulas, this is one of the few Calc functions
whose arguments are not automatically evaluated when the function itself
is evaluated.  The others are `lambda', `quote', and
`condition'.

One minor surprise to watch out for is that the formula `a?3:4'
will not work because the `3:4' is parsed as a fraction instead of
as three separate symbols.  Type something like `a ? 3 : 4' or
`a?(3):4' instead.

As a special case, if `a' evaluates to a vector, then both `b' and `c'
are evaluated; the result is a vector of the same length as `a' whose
elements are chosen from corresponding elements of `b' and `c'
according to whether each element of `a' is zero or nonzero.  Each of
`b' and `c' must be either a vector of the same length as `a', or a
non-vector which is matched with all elements of `a'.

The `a {' (`calc-in-set') [`in(a,b)'] function is true if the number
`a' is in the set of numbers represented by `b'.  If `b' is an
interval form, `a' must be one of the values encompassed by the
interval.  If `b' is a vector, `a' must be equal to one of the
elements of the vector.  (If any vector elements are intervals, `a'
must be in any of the intervals.)  If `b' is a plain number, `a' must
be numerically equal to `b'.  *Note Set Operations::, for a group of
commands that manipulate sets of this sort.

The `typeof(a)' function produces an integer or variable which
characterizes `a'.  If `a' is a number, vector, or variable, the
result will be one of the following numbers:

      1   Integer
      2   Fraction
      3   Floating-point number
      4   HMS form
      5   Rectangular complex number
      6   Polar complex number
      7   Error form
      8   Interval form
      9   Modulo form
     10   Date-only form
     11   Date/time form
     12   Infinity (inf, uinf, or nan)
     100  Variable
     101  Vector (but not a matrix)
     102  Matrix

Otherwise, `a' is a formula, and the result is a variable which
represents the name of the top-level function call.

The `integer(a)' function returns true if `a' is an integer.  The
`real(a)' function is true if `a' is a real number, either integer,
fraction, or float.  The `constant(a)' function returns true if `a' is
any of the objects for which `typeof' would produce an integer code
result except for variables, and provided that the components of an
object like a vector or error form are themselves constant.  Note that
infinities do not satisfy any of these tests, nor do special constants
like `pi' and `e'.

*Note Declarations::, for a set of similar functions that recognize
formulas as well as actual numbers.  For example, `dint(floor(x))' is
true because `floor(x)' is provably integer-valued, but
`integer(floor(x))' does not because `floor(x)' is not literally an
integer constant.

The `refers(a,b)' function is true if the variable (or sub-expression)
`b' appears in `a', or false otherwise.  Unlike the other tests
described here, this function returns a definite "no" answer even if
its arguments are still in symbolic form.  The only case where
`refers' will be left unevaluated is if `a' is a plain variable
(different from `b').

The `negative(a)' function returns true if `a' "looks" negative,
because it is a negative number, because it is of the form `-x', or
because it is a product or quotient with a term that looks negative.
This is most useful in rewrite rules.  Beware that `negative(a)'
evaluates to 1 or 0 for *any* argument `a', so it can only be stored
in a formula if the default simplifications are turned off first with
`m O' (or if it appears in an unevaluated context such as a rewrite
rule condition).

The `variable(a)' function is true if `a' is a variable, or false if
not.  If `a' is a function call, this test is left in symbolic form.
Built-in variables like `pi' and `inf' are considered variables like
any others by this test.

The `nonvar(a)' function is true if `a' is a non-variable.  If its
argument is a variable it is left unsimplified; it never actually
returns zero.  However, since Calc's condition-testing commands
consider "false" anything not provably true, this is often good
enough.

The functions `lin', `linnt', `islin', and `islinnt' check if an
expression is "linear," i.e., can be written in the form `a + b x' for
some constants `a' and `b', and some variable or subformula `x'.  The
function `islin(f,x)' checks if formula `f' is linear in `x',
returning 1 if so.  For example, `islin(x,x)', `islin(-x,x)',
`islin(3,x)', and `islin(x y / 3 - 2, x)' all return 1.  The
`lin(f,x)' function is similar, except that instead of returning 1 it
returns the vector `[a, b, x]'.  For the above examples, this vector
would be `[0, 1, x]', `[0, -1, x]', `[3, 0, x]', and `[-2, y/3, x]',
respectively.  Both `lin' and `islin' generally remain unevaluated for
expressions which are not linear, e.g., `lin(2 x^2, x)' and
`lin(sin(x), x)'.  The second argument can also be a formula; `islin(2
+ 3 sin(x), sin(x))' returns true.

The `linnt' and `islinnt' functions perform a similar check, but
require a "non-trivial" linear form, which means that the `b'
coefficient must be non-zero.  For example, `lin(2,x)' returns `[2, 0,
x]' and `lin(y,x)' returns `[y, 0, x]', but `linnt(2,x)' and
`linnt(y,x)' are left unevaluated (in other words, these formulas are
considered to be only "trivially" linear in `x').

All four linearity-testing functions allow you to omit the second
argument, in which case the input may be linear in any non-constant
formula.  Here, the `a=0', `b=1' case is also considered trivial, and
only constant values for `a' and `b' are recognized.  Thus, `lin(2 x
y)' returns `[0, 2, x y]', `lin(2 - x y)' returns `[2, -1, x y]', and
`lin(x y)' returns `[0, 1, x y]'.  The `linnt' function would allow
the first two cases but not the third.  Also, neither `lin' nor
`linnt' accept plain constants as linear in the one-argument case:
`islin(2,x)' is true, but `islin(2)' is false.

The `istrue(a)' function returns 1 if `a' is a nonzero number or
provably nonzero formula, or 0 if `a' is anything else.  Calls to
`istrue' can only be manipulated if `m O' mode is used to make sure
they are not evaluated prematurely.  (Note that declarations are used
when deciding whether a formula is true; `istrue' returns 1 when
`dnonzero' would return 1, and it returns 0 when `dnonzero' would
return 0 or leave itself in symbolic form.)



File: calc.info, Node: Rewrite Rules, Prev: Logical Operations, Up: Algebra

Rewrite Rules
=============

The `a r' (`calc-rewrite') [`rewrite'] command makes substitutions in
a formula according to a specified pattern or patterns known as
rewrite rules".  Whereas `a b' (`calc-substitute') matches literally,
so that substituting `sin(x)' with `cos(x)' matches only the `sin'
function applied to the variable `x', rewrite rules match general
kinds of formulas; rewriting using the rule `sin(x) := cos(x)' matches
`sin' of any argument and replaces it with `cos' of that same
argument.  The only significance of the name `x' is that the same name
is used on both sides of the rule.

Rewrite rules rearrange formulas already in Calc's memory.  *Note
Syntax Tables::, to read about "syntax rules", which are similar to
algebraic rewrite rules but operate when new algebraic entries are
being parsed, converting strings of characters into Calc formulas.

* Menu:

* Entering Rewrite Rules::
* Basic Rewrite Rules::
* Conditional Rewrite Rules::
* Algebraic Properties of Rewrite Rules::
* Other Features of Rewrite Rules::
* Composing Patterns in Rewrite Rules::
* Nested Formulas with Rewrite Rules::
* Multi-Phase Rewrite Rules::
* Selections with Rewrite Rules::
* Matching Commands::
* Automatic Rewrites::
* Debugging Rewrites::
* Examples of Rewrite Rules::



File: calc.info, Node: Entering Rewrite Rules, Next: Basic Rewrite Rules, Prev: Rewrite Rules, Up: Rewrite Rules

Entering Rewrite Rules
----------------------

Rewrite rules normally use the "assignment" operator `OLD := NEW'.
This operator is equivalent to the function call `assign(old, new)'.
The `assign' function is undefined by itself in Calc, so an assignment
formula such as a rewrite rule will be left alone by ordinary Calc
commands.  But certain commands, like the rewrite system, interpret
assignments in special ways.

For example, the rule `sin(x)^2 := 1-cos(x)^2' says to replace every
occurrence of the sine of something, squared, with one minus the
square of the cosine of that same thing.  All by itself as a formula
on the stack it does nothing, but when given to the `a r' command it
turns that command into a sine-squared-to-cosine-squared converter.

To specify a set of rules to be applied all at once, make a vector of
rules.

When `a r' prompts you to enter the rewrite rules, you can answer in
several ways:

  1. With a rule: `f(x) := g(x) RET'.
  2. With a vector of rules: `[f1(x) := g1(x), f2(x) := g2(x)] RET'.
     (You can omit the enclosing square brackets if you wish.)
  3. With the name of a variable that contains the rule or rules vector:
     `myrules RET'.
  4. With any formula except a rule, a vector, or a variable name; this
     will be interpreted as the OLD half of a rewrite rule,
     and you will be prompted a second time for the NEW half:
     `f(x) RET g(x) RET'.
  5. With a blank line, in which case the rule, rules vector, or
     variable will be taken from the top of the stack (and the formula
     to be rewritten will come from the second-to-top position).

If you enter the rules directly (as opposed to using rules stored in a
variable), those rules will be put into the Trail so that you can
retrieve them later.  *Note Trail Commands::.

It is most convenient to store rules you use often in a variable and
invoke them by giving the variable name.  The `s e'
(`calc-edit-variable') command is an easy way to create or edit a rule
set stored in a variable.  You may also wish to use `s p'
(`calc-permanent-variable') to save your rules permanently; *Note
Operations on Variables::.

Rewrite rules are compiled into a special internal form for faster
matching.  If you enter a rule set directly it must be recompiled
every time.  If you store the rules in a variable and refer to them
through that variable, they will be compiled once and saved away along
with the variable for later reference.  This is another good reason to
store your rules in a variable.

Calc also accepts an obsolete notation for rules, as vectors `[OLD,
NEW]'.  But because it is easily confused with a vector of two rules,
the use of this notation is no longer recommended.



File: calc.info, Node: Basic Rewrite Rules, Next: Conditional Rewrite Rules, Prev: Entering Rewrite Rules, Up: Rewrite Rules

Basic Rewrite Rules
-------------------

To match a particular formula `x' with a particular rewrite rule `OLD
:= NEW', Calc compares the structure of `x' with the structure of OLD.
Variables that appear in OLD are treated as "meta-variables"; the
corresponding positions in `x' may contain any sub-formulas.  For
example, the pattern `f(x,y)' would match the expression `f(12, a+1)'
with the meta-variable `x' corresponding to 12 and with `y'
corresponding to `a+1'.  However, this pattern would not match `f(12)'
or `g(12, a+1)', since there is no assignment of the meta-variables
that will make the pattern match these expressions.  Notice that if
the pattern is a single meta-variable, it will match any expression.

If a given meta-variable appears more than once in OLD, the
corresponding sub-formulas of `x' must be identical.  Thus the pattern
`f(x,x)' would match `f(12, 12)' and `f(a+1, a+1)' but not `f(12,
a+1)' or `f(a+b, b+a)'.  (*Note Conditional Rewrite Rules::, for a way
to match the latter.)

Things other than variables must match exactly between the pattern
and the target formula.  To match a particular variable exactly, use
the pseudo-function `quote(v)' in the pattern.  For example, the
pattern `x+quote(y)' matches `x+y', `2+y', or
`sin(a)+y'.

The special variable names `e', `pi', `i', `phi',
`gamma', `inf', `uinf', and `nan' always match
literally.  Thus the pattern `sin(d + e + f)' acts exactly like
`sin(d + quote(e) + f)'.

If the OLD pattern is found to match a given formula, that formula is
replaced by NEW, where any occurrences in NEW of meta-variables from
the pattern are replaced with the sub-formulas that they matched.
Thus, applying the rule `f(x,y) := g(y+x,x)' to `f(12, a+1)' would
produce `g(a+13, 12)'.

The normal `a r' command applies rewrite rules over and over
throughout the target formula until no further changes are possible
(up to a limit of 100 times).  Use `C-u 1 a r' to make only one change
at a time.



File: calc.info, Node: Conditional Rewrite Rules, Next: Algebraic Properties of Rewrite Rules, Prev: Basic Rewrite Rules, Up: Rewrite Rules

Conditional Rewrite Rules
-------------------------

A rewrite rule can also be "conditional", written in the form `OLD :=
NEW :: COND'.  (There is also the obsolete form `[OLD, NEW, COND]'.)
If a COND part is present in the rule, this is an additional condition
that must be satisfied before the rule is accepted.  Once OLD has been
successfully matched to the target expression, COND is evaluated (with
all the meta-variables substituted for the values they matched) and
simplified with `a s' (`calc-simplify').  If the result is a nonzero
number or any other object known to be nonzero (*Note Declarations::),
the rule is accepted.  If the result is zero or if it is a symbolic
formula that is not known to be nonzero, the rule is rejected.  *Note
Logical Operations::, for a number of functions that return 1 or 0
according to the results of various tests.

For example, the formula `n > 0' simplifies to 1 or 0 if `n' is
replaced by a positive or nonpositive number, respectively (or if `n'
has been declared to be positive or nonpositive).  Thus, the rule
`f(x,y) := g(y+x,x) :: x+y > 0' would apply to `f(0, 4)' but not to
`f(-3, 2)' or `f(12, a+1)' (assuming no outstanding declarations for
`a').  In the case of `f(-3, 2)', the condition can be shown not to be
satisfied; in the case of `f(12, a+1)', the condition merely cannot be
shown to be satisfied, but that is enough to reject the rule.

While Calc will use declarations to reason about variables in the
formula being rewritten, declarations do not apply to meta-variables.
For example, the rule `f(a) := g(a+1)' will match for any values of
`a', such as complex numbers, vectors, or formulas, even if `a' has
been declared to be real or scalar.  If you want the meta-variable `a'
to match only literal real numbers, use `f(a) := g(a+1) :: real(a)'.
If you want `a' to match only reals and formulas which are provably
real, use `dreal(a)' as the condition.

The `::' operator is a shorthand for the `condition' function; `OLD :=
NEW :: COND' is equivalent to the formula `condition(assign(OLD, NEW),
COND)'.

If you have several conditions, you can use `... :: c1 :: c2 :: c3' or
`... :: c1 && c2 && c3'.  The two are entirely equivalent.

It is also possible to embed conditions inside the pattern: `f(x ::
x>0, y) := g(y+x, x)'.  This is purely a notational convenience,
though; where a condition appears in a rule has no effect on when it
is tested.  The rewrite-rule compiler automatically decides when it is
best to test each condition while a rule is being matched.

Certain conditions are handled as special cases by the rewrite rule
system and are tested very efficiently: Where `x' is any
meta-variable, these conditions are `integer(x)', `real(x)',
`constant(x)', `negative(x)', `x >= y' where `y' is either a constant
or another meta-variable and `>=' may be replaced by any of the six
relational operators, and `x % a = b' where `a' and `b' are constants.
Other conditions, like `x >= y+1' or `dreal(x)', will be less
efficient to check since Calc must bring the whole evaluator and
simplifier into play.

An interesting property of `::' is that neither of its arguments will
be touched by Calc's default simplifications.  This is important
because conditions often are expressions that cannot safely be
evaluated early.  For example, the `typeof' function never remains in
symbolic form; entering `typeof(a)' will put the number 100 (the type
code for variables like `a') on the stack.  But putting the condition
`... :: typeof(a) = 6' on the stack is safe since `::' prevents the
`typeof' from being evaluated until the condition is actually used by
the rewrite system.

Since `::' protects its lefthand side, too, you can use a dummy
condition to protect a rule that must itself not evaluate early.  For
example, it's not safe to put `a(f,x) := apply(f, [x])' on the stack
because it will immediately evaluate to `a(f,x) := f(x)', where the
meta-variable-ness of `f' on the righthand side has been lost.  But
`a(f,x) := apply(f, [x]) :: 1' is safe, and of course the condition
`1' is always true (nonzero) so it has no effect on the functioning of
the rule.  (The rewrite compiler will ensure that it doesn't even
impact the speed of matching the rule.)



File: calc.info, Node: Algebraic Properties of Rewrite Rules, Next: Other Features of Rewrite Rules, Prev: Conditional Rewrite Rules, Up: Rewrite Rules

Algebraic Properties of Rewrite Rules
-------------------------------------

The rewrite mechanism understands the algebraic properties of
functions like `+' and `*'.  In particular, pattern matching takes the
associativity and commutativity of the following functions into
account:

     + - *  = !=  && ||  and or xor  vint vunion vxor  gcd lcm  max min  beta

For example, the rewrite rule:

     a x + b x  :=  (a + b) x

will match formulas of the form,

     a x + b x,  x a + x b,  a x + x b,  x a + b x

Rewrites also understand the relationship between the `+' and `-'
operators.  The above rewrite rule will also match the formulas,

     a x - b x,  x a - x b,  a x - x b,  x a - b x

by matching `b' in the pattern to `-b' from the formula.

Applied to a sum of many terms like `r + a x + s + b x + t', this
pattern will check all pairs of terms for possible matches.  The
rewrite will take whichever suitable pair it discovers first.

In general, a pattern using an associative operator like `a + b' will
try 2 n different ways to match a sum of n terms like `x + y + z - w'.
First, `a' is matched against each of `x', `y', `z', and `-w' in turn,
with `b' being matched to the remainders `y + z - w', `x + z - w',
etc.  If none of these succeed, then `b' is matched against each of
the four terms with `a' matching the remainder.  Half-and-half
matches, like `(x + y) + (z - w)', are not tried.

Note that `*' is not commutative when applied to matrices, but rewrite
rules pretend that it is.  If you type `m v' to enable matrix mode
(*Note Matrix Mode::), rewrite rules will match `*' literally,
ignoring its usual commutativity property.  (In the current
implementation, the associativity also vanishes--it is as if the
pattern had been enclosed in a `plain' marker; see below.)  If you are
applying rewrites to formulas with matrices, it's best to enable
matrix mode first to prevent algebraically incorrect rewrites from
occurring.

The pattern `-x' will actually match any expression.  For example, the
rule

     f(-x)  :=  -f(x)

will rewrite `f(a)' to `-f(-a)'.  To avoid this, either use a `plain'
marker as described below, or add a `negative(x)' condition.  The
`negative' function is true if its argument "looks" negative, for
example, because it is a negative number or because it is a formula
like `-x'.  The new rule using this condition is:

     f(x)  :=  -f(-x)  :: negative(x)    or, equivalently,
     f(-x)  :=  -f(x)  :: negative(-x)

In the same way, the pattern `x - y' will match the sum `a + b' by
matching `y' to `-b'.

The pattern `a b' will also match the formula `x/y' if
`y' is a number.  Thus the rule `a x + b x := (a+b) x'
will also convert `a x + x / 2' to `(a + 0.5) x' (or
`(a + 1:2) x', depending on the current fraction mode).

Calc will *not* take other liberties with `*', `/', and `^'.  For
example, the pattern `f(a b)' will not match `f(x^2)', and `f(a + b)'
will not match `f(2 x)', even though conceivably these patterns could
match with `a = b = x'.  Nor will `f(a b)' match `f(x / y)' if `y' is
not a constant, even though it could be considered to match with `a =
x' and `b = 1/y'.  The reasons are partly for efficiency, and partly
because while few mathematical operations are substantively different
for addition and subtraction, often it is preferable to treat the
cases of multiplication, division, and integer powers separately.

Even more subtle is the rule set

     [ f(a) + f(b) := f(a + b),  -f(a) := f(-a) ]

attempting to match `f(x) - f(y)'.  You might think that Calc will
view this subtraction as `f(x) + (-f(y))' and then apply the above two
rules in turn, but actually this will not work because Calc only does
this when considering rules for `+' (like the first rule in this set).
So it will see first that `f(x) + (-f(y))' does not match `f(a) +
f(b)' for any assignments of the meta-variables, and then it will see
that `f(x) - f(y)' does not match `-f(a)' for any assignment of `a'.
Because Calc tries only one rule at a time, it will not be able to
rewrite `f(x) - f(y)' with this rule set.  An explicit `f(a) - f(b)'
rule will have to be added.

Another thing patterns will *not* do is break up complex numbers.
The pattern `myconj(a + b i) := a - b i' will work for formulas
involving the special constant `i' (such as `3 - 4 i'), but
it will not match actual complex numbers like `(3, -4)'.  A version
of the above rule for complex numbers would be

     myconj(a)  :=  re(a) - im(a) (0,1)  :: im(a) != 0

(Because the `re' and `im' functions understand the properties of the
special constant `i', this rule will also work for `3 - 4 i'.  In
fact, this particular rule would probably be better without the `im(a)
!= 0' condition, since if `im(a) = 0' the righthand side of the rule
will still give the correct answer for the conjugate of a real
number.)

It is also possible to specify optional arguments in patterns.  The
rule

     opt(a) x + opt(b) (x^opt(c) + opt(d))  :=  f(a, b, c, d)

will match the formula

     5 (x^2 - 4) + 3 x

in a fairly straightforward manner, but it will also match reduced
formulas like

     x + x^2,    2(x + 1) - x,    x + x

producing, respectively,

     f(1, 1, 2, 0),   f(-1, 2, 1, 1),   f(1, 1, 1, 0)

(The latter two formulas can be entered only if default
simplifications have been turned off with `m O'.)

The default value for a term of a sum is zero.  The default value for
a part of a product, for a power, or for the denominator of a
quotient, is one.  Also, `-x' matches the pattern `opt(a) b' with
`a = -1'.

In particular, the distributive-law rule can be refined to

     opt(a) x + opt(b) x  :=  (a + b) x

so that it will convert, e.g., `a x - x', to `(a - 1) x'.

The pattern `opt(a) + opt(b) x' matches almost any formulas which are
linear in `x'.  You can also use the `lin' and `islin' functions with
rewrite conditions to test for this; *Note Logical Operations::.
These functions are not as convenient to use in rewrite rules, but
they recognize more kinds of formulas as linear: `x/z' is considered
linear with `b = 1/z' by `lin', but it will not match the above
pattern because that pattern calls for a multiplication, not a
division.

As another example, the obvious rule to replace `sin(x)^2 + cos(x)^2'
by 1,

     sin(x)^2 + cos(x)^2  :=  1

misses many cases because the sine and cosine may both be multiplied
by an equal factor.  Here's a more successful rule:

     opt(a) sin(x)^2 + opt(a) cos(x)^2  :=  a

Note that this rule will *not* match `sin(x)^2 + 6 cos(x)^2' because
one `a' would have "matched" 1 while the other matched 6.

Calc automatically converts a rule like

     f(x-1, x)  :=  g(x)

into the form

     f(temp, x)  :=  g(x)  :: temp = x-1

(where `temp' stands for a new, invented meta-variable that
doesn't actually have a name).  This modified rule will successfully
match `f(6, 7)', binding `temp' and `x' to 6 and 7,
respectively, then verifying that they differ by one even though
`6' does not superficially look like `x-1'.

However, Calc does not solve equations to interpret a rule.  The
following rule,

     f(x-1, x+1)  :=  g(x)

will not work.  That is, it will match `f(a - 1 + b, a + 1 + b)' but
not `f(6, 8)'.  Calc always interprets at least one occurrence of a
variable by literal matching.  If the variable appears "isolated" then
Calc is smart enough to use it for literal matching.  But in this last
example, Calc is forced to rewrite the rule to `f(x-1, temp) := g(x)
:: temp = x+1' where the `x-1' term must correspond to an actual
something-minus-one" in the target formula.

A successful way to write this would be `f(x, x+2) := g(x+1)'.
You could make this resemble the original form more closely by using
`let' notation, which is described in the next section:

     f(xm1, x+1)  :=  g(x)  :: let(x := xm1+1)

Calc does this rewriting or "conditionalizing" for any sub-pattern
which involves only the functions in the following list, operating
only on constants and meta-variables which have already been matched
elsewhere in the pattern.  When matching a function call, Calc is
careful to match arguments which are plain variables before arguments
which are calls to any of the functions below, so that a pattern like
`f(x-1, x)' can be conditionalized even though the isolated
`x' comes after the `x-1'.

     + - * / \ % ^  abs sign  round rounde roundu trunc floor ceil
     max min  re im conj arg

You can suppress all of the special treatments described in this
section by surrounding a function call with a `plain' marker.  This
marker causes the function call which is its argument to be matched
literally, without regard to commutativity, associativity, negation,
or conditionalization.  When you use `plain', the "deep structure" of
the formula being matched can show through.  For example,

     plain(a - a b)  :=  f(a, b)

will match only literal subtractions.  However, the `plain'
marker does not affect its arguments' arguments.  In this case,
commutativity and associativity is still considered while matching
the `a b' sub-pattern, so the whole pattern will match
`x - y x' as well as `x - x y'.  We could go still
further and use

     plain(a - plain(a b))  :=  f(a, b)

which would do a completely strict match for the pattern.

By contrast, the `quote' marker means that not only the function name
but also the arguments must be literally the same.  The above pattern
will match `x - x y' but

     quote(a - a b)  :=  f(a, b)

will match only the single formula `a - a b'.  Also,

     quote(a - quote(a b))  :=  f(a, b)

will match only `a - quote(a b)'---probably not the desired effect!

A certain amount of algebra is also done when substituting the
meta-variables on the righthand side of a rule.  For example, in the
rule

     a + f(b)  :=  f(a + b)

matching `f(x) - y' would produce `f((-y) + x)' if taken literally,
but the rewrite mechanism will simplify the righthand side to `f(x -
y)' automatically.  (Of course, the default simplifications would do
this anyway, so this special simplification is only noticeable if you
have turned the default simplifications off.)  This rewriting is done
only when a meta-variable expands to a "negative-looking" expression.
If this simplification is not desirable, you can use a `plain' marker
on the righthand side:

     a + f(b)  :=  f(plain(a + b))

In this example, we are still allowing the pattern-matcher to use all
the algebra it can muster, but the righthand side will always simplify
to a literal addition like `f((-y) + x)'.



File: calc.info, Node: Other Features of Rewrite Rules, Next: Composing Patterns in Rewrite Rules, Prev: Algebraic Properties of Rewrite Rules, Up: Rewrite Rules

Other Features of Rewrite Rules
-------------------------------

Certain "function names" serve as markers in rewrite rules.  Here is a
complete list of these markers.  First are listed the markers that
work inside a pattern; then come the markers that work in the
righthand side of a rule.

One kind of marker, `import(x)', takes the place of a whole
rule.  Here `x' is the name of a variable containing another
rule set; those rules are "spliced into" the rule set that
imports them.  For example, if `[f(a+b) := f(a) + f(b),
f(a b) := a f(b) :: real(a)]' is stored in variable `linearF',
then the rule set `[f(0) := 0, import(linearF)]' will apply
all three rules.  It is possible to modify the imported rules
slightly:  `import(x, v1, x1, v2, x2, ...)' imports
the rule set `x' with all occurrences of `v1', as either
a variable name or a function name, replaced with `x1' and
so on.  (If `v1' is used as a function name, then `x1'
must be either a function name itself or a `< >' nameless
function; *Note Specifying Operators::.)  For example, `[g(0) := 0,
import(linearF, f, g)]' applies the linearity rules to the function
`g' instead of `f'.  Imports can be nested, but the
import-with-renaming feature may fail to rename sub-imports properly.

The special functions allowed in patterns are:

`quote(x)'
     This pattern matches exactly `x'; variable names in `x' are not
     interpreted as meta-variables.  The only flexibility is that
     numbers are compared for numeric equality, so that the pattern
     `f(quote(12))' will match both `f(12)' and `f(12.0)'.  (Numbers
     are always treated this way by the rewrite mechanism: The rule
     `f(x,x) := g(x)' will match `f(12, 12.0)'.  The rewrite may
     produce either `g(12)' or `g(12.0)' as a result in this case.)

`plain(x)'
     Here `x' must be a function call `f(x1,x2,...)'.  This
     pattern matches a call to function `f' with the specified
     argument patterns.  No special knowledge of the properties of the
     function `f' is used in this case; `+' is not commutative or
     associative.  Unlike `quote', the arguments `x1,x2,...'
     are treated as patterns.  If you wish them to be treated "plainly"
     as well, you must enclose them with more `plain' markers:
     `plain(plain(-a) + plain(b c))'.

`opt(x,def)'
     Here `x' must be a variable name.  This must appear as an
     argument to a function or an element of a vector; it specifies
     that the argument or element is optional.  As an argument to `+',
     `-', `*', `&&', or `||', or as the second argument to `/' or `^',
     the value DEF may be omitted.  The pattern `x + opt(y)' matches a
     sum by binding one summand to `x' and the other to `y', and it
     matches anything else by binding the whole expression to `x' and
     zero to `y'.  The other operators above work similarly.

     For general miscellanous functions, the default value `def' must
     be specified.  Optional arguments are dropped starting with the
     rightmost one during matching.  For example, the pattern
     `f(opt(a,0), b, opt(c,b))' will match `f(b)', `f(a,b)', or
     `f(a,b,c)'.  Default values of zero and `b' are supplied in this
     example for the omitted arguments.  Note that the literal
     variable `b' will be the default in the latter case, *not* the
     value that matched the meta-variable `b'.  In other words, the
     default DEF is effectively quoted.

`condition(x,c)'
     This matches the pattern `x', with the attached condition
     `c'.  It is the same as `x :: c'.

`pand(x,y)'
     This matches anything that matches both pattern `x' and
     pattern `y'.  It is the same as `x &&& y'.
     *Note Composing Patterns in Rewrite Rules::.

`por(x,y)'
     This matches anything that matches either pattern `x' or
     pattern `y'.  It is the same as `x ||| y'.

`pnot(x)'
     This matches anything that does not match pattern `x'.  It is the
     same as `!!! x'.

`cons(h,t)'
     This matches any vector of one or more elements.  The first
     element is matched to `h'; a vector of the remaining elements is
     matched to `t'.  Note that vectors of fixed length can also be
     matched as actual vectors: The rule `cons(a,cons(b,[])) :=
     cons(a+b,[])' is equivalent to the rule `[a,b] := [a+b]'.

`rcons(t,h)'
     This is like `cons', except that the *last* element is matched to
     `h', with the remaining elements matched to `t'.

`apply(f,args)'
     This matches any function call.  The name of the function, in the
     form of a variable, is matched to `f'.  The arguments of the
     function, as a vector of zero or more objects, are matched to
     `args'.  Constants, variables, and vectors do *not* match an
     `apply' pattern.  For example, `apply(f,x)' matches any function
     call, `apply(quote(f),x)' matches any call to the function `f',
     `apply(f,[a,b])' matches any function call with exactly two
     arguments, and `apply(quote(f), cons(a,cons(b,x)))' matches any
     call to the function `f' with two or more arguments.  Another way
     to implement the latter, if the rest of the rule does not need to
     refer to the first two arguments of `f' by name, would be
     `apply(quote(f), x :: vlen(x) >= 2)'.  Here's a more interesting
     sample use of `apply':

	  apply(f,[x+n])  :=  n + apply(f,[x])
	     :: in(f, [floor,ceil,round,trunc]) :: integer(n)

     Note, however, that this will be slower to match than a rule set
     with four separate rules.  The reason is that Calc sorts the
     rules of a rule set according to top-level function name; if the
     top-level function is `apply', Calc must try the rule for every
     single formula and sub-formula.  If the top-level function in the
     pattern is, say, `floor', then Calc invokes the rule only for
     sub-formulas which are calls to `floor'.

     Formulas normally written with operators like `+' are still
     considered function calls: `apply(f,x)' matches `a+b' with `f =
     add', `x = [a,b]'.

     You must use `apply' for meta-variables with function names
     on both sides of a rewrite rule:  `apply(f, [x]) := f(x+1)'
     is *not* correct, because it rewrites `spam(6)' into
     `f(7)'.  The righthand side should be `apply(f, [x+1])'.
     Also note that you will have to use no-simplify (`m O')
     mode when entering this rule so that the `apply' isn't
     evaluated immediately to get the new rule `f(x) := f(x+1)'.
     Or, use `s e' to enter the rule without going through the stack,
     or enter the rule as `apply(f, [x]) := apply(f, [x+1]) :: 1'.
     *Note Conditional Rewrite Rules::.

`select(x)'
     This is used for applying rules to formulas with selections;
     *Note Selections with Rewrite Rules::.

Special functions for the righthand sides of rules are:

`quote(x)'
     The notation `quote(x)' is changed to `x' when the righthand side
     is used.  As far as the rewrite rule is concerned, `quote' is
     invisible.  However, `quote' has the special property in Calc
     that its argument is not evaluated.  Thus, while it will not work
     to put the rule `t(a) := typeof(a)' on the stack because
     `typeof(a)' is evaluated immediately to produce `t(a) := 100',
     you can use `quote' to protect the righthand side: `t(a) :=
     quote(typeof(a))'.  (*Note Conditional Rewrite Rules::, for
     another trick for protecting rules from evaluation.)

`plain(x)'
     Special properties of and simplifications for the function call
     `x' are not used.  One interesting case where `plain' is useful
     is the rule, `q(x) := quote(x)', trying to expand a shorthand
     notation for the `quote' function.  This rule will not work as
     shown; instead of replacing `q(foo)' with `quote(foo)', it will
     replace it with `foo'!  The correct rule would be `q(x) :=
     plain(quote(x))'.

`cons(h,t)'
     Where `t' is a vector, this is converted into an expanded vector
     during rewrite processing.  Note that `cons' is a regular Calc
     function which normally does this anyway; the only way `cons' is
     treated specially by rewrites is that `cons' on the righthand
     side of a rule will be evaluated even if default simplifications
     have been turned off.

`rcons(t,h)'
     Analogous to `cons' except putting `h' at the *end* of the vector
     `t'.

`apply(f,args)'
     Where `f' is a variable and ARGS is a vector, this is converted
     to a function call.  Once again, note that `apply' is also a
     regular Calc function.

`eval(x)'
     The formula `x' is handled in the usual way, then the default
     simplifications are applied to it even if they have been turned
     off normally.  This allows you to treat any function similarly to
     the way `cons' and `apply' are always treated.  However, there is
     a slight difference: `cons(2+3, [])' with default simplifications
     off will be converted to `[2+3]', whereas `eval(cons(2+3, []))'
     will be converted to `[5]'.

`evalsimp(x)'
     The formula `x' has meta-variables substituted in the usual way,
     then algebraically simplified as if by the `a s' command.

`evalextsimp(x)'
     The formula `x' has meta-variables substituted in the normal way,
     then "extendedly" simplified as if by the `a e' command.

`select(x)'
     *Note Selections with Rewrite Rules::.

There are also some special functions you can use in conditions.

`let(v := x)'
     The expression `x' is evaluated with meta-variables substituted.
     The `a s' command's simplifications are *not* applied by default,
     but `x' can include calls to `evalsimp' or `evalextsimp' as
     described above to invoke higher levels of simplification.  The
     result of `x' is then bound to the meta-variable `v'.  As usual,
     if this meta-variable has already been matched to something else
     the two values must be equal; if the meta-variable is new then it
     is bound to the result of the expression.  This variable can then
     appear in later conditions, and on the righthand side of the
     rule.  In fact, `v' may be any pattern in which case the result
     of evaluating `x' is matched to that pattern, binding any
     meta-variables that appear in that pattern.  Note that `let' can
     only appear by itself as a condition, or as one term of an `&&'
     which is a whole condition: It cannot be inside an `||' term or
     otherwise buried.

     The alternate, equivalent form `let(v, x)' is also recognized.
     Note that the use of `:=' by `let', while still being
     assignment-like in character, is unrelated to the use of `:=' in
     the main part of a rewrite rule.

     As an example, `f(a) := g(ia) :: let(ia := 1/a) :: constant(ia)'
     replaces `f(a)' with `g' of the inverse of `a', if that inverse
     exists and is constant.  For example, if `a' is a singular matrix
     the operation `1/a' is left unsimplified and `constant(ia)'
     fails, but if `a' is an invertible matrix then the rule succeeds.
     Without `let' there would be no way to express this rule that
     didn't have to invert the matrix twice.  Note that, because the
     meta-variable `ia' is otherwise unbound in this rule, the `let'
     condition itself always "succeeds" because no matter what `1/a'
     evaluates to, it can successfully be bound to `ia'.

     Here's another example, for integrating cosines of linear terms:
     `myint(cos(y),x) := sin(y)/b :: let([a,b,x] := lin(y,x))'.  The
     `lin' function returns a 3-vector if its argument is linear, or
     leaves itself unevaluated if not.  But an unevaluated `lin' call
     will not match the 3-vector on the lefthand side of the `let', so
     this `let' both verifies that `y' is linear, and binds the
     coefficients `a' and `b' for use elsewhere in the rule.  (It
     would have been possible to use `sin(a x + b)/b' for the
     righthand side instead, but using `sin(y)/b' avoids gratuitous
     rearrangement of the argument of the sine.)

     Similarly, here is a rule that implements an inverse-`erf'
     function.  It uses `root' to search for a solution.  If
     `root' succeeds, it will return a vector of two numbers
     where the first number is the desired solution.  If no solution
     is found, `root' remains in symbolic form.  So we use
     `let' to check that the result was indeed a vector.

	  ierf(x)  :=  y  :: let([y,z] := root(erf(a) = x, a, .5))

`matches(v,p)'
     The meta-variable V, which must already have been matched to
     something elsewhere in the rule, is compared against pattern P.
     Since `matches' is a standard Calc function, it can appear
     anywhere in a condition.  But if it appears alone or as a term of
     a top-level `&&', then you get the special extra feature that
     meta-variables which are bound to things inside P can be used
     elsewhere in the surrounding rewrite rule.

     The only real difference between `let(p := v)' and `matches(v,
     p)' is that the former evaluates `v' using the default
     simplifications, while the latter does not.

`remember'
     This is actually a variable, not a function.  If `remember'
     appears as a condition in a rule, then when that rule succeeds
     the original expression and rewritten expression are added to the
     front of the rule set that contained the rule.  If the rule set
     was not stored in a variable, `remember' is ignored.  The
     lefthand side is enclosed in `quote' in the added rule if it
     contains any variables.

     For example, the rule `f(n) := n f(n-1) :: remember' applied to
     `f(7)' will add the rule `f(7) := 7 f(6)' to the front of the
     rule set.  The rule set `EvalRules' works slightly differently:
     There, the evaluation of `f(6)' will complete before the result
     is added to the rule set, in this case as `f(7) := 5040'.  Thus
     `remember' is most useful inside `EvalRules'.

     It is up to you to ensure that the optimization performed by
     `remember' is safe.  For example, the rule `foo(n) := n
     :: evalv(eatfoo) > 0 :: remember' is a bad idea (`evalv' is
     the function equivalent of the `=' command); if the variable
     `eatfoo' ever contains 1, rules like `foo(7) := 7' will
     be added to the rule set and will continue to operate even if
     `eatfoo' is later changed to 0.

`remember(c)'
     Remember the match as described above, but only if condition `c'
     is true.  For example, `remember(n % 4 = 0)' in the above
     factorial rule remembers only every fourth result.  Note that
     `remember(1)' is equivalent to `remember', and `remember(0)' has
     no effect.



