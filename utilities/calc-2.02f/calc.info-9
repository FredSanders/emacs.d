Info file: calc.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `calc.texinfo'
using `texinfmt.el' version 2.42 of  7 Jul 2006.

This file documents Calc, the GNU Emacs calculator.

Copyright (C) 1990, 1991 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the author
instead of in the original English.




File: calc.info, Node: Functions for Declarations, Prev: Kinds of Declarations, Up: Declarations

Functions for Declarations
--------------------------

Calc has a set of functions for accessing the current declarations in
a convenient manner.  These functions return 1 if the argument can be
shown to have the specified property, or 0 if the argument can be
shown *not* to have that property; otherwise they are left
unevaluated.  These functions are suitable for use with rewrite rules
(*Note Conditional Rewrite Rules::) or programming constructs (*Note
Conditionals in Macros::).  They can be entered only using algebraic
notation.  *Note Logical Operations::, for functions that perform
other tests not related to declarations.

For example, `dint(17)' returns 1 because 17 is an integer, as do
`dint(n)' and `dint(2 n - 3)' if `n' has been declared `int', but
`dint(2.5)' and `dint(n + 0.5)' return 0.  Calc consults knowledge of
its own built-in functions as well as your own declarations:
`dint(floor(x))' returns 1.

The `dint' function checks if its argument is an integer.  The
`dnatnum' function checks if its argument is a natural number, i.e., a
nonnegative integer.  The `dnumint' function checks if its argument is
numerically an integer, i.e., either an integer or an integer-valued
float.  Note that these and the other data type functions also accept
vectors or matrices composed of suitable elements, and that real
infinities `inf' and `-inf' are considered to be integers for the
purposes of these functions.

The `drat' function checks if its argument is rational, i.e., an
integer or fraction.  Infinities count as rational, but intervals and
error forms do not.

The `dreal' function checks if its argument is real.  This includes
integers, fractions, floats, real error forms, and intervals.

The `dimag' function checks if its argument is imaginary, i.e., is
mathematically equal to a real number times `i'.

The `dpos' function checks for positive (but nonzero) reals.  The
`dneg' function checks for negative reals.  The `dnonneg' function
checks for nonnegative reals, i.e., reals greater than or equal to
zero.  Note that the `a s' command can simplify an expression like `x
> 0' to 1 or 0 using `dpos', and that `a s' is effectively applied to
all conditions in rewrite rules, so the actual functions `dpos',
`dneg', and `dnonneg' are rarely necessary.

The `dnonzero' function checks that its argument is nonzero.  This
includes all nonzero real or complex numbers, all intervals that do
not include zero, all nonzero modulo forms, vectors all of whose
elements are nonzero, and variables or formulas whose values can be
deduced to be nonzero.  It does not include error forms, since they
represent values which could be anything including zero.  (This is
also the set of objects considered "true" in conditional contexts.)

The `deven' function returns 1 if its argument is known to be
an even integer (or integer-valued float); it returns 0 if its argument
is known not to be even (because it is known to be odd or a non-integer).
The `a s' command uses this to simplify a test of the form
`x % 2 = 0'.  There is also an analogous `dodd' function.

The `drange' function returns a set (an interval or a vector of
intervals and/or numbers; *Note Set Operations::) that describes the
set of possible values of its argument.  If the argument is a variable
or a function with a declaration, the range is copied from the
declaration.  Otherwise, the possible signs of the expression are
determined using a method similar to `dpos', etc., and a suitable set
like `[0 .. inf]' is returned.  If the expression is not provably
real, the `drange' function remains unevaluated.

The `dscalar' function returns 1 if its argument is provably scalar,
or 0 if its argument is provably non-scalar.  It is left unevaluated
if this cannot be determined.  (If matrix mode or scalar mode are in
effect, this function returns 1 or 0, respectively, if it has no other
information.)  When Calc interprets a condition (say, in a rewrite
rule) it considers an unevaluated formula to be "false."  Thus,
`dscalar(a)' is "true" only if `a' is provably scalar, and
`!dscalar(a)' is "true" only if `a' is provably non-scalar; both are
false" if there is insufficient information to tell.



File: calc.info, Node: Display Modes, Next: Language Modes, Prev: Declarations, Up: Mode Settings

Display Modes
=============

The commands in this section are two-key sequences beginning with the
`d' prefix.  The `d l' (`calc-line-numbering') and `d b'
(`calc-line-breaking') commands are described elsewhere; *Note Stack
Basics:: and *Note Normal Language Modes::, respectively.  Display
formats for vectors and matrices are also covered elsewhere; *Note
Vector and Matrix Formats::.

One thing all display modes have in common is their treatment of the
`H' prefix.  This prefix causes any mode command that would normally
refresh the stack to leave the stack display alone.  The word "Dirty"
will appear in the mode line when Calc thinks the stack display may
not reflect the latest mode settings.

The `d RET' (`calc-refresh-top') command reformats the top stack entry
according to all the current modes.  Positive prefix arguments
reformat the top N entries; negative prefix arguments reformat the
specified entry, and a prefix of zero is equivalent to `d SPC'
(`calc-refresh'), which reformats the entire stack.  For example, `H d
s M-2 d RET' changes to scientific notation but reformats only the top
two stack entries in the new mode.

The `I' prefix has another effect on the display modes.  The mode is
set only temporarily; the top stack entry is reformatted according to
that mode, then the original mode setting is restored.  In other
words, `I d s' is equivalent to `H d s d RET H d (OLD MODE)'.

* Menu:

* Radix Modes::
* Grouping Digits::
* Float Formats::
* Complex Formats::
* Fraction Formats::
* HMS Formats::
* Date Formats::
* Truncating the Stack::
* Justification::
* Labels::



File: calc.info, Node: Radix Modes, Next: Grouping Digits, Prev: Display Modes, Up: Display Modes

Radix Modes
-----------

Calc normally displays numbers in decimal ("base-10" or "radix-10")
notation.  Calc can actually display in any radix from two (binary) to
36.  When the radix is above 10, the letters `A' to `Z' are used as
digits.  When entering such a number, letter keys are interpreted as
potential digits rather than terminating numeric entry mode.

The key sequences `d 2', `d 8', `d 6', and `d 0' select binary, octal,
hexadecimal, and decimal as the current display radix, respectively.
Numbers can always be entered in any radix, though the current radix
is used as a default if you press `#' without any initial digits.  A
number entered without a `#' is *always* interpreted as decimal.

To set the radix generally, use `d r' (`calc-radix') and enter an
integer from 2 to 36.  You can specify the radix as a numeric prefix
argument; otherwise you will be prompted for it.

Integers normally are displayed with however many digits are necessary
to represent the integer and no more.  The `d z'
(`calc-leading-zeros') command causes integers to be padded out with
leading zeros according to the current binary word size.  (*Note
Binary Functions::, for a discussion of word size.)  If the absolute
value of the word size is `w', all integers are displayed with at
least enough digits to represent `(2^w)-1' in the current radix.
(Larger integers will still be displayed in their entirety.)



File: calc.info, Node: Grouping Digits, Next: Float Formats, Prev: Radix Modes, Up: Display Modes

Grouping Digits
---------------

Long numbers can be hard to read if they have too many digits.  For
example, the factorial of 30 is 33 digits long!  Press `d g'
(`calc-group-digits') to enable "grouping" mode, in which digits are
displayed in clumps of 3 or 4 (depending on the current radix)
separated by commas.

The `d g' command toggles grouping on and off.  With a numerix prefix
of 0, this command displays the current state of the grouping flag;
with an argument of minus one it disables grouping; with a positive
argument `N' it enables grouping on every `N' digits.  For
floating-point numbers, grouping normally occurs only before the
decimal point.  A negative prefix argument `-N' enables grouping every
`N' digits both before and after the decimal point.

The `d ,' (`calc-group-char') command allows you to choose any
character as the grouping separator.  The default is the comma character.
If you find it difficult to read vectors of large integers grouped with
commas, you may wish to use spaces or some other character instead.
This command takes the next character you type, whatever it is, and
uses it as the digit separator.  As a special case, `d , \' selects
`\,' (TeX's thin-space symbol) as the digit separator.

Please note that grouped numbers will not generally be parsed
correctly if re-read in textual form, say by the use of `M-# y' and
`M-# g'.  (*Note Kill and Yank::, for details on these commands.)  One
exception is the `\,' separator, which doesn't interfere with parsing
because it is ignored by TeX language mode.



File: calc.info, Node: Float Formats, Next: Complex Formats, Prev: Grouping Digits, Up: Display Modes

Float Formats
-------------

Floating-point quantities are normally displayed in standard decimal
form, with scientific notation used if the exponent is especially high
or low.  All significant digits are normally displayed.  The commands
in this section allow you to choose among several alternative display
formats for floats.

The `d n' (`calc-normal-notation') command selects the normal display
format.  All significant figures in a number are displayed.  With a
positive numeric prefix, numbers are rounded if necessary to that
number of significant digits.  With a negative numerix prefix, the
specified number of significant digits less than the current precision
is used.  (Thus `C-u -2 d n' displays 10 digits if the current
precision is 12.)

The `d f' (`calc-fix-notation') command selects fixed-point notation.
The numeric argument is the number of digits after the decimal point,
zero or more.  This format will relax into scientific notation if a
nonzero number would otherwise have been rounded all the way to zero.
Specifying a negative number of digits is the same as for a positive
number, except that small nonzero numbers will be rounded to zero
rather than switching to scientific notation.

The `d s' (`calc-sci-notation') command selects scientific notation.
A positive argument sets the number of significant figures displayed,
of which one will be before and the rest after the decimal point.  A
negative argument works the same as for `d n' format.  The default is
to display all significant digits.

The `d e' (`calc-eng-notation') command selects engineering notation.
This is similar to scientific notation except that the exponent is
rounded down to a multiple of three, with from one to three digits
before the decimal point.  An optional numeric prefix sets the number
of significant digits to display, as for `d s'.

It is important to distinguish between the current *precision* and the
current *display format*.  After the commands `C-u 10 p' and `C-u 6 d
n' the Calculator computes all results to ten significant figures but
displays only six.  (In fact, intermediate calculations are often
carried to one or two more significant figures, but values placed on
the stack will be rounded down to ten figures.)  Numbers are never
actually rounded to the display precision for storage, except by
commands like `C-k' and `M-# y' which operate on the actual displayed
text in the Calculator buffer.

The `d .' (`calc-point-char') command selects the character used as a
decimal point.  Normally this is a period; users in some countries may
wish to change this to a comma.  Note that this is only a display
style; on entry, periods must always be used to denote floating-point
numbers, and commas to separate elements in a list.



File: calc.info, Node: Complex Formats, Next: Fraction Formats, Prev: Float Formats, Up: Display Modes

Complex Formats
---------------

There are three supported notations for complex numbers in rectangular
form.  The default is as a pair of real numbers enclosed in
parentheses and separated by a comma: `(a,b)'.  The `d c'
(`calc-complex-notation') command selects this style.

The other notations are `d i' (`calc-i-notation'), in which numbers
are displayed in `a+bi' form, and `d j' (`calc-j-notation') which
displays the form `a+bj' preferred in some disciplines.

Complex numbers are normally entered in `(a,b)' format.  If you enter
`2+3i' as an algebraic formula, it will be stored as the formula `2 +
3 * i'.  However, if you use `=' to evaluate this formula and you have
not changed the variable `i', the `i' will be interpreted as `(0,1)'
and the formula will be simplified to `(2,3)'.  Other commands (like
`calc-sin') will *not* interpret the formula `2 + 3 * i' as a complex
number.  *Note Variables::, under "special constants."



File: calc.info, Node: Fraction Formats, Next: HMS Formats, Prev: Complex Formats, Up: Display Modes

Fraction Formats
----------------

Display of fractional numbers is controlled by the `d o'
(`calc-over-notation') command.  By default, a number like eight
thirds is displayed in the form `8:3'.  The `d o' command prompts for
a one- or two-character format.  If you give one character, that
character is used as the fraction separator.  Common separators are
`:' and `/'.  (During input of numbers, the `:' key must be used
regardless of the display format; in particular, the `/' is used for
RPN-style division, *not* for entering fractions.)

If you give two characters, fractions use
integer-plus-fractional-part" notation.  For example, the format `+/'
would display eight thirds as `2+2/3'.  If two colons are present in a
number being entered, the number is interpreted in this form (so that
the entries `2:2:3' and `8:3' are equivalent).

It is also possible to follow the one- or two-character format with a
number.  For example: `:10' or `+/3'.  In this case, Calc adjusts all
fractions that are displayed to have the specified denominator, if
possible.  Otherwise it adjusts the denominator to be a multiple of
the specified value.  For example, in `:6' mode the fraction `1:6'
will be unaffected, but `2:3' will be displayed as `4:6', `1:2' will
be displayed as `3:6', and `1:8' will be displayed as `3:24'.
Integers are also affected by this mode: 3 is displayed as `18:6'.
Note that the format `:1' writes fractions the same as `:', but it
writes integers as `n:1'.

The fraction format does not affect the way fractions or integers are
stored, only the way they appear on the screen.  The fraction format
never affects floats.



File: calc.info, Node: HMS Formats, Next: Date Formats, Prev: Fraction Formats, Up: Display Modes

HMS Formats
-----------

The `d h' (`calc-hms-notation') command controls the display of HMS
(hours-minutes-seconds) forms.  It prompts for a string which consists
basically of an "hours" marker, optional punctuation, a "minutes"
marker, more optional punctuation, and a "seconds" marker.
Punctuation is zero or more spaces, commas, or semicolons.  The hours
marker is one or more non-punctuation characters.  The minutes and
seconds markers must be single non-punctuation characters.

The default HMS format is `@ ' "', producing HMS values of the form
`23@ 30' 15.75"'.  The format `deg, ms' would display this same value
as `23deg, 30m15.75s'.  During numeric entry, the `h' or `o' keys are
recognized as synonyms for `@' regardless of display format.  The `m'
and `s' keys are recognized as synonyms for `'' and `"', respectively,
but only if an `@' (or `h' or `o') has already been typed; otherwise,
they have their usual meanings (`m-' prefix and `s-' prefix).  Thus,
`5 "', `0 @ 5 "', and `0 h 5 s' are some of the ways to enter the
quantity "five seconds."  The `'' key is recognized as "minutes" only
if `@' (or `h' or `o') has already been pressed; otherwise it means to
switch to algebraic entry.



File: calc.info, Node: Date Formats, Next: Truncating the Stack, Prev: HMS Formats, Up: Display Modes

Date Formats
------------

The `d d' (`calc-date-notation') command controls the display of date
forms (*Note Date Forms::).  It prompts for a string which contains
letters that represent the various parts of a date and time.  To show
which parts should be omitted when the form represents a pure date
with no time, parts of the string can be enclosed in `< >' marks.  If
you don't include `< >' markers in the format, Calc guesses at which
parts, if any, should be omitted when formatting pure dates.

The default format is: `<H:mm:SSpp >Www Mmm D, YYYY'.  An example
string in this format is `3:32pm Wed Jan 9, 1991'.  If you enter a
blank format string, this default format is reestablished.

Calc uses `< >' notation for nameless functions as well as for dates.
*Note Specifying Operators::.  To avoid confusion with nameless
functions, your date formats should avoid using the `#' character.

* Menu:

* Date Formatting Codes::
* Free-Form Dates::
* Standard Date Formats::



File: calc.info, Node: Date Formatting Codes, Next: Free-Form Dates, Prev: Date Formats, Up: Date Formats

Date Formatting Codes
.....................

When displaying a date, the current date format is used.  All
characters except for letters and `<' and `>' are copied literally
when dates are formatted.  The portion between `< >' markers is
omitted for pure dates, or included for date/time forms.  Letters are
interpreted according to the table below.

When dates are read in during algebraic entry, Calc first tries to
match the input string to the current format either with or without
the time part.  The punctuation characters (including spaces) must
match exactly; letter fields must correspond to suitable text in the
input.  If this doesn't work, Calc checks if the input is a simple
number; if so, the number is interpreted as a number of days since Jan
1, 1 AD.  Otherwise, Calc tries a much more relaxed and flexible
algorithm which is described in the next section.

Weekday names are ignored during reading.

Two-digit year numbers are interpreted as lying in the range from 1941
to 2039.  Years outside that range are always entered and displayed in
full.  Year numbers with a leading `+' sign are always interpreted
exactly, allowing the entry and display of the years 1 through 99 AD.

Here is a complete list of the formatting codes for dates:

Y
     Year: "91" for 1991, "7" for 2007, "+23" for 23 AD.
YY
     Year: "91" for 1991, "07" for 2007, "+23" for 23 AD.
BY
     Year: "91" for 1991, " 7" for 2007, "+23" for 23 AD.
YYY
     Year: "1991" for 1991, "23" for 23 AD.
YYYY
     Year: "1991" for 1991, "+23" for 23 AD.
aa
     Year: "ad" or blank.
AA
     Year: "AD" or blank.
aaa
     Year: "ad " or blank.  (Note trailing space.)
AAA
     Year: "AD " or blank.
aaaa
     Year: "a.d." or blank.
AAAA
     Year: "A.D." or blank.
bb
     Year: "bc" or blank.
BB
     Year: "BC" or blank.
bbb
     Year: " bc" or blank.  (Note leading space.)
BBB
     Year: " BC" or blank.
bbbb
     Year: "b.c." or blank.
BBBB
     Year: "B.C." or blank.
M
     Month: "8" for August.
MM
     Month: "08" for August.
BM
     Month: " 8" for August.
MMM
     Month: "AUG" for August.
Mmm
     Month: "Aug" for August.
mmm
     Month: "aug" for August.
MMMM
     Month: "AUGUST" for August.
Mmmm
     Month: "August" for August.
D
     Day: "7" for 7th day of month.
DD
     Day: "07" for 7th day of month.
BD
     Day: " 7" for 7th day of month.
W
     Weekday: "0" for Sunday, "6" for Saturday.
WWW
     Weekday: "SUN" for Sunday.
Www
     Weekday: "Sun" for Sunday.
www
     Weekday: "sun" for Sunday.
WWWW
     Weekday: "SUNDAY" for Sunday.
Wwww
     Weekday: "Sunday" for Sunday.
d
     Day of year: "34" for Feb. 3.
ddd
     Day of year: "034" for Feb. 3.
bdd
     Day of year: " 34" for Feb. 3.
h
     Hour: "5" for 5 AM; "17" for 5 PM.
hh
     Hour: "05" for 5 AM; "17" for 5 PM.
bh
     Hour: " 5" for 5 AM; "17" for 5 PM.
H
     Hour: "5" for 5 AM and 5 PM.
HH
     Hour: "05" for 5 AM and 5 PM.
BH
     Hour: " 5" for 5 AM and 5 PM.
p
     AM/PM: "a" or "p".
P
     AM/PM: "A" or "P".
pp
     AM/PM: "am" or "pm".
PP
     AM/PM: "AM" or "PM".
pppp
     AM/PM: "a.m." or "p.m.".
PPPP
     AM/PM: "A.M." or "P.M.".
m
     Minutes: "7" for 7.
mm
     Minutes: "07" for 7.
bm
     Minutes: " 7" for 7.
s
     Seconds: "7" for 7; "7.23" for 7.23.
ss
     Seconds: "07" for 7; "07.23" for 7.23.
bs
     Seconds: " 7" for 7; " 7.23" for 7.23.
SS
     Optional seconds: "07" for 7; blank for 0.
BS
     Optional seconds: " 7" for 7; blank for 0.
N
     Numeric date/time: "726842.25" for 6:00am Wed Jan 9, 1991.
n
     Numeric date: "726842" for any time on Wed Jan 9, 1991.
J
     Julian date/time: "2448265.75" for 6:00am Wed Jan 9, 1991.
j
     Julian date: "2448266" for any time on Wed Jan 9, 1991.
U
     Unix time: "663400800" for 6:00am Wed Jan 9, 1991.
X
     Brackets suppression.  An "X" at the front of the format
     causes the surrounding `< >' delimiters to be omitted
     when formatting dates.  Note that the brackets are still
     required for algebraic entry.

If "SS" or "BS" (optional seconds) is preceded by a colon, the colon
is also omitted if the seconds part is zero.

If "bb," "bbb" or "bbbb" or their upper-case equivalents
appear in the format, then negative year numbers are displayed
without a minus sign.  Note that "aa" and "bb" are mutually
exclusive.  Some typical usages would be `YYYY AABB';
`AAAYYYYBBB'; `YYYYBBB'.

The formats "YY," "YYYY," "MM," "DD," "ddd," "hh," "HH," "mm," "ss,"
and "SS" actually match any number of digits during reading unless
several of these codes are strung together with no punctuation in
between, in which case the input must have exactly as many digits as
there are letters in the format.

The "j," "J," and "U" formats do not make any time zone
adjustment.  They effectively use `julian(x,0)' and
`unixtime(x,0)' to make the conversion; *Note Date Arithmetic::.



File: calc.info, Node: Free-Form Dates, Next: Standard Date Formats, Prev: Date Formatting Codes, Up: Date Formats

Free-Form Dates
...............

When reading a date form during algebraic entry, Calc falls back on
the algorithm described here if the input does not exactly match the
current date format.  This algorithm generally "does the right thing"
and you don't have to worry about it, but it is described here in full
detail for the curious.

Calc does not distinguish between upper- and lower-case letters while
interpreting dates.

First, the time portion, if present, is located somewhere in the text
and then removed.  The remaining text is then interpreted as the date.

A time is of the form `hh:mm:ss', possibly with the seconds part
omitted and possibly with an AM/PM indicator added to indicate 12-hour
time.  If the AM/PM is present, the minutes may also be omitted.  The
AM/PM part may be any of the words `am', `pm', `noon', or `midnight';
each of these may be abbreviated to one letter, and the alternate
forms `a.m.', `p.m.', and `mid' are also understood.  Obviously `noon'
and `midnight' are allowed only on 12:00:00.  The words `noon', `mid',
and `midnight' are also recognized with no number attached.

If there is no AM/PM indicator, the time is interpreted in 24-hour
format.

To read the date portion, all words and numbers are isolated from the
string; other characters are ignored.  All words must be either month
names or day-of-week names (the latter of which are ignored).  Names
can be written in full or as three-letter abbreviations.

Large numbers, or numbers with `+' or `-' signs, are interpreted as
years.  If one of the other numbers is greater than 12, then that must
be the day and the remaining number in the input is therefore the
month.  Otherwise, Calc assumes the month, day and year are in the
same order that they appear in the current date format.  If the year
is omitted, the current year is taken from the system clock.

If there are too many or too few numbers, or any unrecognizable words,
then the input is rejected.

If there are any large numbers (of five digits or more) other than the
year, they are ignored on the assumption that they are something like
Julian dates that were included along with the traditional date
components when the date was formatted.

One of the words `ad', `a.d.', `bc', or `b.c.'  may optionally be
used; the latter two are equivalent to a minus sign on the year value.

If you always enter a four-digit year, and use a name instead of a
number for the month, there is no danger of ambiguity.



File: calc.info, Node: Standard Date Formats, Prev: Free-Form Dates, Up: Date Formats

Standard Date Formats
.....................

There are actually ten standard date formats, numbered 0 through 9.
Entering a blank line at the `d d' command's prompt gives you format
number 1, Calc's usual format.  You can enter any digit to select the
other formats.

To create your own standard date formats, give a numeric prefix
argument from 0 to 9 to the `d d' command.  The format you
enter will be recorded as the new standard format of that
number, as well as becoming the new current date format.
You can save your formats permanently with the `m m'
command (*Note Mode Settings::).

0
     `N'  (Numerical format)
1
     `<H:mm:SSpp >Www Mmm D, YYYY'  (American format)
2
     `D Mmm YYYY<, h:mm:SS>'  (European format)
3
     `Www Mmm BD< hh:mm:ss> YYYY'  (Unix written date format)
4
     `M/D/Y< H:mm:SSpp>'  (American slashed format)
5
     `D.M.Y< h:mm:SS>'  (European dotted format)
6
     `M-D-Y< H:mm:SSpp>'  (American dashed format)
7
     `D-M-Y< h:mm:SS>'  (European dashed format)
8
     `j<, h:mm:ss>'  (Julian day plus time)
9
     `YYddd< hh:mm:ss>'  (Year-day format)



File: calc.info, Node: Truncating the Stack, Next: Justification, Prev: Date Formats, Up: Display Modes

Truncating the Stack
--------------------

The `d t' (`calc-truncate-stack') command moves the `.'  line that
marks the top-of-stack up or down in the Calculator buffer.  The
number right above that line is considered to the be at the top of the
stack.  Any numbers below that line are "hidden" from all stack
operations.  This is similar to the Emacs "narrowing" feature, except
that the values below the `.' are *visible*, just temporarily frozen.
This feature allows you to keep several independent calculations
running at once in different parts of the stack, or to apply a certain
command to an element buried deep in the stack.

Pressing `d t' by itself moves the `.' to the line the cursor is on.
Thus, this line and all those below it become hidden.  To un-hide
these lines, move down to the end of the buffer and press `d t'.  With
a positive numeric prefix argument `n', `d t' hides the bottom `n'
values in the buffer.  With a negative argument, it hides all but the
top `n' values.  With an argument of zero, it hides zero values, i.e.,
moves the `.' all the way down to the bottom.

The `d [' (`calc-truncate-up') and `d ]' (`calc-truncate-down')
commands move the `.' up or down one line at a time (or several lines
with a prefix argument).



File: calc.info, Node: Justification, Next: Labels, Prev: Truncating the Stack, Up: Display Modes

Justification
-------------

Values on the stack are normally left-justified in the window.  You
can control this arrangement by typing `d <' (`calc-left-justify'), `d
>' (`calc-right-justify'), or `d =' (`calc-center-justify').  For
example, in right-justification mode, stack entries are displayed
flush-right against the right edge of the window.

If you change the width of the Calculator window you may have to type
`d SPC' (`calc-refresh') to re-align right-justified or centered text.

Right-justification is especially useful together with fixed-point
notation (see `d f'; `calc-fix-notation').  With these modes together,
the decimal points on numbers will always line up.

With a numeric prefix argument, the justification commands give you a
little extra control over the display.  The argument specifies the
horizontal "origin" of a display line.  It is also possible to specify
a maximum line width using the `d b' command (*Note Normal Language
Modes::).  For reference, the precise rules for formatting and
breaking lines are given below.  Notice that the interaction between
origin and line width is slightly different in each justification
mode.

In left-justified mode, the line is indented by a number of spaces
given by the origin (default zero).  If the result is longer than the
maximum line width, if given, or too wide to fit in the Calc window
otherwise, then it is broken into lines which will fit; each broken
line is indented to the origin.

In right-justified mode, lines are shifted right so that the rightmost
character is just before the origin, or just before the current window
width if no origin was specified.  If the line is too long for this,
then it is broken; the current line width is used, if specified, or
else the origin is used as a width if that is specified, or else the
line is broken to fit in the window.

In centering mode, the origin is the column number of the center of
each stack entry.  If a line width is specified, lines will not be
allowed to go past that width; Calc will either indent less or break
the lines if necessary.  If no origin is specified, half the line
width or Calc window width is used.

Note that, in each case, if line numbering is enabled the display is
indented an additional four spaces to make room for the line number.
The width of the line number is taken into account when positioning
according to the current Calc window width, but not when positioning
by explicit origins and widths.  In the latter case, the display is
formatted as specified, and then uniformly shifted over four spaces to
fit the line numbers.



File: calc.info, Node: Labels, Prev: Justification, Up: Display Modes

Labels
------

The `d {' (`calc-left-label') command prompts for a string, then
displays that string to the left of every stack entry.  If the entries
are left-justified (*Note Justification::), then they will appear
immediately after the label (unless you specified an origin greater
than the length of the label).  If the entries are centered or
right-justified, the label appears on the far left and does not affect
the horizontal position of the stack entry.

Give a blank string (with `d { RET') to turn the label off.

The `d }' (`calc-right-label') command similarly adds a label on the
righthand side.  It does not affect positioning of the stack entries
unless they are right-justified.  Also, if both a line width and an
origin are given in right-justified mode, the stack entry is justified
to the origin and the righthand label is justified to the line width.

One application of labels would be to add equation numbers to formulas
you are manipulating in Calc and then copying into a document
(possibly using Embedded Mode).  The equations would typically be
centered, and the equation numbers would be on the left or right as
you prefer.



File: calc.info, Node: Language Modes, Next: Modes Variable, Prev: Display Modes, Up: Mode Settings

Language Modes
==============

The commands in this section change Calc to use a different notation
for entry and display of formulas, corresponding to the conventions of
some other common language such as Pascal or TeX.  Objects displayed
on the stack or yanked from the Calculator to an editing buffer will
be formatted in the current language; objects entered in algebraic
entry or yanked from another buffer will be interpreted according to
the current language.

The current language has no effect on things written to or read from
the trail buffer, nor does it affect numeric entry.  Only algebraic
entry is affected.  You can make even algebraic entry ignore the
current language and use the standard notation by giving a numeric
prefix, e.g., `C-u ''.

For example, suppose the formula `2*a[1] + atan(a[2])' occurs in a C
program; elsewhere in the program you need the derivatives of this
formula with respect to `a[1]' and `a[2]'.  First, type `d C' to
switch to C notation.  Now use `C-u M-# g' to grab the formula into
the Calculator, `a d a[1] RET' to differentiate with respect to the
first variable, and `M-# y' to yank the formula for the derivative
back into your C program.  Press `U' to undo the differentiation and
repeat with `a d a[2] RET' for the other derivative.

Without being switched into C mode first, Calc would have
misinterpreted the brackets in `a[1]' and `a[2]', would not have known
that `atan' was equivalent to Calc's built-in `arctan' function, and
would have written the formula back with notations (like implicit
multiplication) which would not have been legal for a C program.

As another example, suppose you are maintaining a C program and a TeX
document, each of which needs a copy of the same formula.  You can
grab the formula from the program in C mode, switch to TeX mode, and
yank the formula into the document in TeX math-mode format.

Language modes are selected by typing the letter `d' followed by a
shifted letter key.

* Menu:

* Normal Language Modes::
* C FORTRAN Pascal::
* TeX Language Mode::
* Eqn Language Mode::
* Mathematica Language Mode::
* Maple Language Mode::
* Compositions::
* Syntax Tables::



File: calc.info, Node: Normal Language Modes, Next: C FORTRAN Pascal, Prev: Language Modes, Up: Language Modes

Normal Language Modes
---------------------

The `d N' (`calc-normal-language') command selects the usual notation
for Calc formulas, as described in the rest of this manual.  Matrices
are displayed in a multi-line tabular format, but all other objects
are written in linear form, as they would be typed from the keyboard.

The `d O' (`calc-flat-language') command selects a language identical
with the normal one, except that matrices are written in one-line form
along with everything else.  In some applications this form may be
more suitable for yanking data into other buffers.

Even in one-line mode, long formulas or vectors will still be split
across multiple lines if they exceed the width of the Calculator
window.  The `d b' (`calc-line-breaking') command turns this
line-breaking feature on and off.  (It works independently of the
current language.)  If you give a numeric prefix argument of five or
greater to the `d b' command, that argument will specify the line
width used when breaking long lines.

The `d B' (`calc-big-language') command selects a language which uses
textual approximations to various mathematical notations, such as
powers, quotients, and square roots:

       ____________
      | a + 1    2
      | ----- + c
     \|   b

in place of `sqrt((a+1)/b + c^2)'.

Subscripts like `a_i' are displayed as actual subscripts in "big"
mode.  Double subscripts, `a_i_j' (`subscr(subscr(a, i), j)') are
displayed as `a' with subscripts separated by commas: `i, j'.  They
must still be entered in the usual underscore notation.

One slight ambiguity of Big notation is that

       3
     - -
       4

can represent either the negative rational number `-3:4', or the
actual expression `-(3/4)'; but the latter formula would normally
never be displayed because it would immediately be evaluated to `-3:4'
or `-0.75', so this ambiguity is not a problem in typical use.

Non-decimal numbers are displayed with subscripts.  Thus there is no
way to tell the difference between `16#C2' and `C2_16', though
generally you will know which interpretation is correct.  Logarithms
`log(x,b)' and `log10(x)' also use subscripts in Big mode.

In Big mode, stack entries often take up several lines.  To aid
readability, stack entries are separated by a blank line in this mode.
You may find it useful to expand the Calc window's height using `C-x
^' (`enlarge-window') or to make the Calc window the only one on the
screen with `C-x 1' (`delete-other-windows').

Long lines are currently not rearranged to fit the window width in Big
mode, so you may need to use the `<' and `>' keys to scroll across a
wide formula.  For really big formulas, you may even need to use `{'
and `}' to scroll up and down.

The `d U' (`calc-unformatted-language') command altogether disables
the use of operator notation in formulas.  In this mode, the formula
shown above would be displayed:

     sqrt(add(div(add(a, 1), b), pow(c, 2)))

These four modes differ only in display format, not in the format
expected for algebraic entry.  The standard Calc operators work in all
four modes, and unformatted notation works in any language mode
(except that Mathematica mode expects square brackets instead of
parentheses).



File: calc.info, Node: C FORTRAN Pascal, Next: TeX Language Mode, Prev: Normal Language Modes, Up: Language Modes

C, FORTRAN, and Pascal Modes
----------------------------

The `d C' (`calc-c-language') command selects the conventions
of the C language for display and entry of formulas.  This differs from
the normal language mode in a variety of (mostly minor) ways.  In
particular, C language operators and operator precedences are used in
place of Calc's usual ones.  For example, `a^b' means `xor(a,b)'
in C mode; a value raised to a power is written as a function call,
`pow(a,b)'.

In C mode, vectors and matrices use curly braces instead of brackets.
Octal and hexadecimal values are written with leading `0' or `0x'
rather than using the `#' symbol.  Array subscripting is translated
into `subscr' calls, so that `a[i]' in C mode is the same as `a_i' in
normal mode.  Assignments turn into the `assign' function, which Calc
normally displays using the `:=' symbol.

The variables `var-pi' and `var-e' would be displayed `pi' and `e' in
normal mode, but in C mode they are displayed as `M_PI' and `M_E',
corresponding to the names of constants typically provided in the
`<math.h>' header.  Functions whose names are different in C are
translated automatically for entry and display purposes.  For example,
entering `asin(x)' will push the formula `arcsin(x)' onto the stack;
this formula will be displayed as `asin(x)' as long as C mode is in
effect.

The `d P' (`calc-pascal-language') command selects Pascal conventions.
Like C mode, Pascal mode interprets array brackets and uses a
different table of operators.  Hexadecimal numbers are entered and
displayed with a preceding dollar sign.  (Thus the regular meaning of
`$2' during algebraic entry does not work in Pascal mode, though `$'
(and `$$', etc.) not followed by digits works the same as always.)  No
special provisions are made for other non-decimal numbers, vectors,
and so on, since there is no universally accepted standard way of
handling these in Pascal.

The `d F' (`calc-fortran-language') command selects FORTRAN
conventions.  Various function names are transformed into FORTRAN
equivalents.  Vectors are written as `/1, 2, 3/', and may be entered
this way or using square brackets.  Since FORTRAN uses round
parentheses for both function calls and array subscripts, Calc
displays both in the same way; `a(i)' is interpreted as a function
call upon reading, and subscripts must be entered as `subscr(a, i)'.
Also, if the variable `a' has been declared to have type `vector' or
`matrix' then `a(i)' will be parsed as a subscript.  (*Note
Declarations::.)  Usually it doesn't matter, though; if you enter the
subscript expression `a(i)' and Calc interprets it as a function call,
you'll never know the difference unless you switch to another language
mode or replace `a' with an actual vector (or unless `a' happens to be
the name of a built-in function!).

Underscores are allowed in variable and function names in all of these
language modes.  The underscore here is equivalent to the `#' in
normal mode, or to hyphens in the underlying Emacs Lisp variable
names.

FORTRAN and Pascal modes normally do not adjust the case of letters in
formulas.  Most built-in Calc names use lower-case letters.  If you
use a positive numeric prefix argument with `d P' or `d F', these
modes will use upper-case letters exclusively for display, and will
convert to lower-case on input.  With a negative prefix, these modes
convert to lower-case for display and input.



File: calc.info, Node: TeX Language Mode, Next: Eqn Language Mode, Prev: C FORTRAN Pascal, Up: Language Modes

TeX Language Mode
-----------------

The `d T' (`calc-tex-language') command selects the conventions of
math mode" in the TeX typesetting language, by Donald Knuth.  Formulas
are entered and displayed in TeX notation, as in `\sin\left( a \over b
right)'.  Math formulas are usually enclosed by `$ $' signs in TeX;
these should be omitted when interfacing with Calc.  To Calc, the `$'
sign has the same meaning it always does in algebraic formulas (a
reference to an existing entry on the stack).

Complex numbers are displayed as in `3 + 4i'.  Fractions and quotients
are written using `\over'; binomial coefficients are written with
`\choose'.  Interval forms are written with `\ldots', and error forms
are written with `\pm'.  Absolute values are written as in `|x + 1|',
and the floor and ceiling functions are written with `\lfloor',
`\rfloor', etc.  The words `\left' and `\right' are ignored when
reading formulas in TeX mode.  Both `inf' and `uinf' are written as
`\infty'; when read, `\infty' always translates to `inf'.

Function calls are written the usual way, with the function name followed
by the arguments in parentheses.  However, functions for which TeX has
special names (like `\sin') will use curly braces instead of
parentheses for very simple arguments.  During input, curly braces and
parentheses work equally well for grouping, but when the document is
formatted the curly braces will be invisible.  Thus the printed result is
`sin 2x' but `sin(2 + x)'.

Function and variable names not treated specially by TeX are simply
written out as-is, which will cause them to come out in italic letters
in the printed document.  If you invoke `d T' with a positive numeric
prefix argument, names of more than one character will instead be
written `\hbox{NAME}'.  The `\hbox{ }' notation is ignored during
reading.  If you use a negative prefix argument, such function names
are written `\NAME', and function names that begin with `\' during
reading have the `\' removed.  (Note that in this mode, long variable
names are still written with `\hbox'.  However, you can always make an
actual variable name like `\bar' in any TeX mode.)

During reading, text of the form `\matrix{ ... }' is replaced by
`[ ... ]'.  The same also applies to `\pmatrix' and `\bmatrix'.  The
symbol `&' is interpreted as a comma, and the symbols `\cr' and `\\'
are interpreted as semicolons.  During output, matrices are displayed
in `\matrix{ a & b \\ c & d}' format; you may need to edit this
afterwards to change `\matrix' to `\pmatrix' or `\\' to `\cr'.

Accents like `\tilde' and `\bar' translate into function calls
internally (`tilde(x)', `bar(x)').  The `\underline' sequence is
treated as an accent.  The `\vec' accent corresponds to the function
name `Vec', because `vec' is the name of a built-in Calc function.
The following table shows the accents in Calc, TeX, and "eqn"
(described in the next section):

     Calc      TeX           eqn
     ----      --           ---
     acute     \acute
     bar       \bar          bar
     breve     \breve
     check     \check
     dot       \dot          dot
     dotdot    \ddot         dotdot
     dyad                    dyad
     grave     \grave
     hat       \hat          hat
     Prime                   prime
     tilde     \tilde        tilde
     under     \underline    under
     Vec       \vec          vec

The `=>' (evaluates-to) operator appears as a `\to' symbol: `{A \to
B}'.  TeX defines `\to' as an alias for `\rightarrow'.  However, if
the `=>' is the top-level expression being formatted, a slightly
different notation is used: `\evalto A \to B'.  The `\evalto' word is
ignored by Calc's input routines, and is undefined in TeX.  You will
typically want to include one of the following definitions at the top
of a TeX file that uses `\evalto':

     \def\evalto{}
     \def\evalto#1\to{}

The first definition formats evaluates-to operators in the usual
way.  The second causes only the B part to appear in the
printed document; the A part and the arrow are hidden.
Another definition you may wish to use is `\let\to=\Rightarrow'
which causes `\to' to appear more like Calc's `=>' symbol.
*Note Evaluates-To Operator::, for a discussion of `evalto'.

The complete set of TeX control sequences that are ignored during
reading is:

     \hbox  \mbox  \text  \left  \right
     \,  \>  \:  \;  \!  \quad  \qquad  \hfil  \hfill
     \displaystyle  \textstyle  \dsize  \tsize
     \scriptstyle  \scriptscriptstyle  \ssize  \ssize
     \rm  \bf  \it  \sl  \roman  \bold  \italic  \slanted
     \cal  \mit  \Cal  \Bbb  \frak  \goth
     \evalto

Note that, because these symbols are ignored, reading a TeX formula
into Calc and writing it back out may lose spacing and font
information.

Also, the "discretionary multiplication sign" `\*' is read the same as
`*'.

The TeX version of this manual includes some printed examples at the
end of this section.



File: calc.info, Node: Eqn Language Mode, Next: Mathematica Language Mode, Prev: TeX Language Mode, Up: Language Modes

Eqn Language Mode
-----------------

"Eqn" is another popular formatter for math formulas.  It is designed
for use with the TROFF text formatter, and comes standard with many
versions of Unix.  The `d E' (`calc-eqn-language') command selects
eqn" notation.

The "eqn" language's main idiosyncrasy is that whitespace plays a
significant part in the parsing of the language.  For example, `sqrt
x+1 + y' treats `x+1' as the argument of the `sqrt' operator.  "Eqn"
also understands more conventional grouping using curly braces:
`sqrt{x+1} + y'.  Braces are required only when the argument contains
spaces.

In Calc's "eqn" mode, however, curly braces are required to delimit
arguments of operators like `sqrt'.  The first of the above examples
would treat only the `x' as the argument of `sqrt', and in fact `sin
x+1' would be interpreted as `sin * x + 1', because `sin' is not a
special operator in the "eqn" language.  If you always surround the
argument with curly braces, Calc will never misunderstand.

Calc also understands parentheses as grouping characters.  Another
peculiarity of "eqn"'s syntax makes it advisable to separate words
with spaces from any surrounding characters that aren't curly braces,
so Calc writes `sin ( x + y )' in "eqn" mode.  (The spaces around
`sin' are important to make "eqn" recognize that `sin' should be
typeset in a roman font, and the spaces around `x' and `y' are a good
idea just in case the "eqn" document has defined special meanings for
these names, too.)

Powers and subscripts are written with the `sub' and `sup' operators,
respectively.  Note that the caret symbol `^' is treated the same as a
space in "eqn" mode, as is the `~' symbol (these are used to introduce
spaces of various widths into the typeset output of "eqn").

As in TeX mode, Calc's formatter omits parentheses around the
arguments of functions like `ln' and `sin' if they are
simple-looking"; in this case Calc surrounds the argument with braces,
separated by a `~' from the function name: `sin~{x}'.

Font change codes (like `roman X') and positioning codes (like `~' and
`down N X') are ignored by the "eqn" reader.  Also ignored are the
words `left', `right', `mark', and `lineup'.  Quotation marks in "eqn"
mode input are treated the same as curly braces: `sqrt "1+x"' is
equivalent to `sqrt {1+x}'; this is only an approximation to the true
meaning of quotes in "eqn", but it is good enough for most uses.

Accent codes (`X dot') are handled by treating them as
function calls (`dot(X)') internally.  *Note TeX Language Mode:: for a table of these accent functions.  The `prime' accent
is treated specially if it occurs on a variable or function name:
`f prime prime ( x prime )' is stored internally as
`f''(x')'.  For example, taking the derivative of `f(2 x)'
with `a d x' will produce `2 f'(2 x)', which "eqn" mode
will display as `2 f prime ( 2 x )'.

Assignments are written with the `<-' (left-arrow) symbol, and
`evalto' operators are written with `->' or `evalto ... ->' (*Note TeX
Language Mode::, for a discussion of this).  The regular Calc symbols
`:=' and `=>' are also recognized for these operators during reading.

Vectors in "eqn" mode use regular Calc square brackets, but matrices
are formatted as `matrix { ccol { a above b } ... }'.  The words
`lcol' and `rcol' are recognized as synonyms for `ccol' during input,
and are generated instead of `ccol' if the matrix justification mode
so specifies.



File: calc.info, Node: Mathematica Language Mode, Next: Maple Language Mode, Prev: Eqn Language Mode, Up: Language Modes

Mathematica Language Mode
-------------------------

The `d M' (`calc-mathematica-language') command selects the
conventions of Mathematica, a powerful and popular mathematical tool
from Wolfram Research, Inc.  Notable differences in Mathematica mode
are that the names of built-in functions are capitalized, and function
calls use square brackets instead of parentheses.  Thus the Calc
formula `sin(2 x)' is entered and displayed `Sin[2 x]' in
Mathematica mode.

Vectors and matrices use curly braces in Mathematica.  Complex numbers
are written `3 + 4 I'.  The standard special constants in Calc are
written `Pi', `E', `I', `GoldenRatio', `EulerGamma', `Infinity',
`ComplexInfinity', and `Indeterminate' in Mathematica mode.
Non-decimal numbers are written, e.g., `16^^7fff'.  Floating-point
numbers in scientific notation are written `1.23*10.^3'.  Subscripts
use double square brackets: `a[[i]]'.



